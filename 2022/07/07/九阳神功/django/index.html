<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>django | 可乐就炸鸡の葵花宝典</title><meta name="keywords" content="django"><meta name="author" content="可乐就炸鸡"><meta name="copyright" content="可乐就炸鸡"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考： Web 开发简介 | 白月黑羽 (byhy.net) 安装与运行安装django2pip install django&#x3D;&#x3D;2.2升级到最新版pip install django -U查看版本python -m django --version创建工程django-admin startproject bysms(工程名)运行项目python manage.py runserver 0.0.">
<meta property="og:type" content="article">
<meta property="og:title" content="django">
<meta property="og:url" content="https://cobwebzh.top/2022/07/07/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/django/index.html">
<meta property="og:site_name" content="可乐就炸鸡の葵花宝典">
<meta property="og:description" content="参考： Web 开发简介 | 白月黑羽 (byhy.net) 安装与运行安装django2pip install django&#x3D;&#x3D;2.2升级到最新版pip install django -U查看版本python -m django --version创建工程django-admin startproject bysms(工程名)运行项目python manage.py runserver 0.0.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.dmoe.cc/random.php">
<meta property="article:published_time" content="2022-07-07T07:25:00.000Z">
<meta property="article:modified_time" content="2022-10-18T07:18:46.979Z">
<meta property="article:author" content="可乐就炸鸡">
<meta property="article:tag" content="django">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.dmoe.cc/random.php"><link rel="shortcut icon" href="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012058447.png"><link rel="canonical" href="https://cobwebzh.top/2022/07/07/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/django/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'django',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-10-18 15:18:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012052210.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://www.dmoe.cc/random.php')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">可乐就炸鸡の葵花宝典</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">django</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-07T07:25:00.000Z" title="发表于 2022-07-07 15:25:00">2022-07-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-18T07:18:46.979Z" title="更新于 2022-10-18 15:18:46">2022-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/">九阳神功</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="django"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.byhy.net/tut/webdev/django/01/">Web 开发简介 | 白月黑羽 (byhy.net)</a></p>
<h2 id="安装与运行"><a href="#安装与运行" class="headerlink" title="安装与运行"></a>安装与运行</h2><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">安装django2</span></span><br><span class="line"><span class="language-xml">pip install django==2.2</span></span><br><span class="line"><span class="language-xml">升级到最新版</span></span><br><span class="line"><span class="language-xml">pip install django -U</span></span><br><span class="line"><span class="language-xml">查看版本</span></span><br><span class="line"><span class="language-xml">python -m django --version</span></span><br><span class="line"><span class="language-xml">创建工程</span></span><br><span class="line"><span class="language-xml">django-admin startproject bysms(工程名)</span></span><br><span class="line"><span class="language-xml">运行项目</span></span><br><span class="line"><span class="language-xml">python manage.py runserver 0.0.0.0:80</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220317194109737.png" alt="image-20220317194109737"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220317194150643.png" alt="image-20220317194150643"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220317194214302.png" alt="image-20220317194214302"></p>
<h2 id="url路由"><a href="#url路由" class="headerlink" title="url路由"></a>url路由</h2><h3 id="创建项目app"><a href="#创建项目app" class="headerlink" title="创建项目app"></a>创建项目app</h3><p>Django 中的一个app 就是项目里面的一个应用的意思。</p>
<p>一个项目包含多个app。</p>
<p>一个app 通常就是一个相对独立的模块 ，实现相对独立的功能。</p>
<p>比如，我们可以把 这个系统的 管理员管理的功能 做在一个名字为 mgr的app里面，把 销售人员的操作 实现在另外一个名字为 sales的app里面。</p>
<p>一个app 本质上 就是一个 Python 包， 里面包含了一些应用相关的代码文件。</p>
<p>当然，一个项目分成多少个app 这完全取决你的设计。 你把所有的功能都放入一个大app内也可以实现功能，只是这样做，这个app特别的臃肿。</p>
<p>Django 中创建app 可以 通过执行命令，创建一个app目录，并在里面自动创建app常用的文件。</p>
<p>比如，现在我们需要一个app 专门处理 白月医药系统中销售员的 添加、修改、查询、删除请求。</p>
<p>我们就进入项目根目录，执行下面的命令。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">python manage.py startapp sales</span></span><br></pre></td></tr></table></figure>

<h3 id="view-py"><a href="#view-py" class="headerlink" title="view.py"></a>view.py</h3><p>views.py  这个文件里面通常是写处理http 请求的代码的。</p>
<p>比如，我们 设计 凡是浏览器访问的http 请求的 url 地址 是 <code>/sales/orders/</code> , 就由 views.py 里面的函数 <code>listorders</code> 来处理， 返回一段字符串给浏览器。</p>
<p>打开 views.py , 在里面加入如下内容</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">from django.http import HttpResponse</span></span><br><span class="line"><span class="language-xml">from django.shortcuts import render</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"># Create your views here.</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">def listorder(request):</span></span><br><span class="line"><span class="language-xml">    return HttpResponse(&quot;下面是系统中所有的订单信息&quot;);</span></span><br></pre></td></tr></table></figure>



<h3 id="添加路由记录"><a href="#添加路由记录" class="headerlink" title="添加路由记录"></a>添加路由记录</h3><p>前面在创建项目目录的时候，在项目的设置目录下，有如下的一个urls.py 文件</p>
<p>这个文件是 url路由设置的入口文件。</p>
<p>打开该文件，在 <code>urlpatterns</code> 列表变量中添加一条路由信息，结果如下</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">from django.contrib import admin</span></span><br><span class="line"><span class="language-xml">from django.urls import path</span></span><br><span class="line"><span class="language-xml">from sales.views import listorders</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">urlpatterns = [</span></span><br><span class="line"><span class="language-xml">    path(&#x27;admin/&#x27;, admin.site.urls),</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    path(&#x27;sales/orders/&#x27;, listorders),</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">]</span></span><br></pre></td></tr></table></figure>

<p><code>urlpatterns</code> 列表 就是 Django 的 url 路由的入口。</p>
<h3 id="路由子表"><a href="#路由子表" class="headerlink" title="路由子表"></a>路由子表</h3><p>url 路由表就是可以像上面这样，一个请求对应一个处理函数。</p>
<p>但是有的时候，我们的项目比较大的时候， 请求的url 会特别多。</p>
<p>复杂的系统url条目多达几百甚至上千个， 放在一个表中，查看时，要找一条路由记录就非常麻烦。</p>
<p>这时，我们通常可以将不同的路由记录 按照功能 分拆到不同的 <strong>url路由子表</strong> 文件中。</p>
<p>比如，这里我们可以把 访问 的 url 凡是 以 <code>sales</code> 开头的全部都 由 sales app目录下面的 子路由文件 urls.py 处理。</p>
<p>首先我们需要在 sales 目录下面创建一个新的文件 <code>sales\urls.py</code> 。</p>
<p>然后在这个 <code>sales\urls.py</code> 文件中输入如下内容</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">from django.urls import path</span></span><br><span class="line"><span class="language-xml">from sales.views import listorders, listorders1</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">urlpatterns = [</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    path(&#x27;orders/&#x27;, listorders),</span></span><br><span class="line"><span class="language-xml">    path(&#x27;orders1/&#x27;, listorders1),</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">]</span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure>

<p>然后，我们再修改主url路由文件 <code>bysms/urls.py</code> , 如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;sales/&#x27;</span>, include(<span class="string">&#x27;sales.urls&#x27;</span>)),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>当一个http请求过来时， Django检查 url，比如这里是 <code>sales/orders/</code>，</p>
<p>先到主url路由文件 <code>bysms/urls.py</code>中查看 是否有匹配的路由项。</p>
<p>如果有匹配 ( 这里匹配了 <code>sales/</code> )， 并且匹配的对象 不是 函数， 而是 一个子路由设置 , 比如这里是 <code>include(&#39;sales.urls&#39;)</code></p>
<p>就会去子路由文件中查看， 这里就是 sales.urls 对应的文件 <code>sales\urls.py</code> 。</p>
<p>注意这时，会从请求url中去掉 前面主路由文件 已经匹配上的部分（这里是 <code>sales/</code> ）, 将剩余的部分 （这里是 <code>orders/</code> ）去子路由文件中查看是否有匹配的路由项。</p>
<p>这里就匹配了 <code>orders/</code> ，匹配的对象，这里是 <code>views.listorders</code> ，它是一个处理函数，就调用该函数处理 这个http请求， 将该函数的返回对象 构建 HTTP响应消息，返回给客户端。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>项目中数据库的配置在 <code>bysms/settings.py</code> 中，这里</p>
<p>MySQL数据库需要先在数据库中创建数据库名，还要确保有mysqlclient库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="comment"># &#x27;default&#x27;: &#123;</span></span><br><span class="line">    <span class="comment">#     &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span></span><br><span class="line">    <span class="comment">#     &#x27;NAME&#x27;: BASE_DIR / &#x27;db.sqlite3&#x27;,</span></span><br><span class="line">    <span class="comment"># &#125;,</span></span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;bysms&#x27;</span>,  <span class="comment"># 数据库名</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,  <span class="comment"># 数据库 用户名</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;zhaohui&#x27;</span>,  <span class="comment"># 数据库 用户密码</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,  <span class="comment"># 数据库服务主机名</span></span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,  <span class="comment"># 数据库服务端口</span></span><br><span class="line">        <span class="string">&#x27;CONN_MAX_AGE&#x27;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们需要创建数据库，执行如下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>就会生成db.sqlite3或mysql数据库</p>
<p>Django 里面， 数据库表的操作，包括 表的定义、表中数据的增删改查，都可以通过 <strong>Model</strong> 类型的对象进行的。</p>
<p>通常，在Django中</p>
<ul>
<li>定义一张数据库的表 就是定义一个继承自 django.db.models.Model 的类</li>
<li>定义该表中的字段（列）， 就是定义该类里面的一些属性</li>
<li>类的方法就是对该表中数据的处理方法，包括 数据的增删改查</li>
</ul>
<p>这样，开发者对数据库的访问，从原来的使用底层的 sql 语句，变成 面向对象的开发，通过一系列对象的类定义 和方法调用就可以 操作数据库。</p>
<p>创建一个名为common的应用目录， 里面存放我们项目需要的一些公共的表的定义</p>
<p>前面已经说过，Django是通过定义类来定义数据库表的。</p>
<p>所以，我们要定义数据库的表，无需执行sql语句，只需要在app目录下面 定义特殊的类就可以了。</p>
<p>数据库表的定义，一般是放在app目录中的 models.py里面的。</p>
<p>打开 common&#x2F;models.py，发现里面是空的，因为我们还没有定义我们的业务所需要的表。</p>
<p>我们修改它，加入如下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>(models.Model):</span><br><span class="line">    <span class="comment">#客户名称</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment">#电话</span></span><br><span class="line">    phonenumber = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    <span class="comment">#地址</span></span><br><span class="line">    address = models.CharField(max_length=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>这个 Customer 类继承自 django.db.models.Model， 就是用来定义数据库表的。</p>
<p>里面的 name、phonenumber、address 是该表的3个字段。</p>
<p>定义表中的字段 就是定义一些静态属性，这些属性是 django.db.models 里面的各种 Field 对象，对应不同类型的字段。</p>
<p>比如这里的3个字段 都是 CharField 对象，对应 varchar类型的数据库字段。</p>
<p>后面的参数 <code>max_length</code> 指明了该 varchar字段的 最大长度。</p>
<p>Django 有很多字段对象类型， 对应不同的类型的数据库字段。</p>
<p>大家可以参考<a target="_blank" rel="noopener" href="https://docs.djangoproject.com/en/2.0/ref/models/fields/#model-field-types">官方文档</a></p>
<p>定义好表以后，我们怎么真正去创建数据库表呢？</p>
<p>首先我们需要告诉Django： 我们的 common 应用中 需要你关注， 因为其中包含了 数据库Model的定义。</p>
<p>怎么告诉它？ 在项目的配置文件 <code>settings.py </code>中， INSTALLED_APPS 配置项 加入如下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;common.apps.CommonConfig&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在Django知道了我们的 common 应用， 我们可以在项目根目录下执行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations common</span><br></pre></td></tr></table></figure>

<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220317211836362.png" alt="image-20220317211836362"></p>
<p>这个命令，告诉Django ， 去看看common这个app里面的models.py ，我们已经修改了数据定义， 你现在去产生相应的更新脚本。</p>
<p>执行一下，会发现在 common\migrations 目录下面出现了0001_initial.py, 这个脚本就是相应要进行的数据库操作代码。</p>
<p>随即，执行如下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220317212153658.png" alt="image-20220317212153658"></p>
<p>就真正去数据库创建表了。</p>
<p>Django Admin 管理数据</p>
<p>Django提供了一个管理员操作界面可以方便的 添加、修改、删除你定义的 model 表数据。</p>
<p>首先，我们需要创建 一个超级管理员账号。</p>
<p>进入到项目的根目录，执行如下命令，依次输入你要创建的管理员的 登录名、email、密码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<p>然后我们需要修改应用里面的 管理员 配置文件 common&#x2F;admin.py，注册我们定义的model类。这样Django才会知道</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Customer</span><br><span class="line"></span><br><span class="line">admin.site.register(Customer)</span><br></pre></td></tr></table></figure>



<h3 id="读取数据库表"><a href="#读取数据库表" class="headerlink" title="读取数据库表"></a>读取数据库表</h3><p>Django 中 对数据库表的操作， 应该都通过 Model对象 实现对数据的读写，而不是通过SQL语句。</p>
<p>比如，这里我们要获取 customer 表 所有记录， 该表是和我们前面定义的 Customer 类管理的。</p>
<p>我们可以这样获取所有的表记录:</p>
<p>在文件sales&#x2F;views.py 中，定义一个listcustomers 函数，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> common.models <span class="keyword">import</span> Customer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcustomers</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个QuerySet对象</span></span><br><span class="line">    <span class="comment"># 每条记录都是一个dict对象</span></span><br><span class="line">    <span class="comment"># key是字段名，value是字段值</span></span><br><span class="line"></span><br><span class="line">    qs = Customer.objects.values()</span><br><span class="line">    <span class="comment"># 定义返回字符串</span></span><br><span class="line">    retStr = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> customer <span class="keyword">in</span> qs:</span><br><span class="line">        <span class="keyword">for</span> name,value <span class="keyword">in</span> customer.items():</span><br><span class="line">            retStr += <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> : <span class="subst">&#123;value&#125;</span> | &#x27;</span></span><br><span class="line"></span><br><span class="line">        retStr += <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(retStr)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Customer.objects.values() 就会返回一个 QuerySet 对象，这个对象是Django 定义的，在这里它包含所有的Customer 表记录。</p>
<p>QuerySet 对象 可以使用 for 循环遍历取出里面所有的元素。每个元素 对应 一条表记录。</p>
<p>每条表记录元素都是一个dict对象，其中 每个元素的 key 是表字段名，value 是 该记录的字段值</p>
<p>上面的代码就可以将 每条记录的信息存储到字符串中 返回给 前端浏览器。</p>
<p>我们还需要修改路由表， 加上对 <code>sales/customers/</code> url请求的 路由。</p>
<p>前面，我们在bysms\urls.py 主路由文件中，已经有如下的记录了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> sales.views <span class="keyword">import</span> listorders, listorders1, listcustomers</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;orders/&#x27;</span>, listorders),</span><br><span class="line">    path(<span class="string">&#x27;orders1/&#x27;</span>, listorders1),</span><br><span class="line">    path(<span class="string">&#x27;customers/&#x27;</span>, listcustomers),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h3><p>有的时候，我们需要根据过滤条件查询部分客户信息。</p>
<p>比如，当用户在浏览器输入 <code>/sales/customers/?phonenumber=13000000001</code> ，要求返回电话号码为 13000000001 客户记录。</p>
<p>我们可以通过 <code>filter</code> 方法加入过滤条件，修改view里面的代码，如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listcustomers</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个QuerySet对象</span></span><br><span class="line">    <span class="comment"># 每条记录都是一个dict对象</span></span><br><span class="line">    <span class="comment"># key是字段名，value是字段值</span></span><br><span class="line">    qs = Customer.objects.values()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查url中是否有参数</span></span><br><span class="line">    ph = request.GET.get(<span class="string">&#x27;phonenumber&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ph:</span><br><span class="line">        qs = qs.<span class="built_in">filter</span>(phonenumber=ph)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义返回字符串</span></span><br><span class="line">    retStr = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> customer <span class="keyword">in</span> qs:</span><br><span class="line">        <span class="keyword">for</span> name,value <span class="keyword">in</span> customer.items():</span><br><span class="line">            retStr += <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> : <span class="subst">&#123;value&#125;</span> | &#x27;</span></span><br><span class="line"></span><br><span class="line">        retStr += <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(retStr)</span><br></pre></td></tr></table></figure>

<p>Django 框架在 url 路由匹配到函数后， 调用函数时，会传入 一个 HttpRequest 对象给参数变量 request，该对象里面 包含了请求的数据信息。</p>
<p>HTTP 的 Get 请求url里面的参数（术语叫 querystring 里面的参数）， 可以通过 HttpRequest对象的 GET 属性获取。这是一个类似dict的对象。</p>
<p>比如要获取querystring里面的 phonenumber 参数 ，就可以像这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ph =  request.GET.get(<span class="string">&#x27;phonenumber&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>第二个参数传入 None 表示，如果没有 phonenumber 参数在 querystring中 ，就会返回 None。</p>
<p>然后通过调用 QuerySet 对象的filter方法，就可以把查询过滤条件加上去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qs = qs.<span class="built_in">filter</span>(phonenumber=ph)</span><br></pre></td></tr></table></figure>

<p>有了这个过滤条件，Django 会在底层执行数据库查询的SQL语句 加上相应的 where 从句，进行过滤查询。</p>
<p>注意，参数名 phonenumber 是和 定义的表 model 的属性名 phonenumber 一致的。</p>
<p>filter的过滤条件可以有多个，只要继续在后面的参数添加过滤条件即可。</p>
<p>比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qs = qs.<span class="built_in">filter</span>(phonenumber=ph,address=<span class="string">&#x27;安徽芜湖&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样就 除了 根据电话号码字段过滤，还有根据 地址字段过滤。</p>
<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><h3 id="直接生成HTML代码返回"><a href="#直接生成HTML代码返回" class="headerlink" title="直接生成HTML代码返回"></a>直接生成HTML代码返回</h3><p>HTML本身其实也是字符串，只是这个字符串里面的内容是符合HTML语言规范的。</p>
<p>既然它也是字符串，我们可以使用Python直接构建出 HTML 字符串内容。</p>
<p>修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先定义好HTML模板</span></span><br><span class="line">html_template =<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;style&gt;</span></span><br><span class="line"><span class="string">table &#123;</span></span><br><span class="line"><span class="string">    border-collapse: collapse;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">th, td &#123;</span></span><br><span class="line"><span class="string">    padding: 8px;</span></span><br><span class="line"><span class="string">    text-align: left;</span></span><br><span class="line"><span class="string">    border-bottom: 1px solid #ddd;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;table&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;id&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;姓名&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;电话号码&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;地址&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        %s</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcustomers</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Customer.objects.values()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查url中是否有参数phonenumber</span></span><br><span class="line">    ph =  request.GET.get(<span class="string">&#x27;phonenumber&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果有，添加过滤条件</span></span><br><span class="line">    <span class="keyword">if</span> ph:</span><br><span class="line">        qs = qs.<span class="built_in">filter</span>(phonenumber=ph)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成html模板中要插入的html片段内容</span></span><br><span class="line">    tableContent = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> customer <span class="keyword">in</span>  qs:</span><br><span class="line">        tableContent += <span class="string">&#x27;&lt;tr&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name,value <span class="keyword">in</span> customer.items():</span><br><span class="line">            tableContent += <span class="string">f&#x27;&lt;td&gt;<span class="subst">&#123;value&#125;</span>&lt;/td&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">        tableContent += <span class="string">&#x27;&lt;/tr&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(html_template%tableContent)</span><br></pre></td></tr></table></figure>



<h3 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h3><p>上面我们是用Python代码直接拼接出html内容。</p>
<p>但是这种方式，我们代码处理比较麻烦。特别是，如果html里面有多处内容需要填入，使用Python代码直接拼接就显得很繁杂，不好维护。</p>
<p>很多后端框架都提供了一种 模板技术， 可以在html 中嵌入编程语言代码片段， 用模板引擎（就是一个专门处理HTML模板的库）来动态的生成HTML代码。</p>
<p>比如JavaEE 里面的JSP。</p>
<p>Python 中有很多这样的模板引擎 比如 jinja2 、Mako， Django也内置了一个这样的模板引擎。</p>
<p>我们修改一下代码，使用Django的模板引擎</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先定义好HTML模板</span></span><br><span class="line">html_template =<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;style&gt;</span></span><br><span class="line"><span class="string">table &#123;</span></span><br><span class="line"><span class="string">    border-collapse: collapse;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">th, td &#123;</span></span><br><span class="line"><span class="string">    padding: 8px;</span></span><br><span class="line"><span class="string">    text-align: left;</span></span><br><span class="line"><span class="string">    border-bottom: 1px solid #ddd;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;table&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;id&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;姓名&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;电话号码&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;th&gt;地址&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#123;% for customer in customers %&#125;</span></span><br><span class="line"><span class="string">            &lt;tr&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &#123;% for name, value in customer.items %&#125;            </span></span><br><span class="line"><span class="string">                &lt;td&gt;&#123;&#123; value &#125;&#125;&lt;/td&gt;            </span></span><br><span class="line"><span class="string">            &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">        &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> engines</span><br><span class="line">django_engine = engines[<span class="string">&#x27;django&#x27;</span>]</span><br><span class="line">template = django_engine.from_string(html_template)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcustomers</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Customer.objects.values()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查url中是否有参数phonenumber</span></span><br><span class="line">    ph =  request.GET.get(<span class="string">&#x27;phonenumber&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果有，添加过滤条件</span></span><br><span class="line">    <span class="keyword">if</span> ph:</span><br><span class="line">        qs = qs.<span class="built_in">filter</span>(phonenumber=ph)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 传入渲染模板需要的参数</span></span><br><span class="line">    rendered = template.render(&#123;<span class="string">&#x27;customers&#x27;</span>:qs&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(rendered)</span><br></pre></td></tr></table></figure>

<h3 id="前后端分离-1"><a href="#前后端分离-1" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>服务端就<strong>只负责提供数据</strong>， 界面的构成全部在前端（浏览器前端或者手机前端）进行，称之为前端渲染。</p>
<p>只是这个工作在前端执行， 使用前端的 框架库去完成，比如 Angular，React，Vue。</p>
<p>这样 界面完全交给前端开发人员去做， 后端开发只需要提供前端界面所需要的数据就行了。</p>
<p>前端 和 后端 之间的交互就完全是 业务数据了。</p>
<p>这样需要 定义好 前端和后端 交互数据 的接口。</p>
<p>目前通常这样的接口设计最普遍的就是使用 REST 风格的 API 接口。</p>
<p>前端通过 API 接口 从后端获取数据展示在界面上。</p>
<p>前端通过 API 接口 告诉后端需要更新的数据是什么。</p>
<p>通常 前后端的 API 接口 是由 架构师 设计的， 有时也可以由经验丰富的前端开发者、或者后端开发者设计。</p>
<p>接下来我们就聚焦在后端，我们的系统前端由另外的团队开发，我们只负责后端业务数据的维护</p>
<p>现在我们的系统，API接口 已经由架构师定义好了， <a target="_blank" rel="noopener" href="https://www.byhy.net/tut/webdev/django/doc_api_v1_0/">点击这里查看</a></p>
<p>我们只需要根据这个接口文档，实现后端系统的部分。</p>
<p>注意：需要Django返回的信息，通常都是所谓的 <code>动态</code> 数据信息。 比如：用户信息，药品信息，订单信息，等等。</p>
<p>这些信息通常都是存在数据库中，这些信息是会随着系统的使用发生变化的。</p>
<p>而 <code>静态</code> 信息，比如： 页面HTML文档、css文档、图片、视频等，是不应该由 Django 负责返回数据的。</p>
<p>这些数据通常都是由其他的 静态资源服务软件，比如 Nginx、Varnish等等，返回给前端。这些软件都会有效的对静态数据进行缓存，大大提高服务效率。在实际的项目中，往往还会直接使用 静态文件 云服务（ OSS + CDN ）提供静态数据的访问服务。</p>
<p>总之，Django处理并返回的应该是动态业务数据信息。</p>
<h2 id="对资源的增删改查"><a href="#对资源的增删改查" class="headerlink" title="对资源的增删改查"></a>对资源的增删改查</h2><h3 id="创建-mgr应用目录"><a href="#创建-mgr应用目录" class="headerlink" title="创建 mgr应用目录"></a>创建 mgr应用目录</h3><p>接口文档明确说明了，这是针对 <strong>管理员用户</strong> 的 请求。</p>
<p>前面我们已经为 <strong>销售员用户</strong> 专门创建了一个应用 sales 来处理相关的 请求。</p>
<p>所以，我们可以 再为 <strong>管理员用户</strong> 专门创建一个应用 mgr 来处理相关的 请求。 怎么创建还记得吗？</p>
<p>对了，执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py startapp mgr </span><br></pre></td></tr></table></figure>



<p>前面，我们都是在views.py 里面定义函数，处理 http请求的。</p>
<p>但是可以想象， 以后，这个mgr应用要处理很多类型的http请求。</p>
<p>都用这个views.py 就会让这个文件非常的庞大， 不好维护。所以，我们可以用不同的 py 文件处理不同类型的http请求。</p>
<p>比如，这里我们可以新增一个文件 customer.py， 专门处理 客户端对 customer 数据的操作。</p>
<p>将来如果客户端有对其他类型数据的操作， 比如 order 数据， 我们就可以添加 orders.py 来处理。</p>
<hr>
<p>接下来，从接口文档，我们可以发现对资源的增删改查 操作， 都是<strong>同一个URL</strong>，都是 <code>/api/mgr/medicine</code> 。</p>
<p>而且我们发现，不同的操作请求，使用不同的 HTTP 请求方法 ，比如 添加是POST， 查询是 GET， 修改是 PUT， 删除是 DELETE。</p>
<p>而且请求的参数中都有 action 参数表明这次请求的操作具体是什么。</p>
<p>注意：Django 的 url路由功能 <strong>不支持</strong> 根据 HTTP 请求的方法 和请求体里面的参数 进行路由。</p>
<p>就是不能像下面这样，来根据请求 是 post 还是 get 来 路由</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;customers/&#x27;</span>, <span class="string">&#x27;app.views.list_customer&#x27;</span>, method=<span class="string">&#x27;get&#x27;</span>),</span><br><span class="line">path(<span class="string">&#x27;customers/&#x27;</span>, <span class="string">&#x27;app.views.add_customer&#x27;</span>,  method=<span class="string">&#x27;post&#x27;</span>),</span><br></pre></td></tr></table></figure>

<p>那么大家想想该怎么办？</p>
<p>一种方式是：自己编写一个函数， 来 根据 http请求的类型 和请求体里面的参数 分发（或者说路由）给 不同的函数进行处理。</p>
<p>我们可以 在 customer.py 中定义如下 dispatcher 函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dispatcher</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 将请求参数统一放入request 的 params 属性中，方便后续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET请求 参数在url中，同过request 对象的 GET属性获取</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        request.params = request.GET</span><br><span class="line"></span><br><span class="line">    <span class="comment"># POST/PUT/DELETE 请求 参数 从 request 对象的 body 属性中获取</span></span><br><span class="line">    <span class="keyword">elif</span> request.method <span class="keyword">in</span> [<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;PUT&#x27;</span>,<span class="string">&#x27;DELETE&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 根据接口，POST/PUT/DELETE 请求的消息体都是 json格式</span></span><br><span class="line">        request.params = json.loads(request.body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据不同的action分派给不同的函数进行处理</span></span><br><span class="line">    action = request.params[<span class="string">&#x27;action&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">&#x27;list_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> listcustomers(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;add_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> addcustomer(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;modify_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> modifycustomer(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;del_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> deletecustomer(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;不支持该类型http请求&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>该函数 把 请求消息中的参数统一放入到 request请求对象的params 属性中。</p>
<p>params 属性 被 做成一个 dict 类型 ， 方便后面的处理函数来获取消息中的参数。</p>
<p>然后 dispatch函数再根据 请求的 类型 和 action 参数的值 决定由那个函数具体处理该请求消息。</p>
<p>比如 action 参数 为 ‘add_customer’ 的 请求 就由 addcustomer 函数 进行处理。</p>
<p>当然在文件的开头，我们需要 先导入 JsonResponse 和 json 的定义，像下面这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>

<hr>
<p>接下来，根据 API 接口 ，我们发现 凡是 API 请求url为 <code>/api/mgr/customers</code> 的，都属于 客户 相关的API， 都应该交由 我们上面定义的dispatch函数进行分派处理。</p>
<p>那么我们需要在Django的url路由文件中加入对应的路由。</p>
<p>所以，</p>
<p>第一步：我们应该在 总路由文件 <code>bysms/urls.py</code> 中定义了如下部分</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 凡是 url 以 api/mgr  开头的，</span></span><br><span class="line"><span class="comment"># 都根据 mgr.urls 里面的 子路由表进行路由</span></span><br><span class="line">path(<span class="string">&#x27;api/mgr/&#x27;</span>, include(<span class="string">&#x27;mgr.urls&#x27;</span>)),</span><br></pre></td></tr></table></figure>

<p>第二步： 在 mgr 目录下面添加 urls.py 路由文件， 并 加入如下声明即可， 如下所示</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mgr <span class="keyword">import</span> customer</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;customers&#x27;</span>, customer.dispatcher),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样，就表示 凡是 API 请求url为 <code>/api/mgr/customers</code> 的，都交由 我们上面定义的dispatch函数进行分派处理</p>
<h3 id="列出客户"><a href="#列出客户" class="headerlink" title="列出客户"></a>列出客户</h3><p>通常数据资源的 增查改删 里面的 查 就是 查看，对应的就是列出数据资源。</p>
<p>根据接口文档，列出客户数据接口，后端返回的数据格式如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ret&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;retlist&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;江苏省常州武进市白云街44号&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;武进市 袁腾飞&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phonenumber&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13886666666&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京海淀区&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京海淀区代理 蔡国庆&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phonenumber&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13990123456&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span>              </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>看到没有，这里我们无需 将数据库中获取的数据 转化为 供浏览器展示的HTML。</p>
<p>在前后端分离的开发架构中，如何展示数据，那是前端的事情。</p>
<p>我们后端只需要根据接口文档， 返回原始数据就行。</p>
<p>我们可以使用如下的函数来返回数据库的所有的 客户数据信息</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listcustomers</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Customer.objects.values()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    <span class="comment"># 否则不能 被 转化为 JSON 字符串</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist&#125;)</span><br></pre></td></tr></table></figure>

<p>当然在文件的开头，我们需要 先导入 Customer 定义，像下面这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 Customer </span></span><br><span class="line"><span class="keyword">from</span> common.models <span class="keyword">import</span> Customer</span><br></pre></td></tr></table></figure>

<p>可以发现，无需转化数据为HTML， 后端的代码任务也大大减轻。</p>
<h3 id="添加客户"><a href="#添加客户" class="headerlink" title="添加客户"></a>添加客户</h3><p>通常数据资源的 增查改删 里面的 增 就是 添加，对应的就是添加数据资源。</p>
<p>根据接口文档，添加客户数据接口，前端提供的客户数据格式如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span><span class="string">&quot;add_customer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;武汉市桥西医院&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;phonenumber&quot;</span><span class="punctuation">:</span><span class="string">&quot;13345679934&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="string">&quot;武汉市桥西医院北路&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用如下的函数来处理</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">addcustomer</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    info    = request.params[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求消息中 获取要添加客户的信息</span></span><br><span class="line">    <span class="comment"># 并且插入到数据库中</span></span><br><span class="line">    <span class="comment"># 返回值 就是对应插入记录的对象 </span></span><br><span class="line">    record = Customer.objects.create(name=info[<span class="string">&#x27;name&#x27;</span>] ,</span><br><span class="line">                            phonenumber=info[<span class="string">&#x27;phonenumber&#x27;</span>] ,</span><br><span class="line">                            address=info[<span class="string">&#x27;address&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;id&#x27;</span>:record.<span class="built_in">id</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Customer.objects.create</code> 方法就可以添加一条Customer表里面的记录。</p>
<h3 id="临时取消CSRF校验"><a href="#临时取消CSRF校验" class="headerlink" title="临时取消CSRF校验"></a>临时取消CSRF校验</h3><p>根据接口文档，添加客户 请求是个Post请求</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">POST /网站名/api/mgr/signin  HTTP/<span class="number">1.1</span></span><br><span class="line">Content-<span class="type">Type</span>:   application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>注意，缺省创建的项目， Django 会启用一个 CSRF （跨站请求伪造） 安全防护机制。</p>
<p>在这种情况下， 所有的Post、PUT 类型的 请求都必须在HTTP请求头中携带用于校验的数据。</p>
<p>为了简单起见，我们先临时取消掉CSRF的 校验机制，等以后有需要再打开。</p>
<p>要临时取消掉CSRF的 校验机制，非常简单，只需要在 项目的配置文件 <code>bysms/settings.py</code> 中 <code>MIDDLEWARE</code> 配置项 里 注释掉 ‘django.middleware.csrf.CsrfViewMiddleware’ 即可。</p>
<p>如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="修改客户信息"><a href="#修改客户信息" class="headerlink" title="修改客户信息"></a>修改客户信息</h3><p>数据资源的 增查改删 里面的 <strong>改</strong> 就是 改动，对应的就是修改数据资源。</p>
<p>根据接口文档，修改客户数据接口，前端提供的数据格式如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span><span class="string">&quot;modify_customer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;newdata&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;武汉市桥北医院&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;phonenumber&quot;</span><span class="punctuation">:</span><span class="string">&quot;13345678888&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="string">&quot;武汉市桥北医院北路&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用如下的函数来处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modifycustomer</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求消息中 获取修改客户的信息</span></span><br><span class="line">    <span class="comment"># 找到该客户，并且进行修改操作</span></span><br><span class="line">    </span><br><span class="line">    customerid = request.params[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    newdata    = request.params[<span class="string">&#x27;newdata&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 根据 id 从数据库中找到相应的客户记录</span></span><br><span class="line">        customer = Customer.objects.get(<span class="built_in">id</span>=customerid)</span><br><span class="line">    <span class="keyword">except</span> Customer.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span>  &#123;</span><br><span class="line">                <span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;msg&#x27;</span>: <span class="string">f&#x27;id 为`<span class="subst">&#123;customerid&#125;</span>`的客户不存在&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        customer.name = newdata[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;phonenumber&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        customer.phonenumber = newdata[<span class="string">&#x27;phonenumber&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;address&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        customer.address = newdata[<span class="string">&#x27;address&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意，一定要执行save才能将修改信息保存到数据库</span></span><br><span class="line">    customer.save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="删除客户"><a href="#删除客户" class="headerlink" title="删除客户"></a>删除客户</h3><p>数据资源的 增查改删 里面的 <strong>删</strong> 就是 删除，对应的就是删除数据资源。</p>
<p>根据接口文档，删除客户数据接口，前端只需要提供要删除的客户的ID。</p>
<p>数据格式如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span><span class="string">&quot;del_customer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用如下的函数来处理</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deletecustomer</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    customerid = request.params[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 根据 id 从数据库中找到相应的客户记录</span></span><br><span class="line">        customer = Customer.objects.get(<span class="built_in">id</span>=customerid)</span><br><span class="line">    <span class="keyword">except</span> Customer.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span>  &#123;</span><br><span class="line">                <span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;msg&#x27;</span>: <span class="string">f&#x27;id 为`<span class="subst">&#123;customerid&#125;</span>`的客户不存在&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># delete 方法就将该记录从数据库中删除了</span></span><br><span class="line">    customer.delete()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="前端环境"><a href="#前端环境" class="headerlink" title="前端环境"></a>前端环境</h3><p>前端环境其实就是 一些前端的代码和资源文件，包括 js文件、html文件、css文件 还有 图片视频文件等。</p>
<p>我们模拟前端团队开发的 前端 系统 打包在这里 ，<a target="_blank" rel="noopener" href="https://cdn2.byhy.net/files/django/z_dist.zip">点击这里下载</a></p>
<p>下载好以后，可以解压该 z_dist.zip 文件到项目根目录下面，形成一个目录 z_dist。</p>
<p>该目录下面就是前端的 代码资源文件。</p>
<p>Django的开发环境也可以从浏览器访问这些前端的资源文件。</p>
<p>但是前端文件都是静态文件，需要我们配置一下Django的配置文件， 指定http请求如果访问静态文件，Django在哪个目录下查找。</p>
<p>注意，接下来我们配置 Django 静态文件服务， 是 <code>开发时</code> 使用的 一种 <code>临时方案</code> ，性能很低，这是方便我们调试程序用的。</p>
<p>前面讲过，正式部署web服务的时候，不应该这样干，应该采用其它方法，比如Nginx等。后面的教程会有详细的讲解如何使用Nginx 和 Django 组合使用。</p>
<p>现在，请打开 <code>bysms/urls.py</code> 文件，在末尾 添加一个</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+  static(<span class="string">&quot;/&quot;</span>, document_root=<span class="string">&quot;./z_dist&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>并添加如下声明</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 静态文件服务</span></span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br></pre></td></tr></table></figure>

<p>最终，内容如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入一个include函数</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态文件服务</span></span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 凡是 url 以 sales/  开头的，</span></span><br><span class="line">    <span class="comment"># 都根据 sales.urls 里面的 子路由表进行路由</span></span><br><span class="line">    path(<span class="string">&#x27;sales/&#x27;</span>, include(<span class="string">&#x27;sales.urls&#x27;</span>)),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 凡是 url 以 api/mgr  开头的，</span></span><br><span class="line">    <span class="comment"># 都根据 mgr.urls 里面的 子路由表进行路由</span></span><br><span class="line">    path(<span class="string">&#x27;api/mgr/&#x27;</span>, include(<span class="string">&#x27;mgr.urls&#x27;</span>)),</span><br><span class="line"></span><br><span class="line">]  +  static(<span class="string">&quot;/&quot;</span>, document_root=<span class="string">&quot;./z_dist&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>最后的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+  static(<span class="string">&quot;/&quot;</span>, document_root=<span class="string">&quot;./z_dist&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>就是在url 路由中加入 前端静态文件的查找路径。</p>
<p>这样如果 http请求的url 不是以 admin&#x2F; sales&#x2F; api&#x2F;mgr&#x2F; 开头， Django 就会认为是要访问 z_dist目录下面的静态文件。</p>
<h2 id="实现登录"><a href="#实现登录" class="headerlink" title="实现登录"></a>实现登录</h2><h3 id="处理登录，登出请求"><a href="#处理登录，登出请求" class="headerlink" title="处理登录，登出请求"></a>处理登录，登出请求</h3><p>我们可以在mgr目录里面创建一个代码文件 <code>sign_in_out.py</code></p>
<p>这个代码文件就是用来处理 <strong>管理员登录和登出</strong> 的API 请求的</p>
<p>大家可以思考一下， 我们的代码 该如何处理登录请求呢？</p>
<p>无非就把请求参数里面的用户名、密码取出来， 和数据库中记录的用户名密码进行比对。</p>
<p>如果和数据库中 记录的一致就认为是认证通过，否则就是不通过。</p>
<p>Django中有个内置app 名为 <code>django.contrib.auth</code> ，缺省包含在项目Installed App设置中。</p>
<p>这个app 的 models 定义中包含了一张 用户表，名为 <code>auth_user</code> 。</p>
<p><code>django.contrib.auth</code> 这个app 已经 <strong>为我们做好了登录验证功能</strong>。</p>
<p>我们只需要使用这个app库里面的方法就可以了。</p>
<p>Django的文档就给出了登录和登出代码范例，我们稍微修改一下。</p>
<p>我们在 mgr 目录下面， 创建一个 <code>sign_in_out.py</code> 文件。</p>
<p>在该文件中，输入如下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate, login, logout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signin</span>(<span class="params"> request</span>):</span><br><span class="line">    <span class="comment"># 从 HTTP POST 请求中获取用户名、密码参数</span></span><br><span class="line">    userName = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    passWord = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 Django auth 库里面的 方法校验用户名、密码</span></span><br><span class="line">    user = authenticate(username=userName, password=passWord)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果能找到用户，并且密码正确</span></span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> user.is_active:</span><br><span class="line">            <span class="keyword">if</span> user.is_superuser:</span><br><span class="line">                login(request, user)</span><br><span class="line">                <span class="comment"># 在session中存入用户类型</span></span><br><span class="line">                request.session[<span class="string">&#x27;usertype&#x27;</span>] = <span class="string">&#x27;mgr&#x27;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;请使用管理员账户登录&#x27;</span>&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;用户已经被禁用&#x27;</span>&#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 否则就是用户名、密码有误</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;用户名或者密码错误&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登出处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signout</span>(<span class="params"> request</span>):</span><br><span class="line">    <span class="comment"># 使用登出方法</span></span><br><span class="line">    logout(request)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h3><p>Bysms系统，浏览器登陆登录页面的url是 <a target="_blank" rel="noopener" href="http://127.0.0.1/mgr/sign.html">http://127.0.0.1/mgr/sign.html</a></p>
<p>但是这不是 登录 API接口的url路径。</p>
<p>根据接口，管理员登录的API 路径是 <code>/api/mgr/signin</code></p>
<p>前面的课程， 我们已经在总路由文件 <code>bysms/urls.py</code> 中 添加了如下路由记录</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 凡是 url 以 api/mgr  开头的，</span></span><br><span class="line"><span class="comment"># 都根据 mgr.urls 里面的 子路由表进行路由</span></span><br><span class="line">path(<span class="string">&#x27;api/mgr/&#x27;</span>, include(<span class="string">&#x27;mgr.urls&#x27;</span>)),</span><br></pre></td></tr></table></figure>

<p>现在，我们只需要 在mgr 目录下面 的子路由文件 <code>urls.py</code> 里添加如下内容</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> mgr <span class="keyword">import</span> sign_in_out</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;signin&#x27;</span>, sign_in_out.signin),</span><br><span class="line">    path(<span class="string">&#x27;signout&#x27;</span>, sign_in_out.signout),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样就表示：</p>
<p>如果有HTTP请求 url是 <code>/api/mgr/signin</code> 就由 sign_in_out.py 里面的signin 函数处理，</p>
<p>如果有HTTP请求 url是 <code>/api/mgr/signout</code> 就由 sign_in_out.py 里面的signout 函数处理。</p>
<h2 id="Session和token"><a href="#Session和token" class="headerlink" title="Session和token"></a>Session和token</h2><p>前端发来的 Customer API 请求， 我们后端代码就直接处理了， <code>并没有验证</code> 这个请求是不是已经登录的管理员发出的。</p>
<p>如果是这样，客户端可以不需要登录，直接访问 登录后的主页， 我们编写的登录处理代码又 有什么用呢？</p>
<p>这就 需要我们在 处理 Customer API 请求前， 判断发出该请求的用户是否登录了。</p>
<p>对于请求消息的合法性验证， 通常有两种方案： <code>session</code> 和 <code>token</code></p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><strong>session</strong> 就是 <strong>会话</strong> 的意思。</p>
<p>session 方案 的原理如下：</p>
<ul>
<li><p>服务端在数据库中保存一张session表。 这张表记录了一次用户登录的相关信息。</p>
<p>具体记录什么信息， 不同的系统各有差异， 通常 会记录 该用户的 ID 、姓名 、登录名 之类的。</p>
</li>
<li><p>大家可以发现sessionid 通常就是 一串字符串 用来标记一个session的。 而session对应的数据在这里是加密的。</p>
<p>通过这张表，服务端 可以根据 session号（通常叫session ID） 查到 session 的信息数据。</p>
</li>
<li><p>在用户登录成功后， 服务端就在数据库session表中 中创建一条记录，记录这次会话。</p>
<p>也就是创建一个新的 sessionid 插入到 该表中。</p>
<p>同时也 放入一些 该session对应的数据到 记录的数据字段中，比如登录用户 的 信息。</p>
<p>然后在该登录请求的HTTP响应消息中， 的头字段 Set-Cookie 里填入 sessionid 数据。</p>
<p>类似这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: sessionid=6qu1cuk8cxvtf4w9rjxeppexh2izy0hh</span><br></pre></td></tr></table></figure>

<p>根据http协议， 这个Set-Cookie字段的意思就是 要求前端将其中的数据存入 cookie中。 并且随后访问该服务端的时候， 在HTTP请求消息中必须带上 这些 cookie数据。</p>
<p>cookie 通常就是存储在客户端浏览器的一些数据。 服务端可以通过http响应消息 要求 浏览器存储 一些数据。</p>
<p>以后每次访问 同一个网站服务， 必须在HTTP请求中再带上 这些cookie里面的数据。</p>
<p>cookie数据由多个 键值对组成， 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sessionid=6qu1cuk8cxvtf4w9rjxeppexh2izy0hh</span><br><span class="line">username=byhy</span><br><span class="line">favorite=phone_laptop_watch</span><br></pre></td></tr></table></figure>
</li>
<li><p>该用户的后续操作，触发的HTTP请求， 都会在请求头的<strong>Cookie</strong>字段带上前面说的sessionid 。</p>
<p>如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: sessionid=6qu1cuk8cxvtf4w9rjxeppexh2izy0hh</span><br></pre></td></tr></table></figure>

<p>服务端接受到该请求后，只需要到session表中查看是否有该 sessionid 对应的记录，这样就可以判断这个请求是否是前面已经登录的用户发出的。</p>
<p>如果不是，就可以拒绝服务，重定向http请求到登录页面让用户登录。</p>
</li>
</ul>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220318230206824.png" alt="image-20220318230206824"></p>
<p>这行代码的作用 就是在登录认证后，将 用户类型保存到session数据中， 也就是存入前面数据库的那张图的 会话数据记录中。</p>
<p>Django 框架 会自动在 HTTP 响应消息头中 加入 类似下面的 sessionid cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: sessionid=????????</span><br></pre></td></tr></table></figure>

<p>后续的HTTP请求就会携带这个sessionid，</p>
<p>我们处理 URL 以 <code>/api/mgr</code> 开头的 API 请求 代码里面， 需要 加上一个验证逻辑。</p>
<p>验证请求的cookie里面是否有sessionid，并且检查session表，看看是否存在session_key为该sessionid 的一条记录，该记录的数据字典里面是否 包含了 usertype 为 mgr 的 数据。</p>
<p>前面实现的代码中， 这些请求都是在dispatcher入口函数处理的，我们就只需在该dispatch中进行验证。</p>
<p>修改 <code>mgr/customer.py</code> 的dispatcher 函数，在前面加上如下代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据session判断用户是否是登录的管理员用户</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;usertype&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.session:</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">        <span class="string">&#x27;ret&#x27;</span>: <span class="number">302</span>,</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;未登录&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;/mgr/sign.html&#x27;</span>&#125;, </span><br><span class="line">        status=<span class="number">302</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> request.session[<span class="string">&#x27;usertype&#x27;</span>] != <span class="string">&#x27;mgr&#x27;</span> :</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">        <span class="string">&#x27;ret&#x27;</span>: <span class="number">302</span>,</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;用户非mgr类型&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;/mgr/sign.html&#x27;</span>&#125; ,</span><br><span class="line">        status=<span class="number">302</span>)</span><br></pre></td></tr></table></figure>

<p>注意request对象里面的session属性对应的就是 session记录里面的 数据。</p>
<p>该数据对象类似字典，所以检查是否有usertype类型为mgr的信息，就是这样写</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.session[<span class="string">&#x27;usertype&#x27;</span>] != <span class="string">&#x27;mgr&#x27;</span> </span><br></pre></td></tr></table></figure>

<h3 id="token机制"><a href="#token机制" class="headerlink" title="token机制"></a>token机制</h3><p>使用session机制验证用户请求的合法性 的主要缺点有两个</p>
<ul>
<li><p>性能问题</p>
<p>因为，验证请求是根据sessionid 到数据库中查找session表的，而数据库操作是服务端常见的性能瓶颈，尤其是当用户量比较大的时候。</p>
</li>
<li><p>扩展性问题</p>
<p>当系统用户特别多的时候，后端处理请求的服务端通常由多个，部署在多个节点上。 但是多个节点都要访问session表，这样就要求数据库服务能够被多个节点访问，不方便切分数据库以提高性能。</p>
</li>
</ul>
<p>最近比较流行的一种token机制可以比较好的解决这些问题。</p>
<p>token 简单来说，就是包含了 数据信息 和 校验信息的 数据包。</p>
<p>Session 机制是把 数据信息（比如session表）放到 服务端，<strong>服务端数据是客户无法篡改的</strong>，从而保证验证的 可靠性。</p>
<p>而 token机制 数据信息 直接传给 客户端，客户每次请求再携带过来给服务端。服务端无需查找数据库，直接根据token里面的数据信息进行校验。</p>
<p>那么问题来了：客户数据直接发送给客户端，如果 客户端篡改了数据， 比如把自己改为 vip用户怎么办？ 服务端怎么验证数据有没有被客户端篡改（术语叫完整性验证）呢？</p>
<p>token 机制的原理如下：</p>
<ul>
<li><p>服务端配置一个<strong>密钥</strong>（secret key），该密钥是服务端私密保存的，不能外泄</p>
</li>
<li><p>在用户登录成功后， 服务端将 <code>用户的信息数据 + 密钥</code> 一起进行一个哈希计算， 得到一个哈希值。</p>
<p>注意：哈希算法保证了， 哈希值只能根据 同样的 源数据得到。</p>
<p>如果谁修改了用户信息， <strong>除非他知道密钥</strong>，再次使用哈希算法才能得到 正确的新的 哈希值。</p>
<p>所以这个哈希值，就是用来校验数据是否被修改的.</p>
<p>然后将 用户数据信息 和 哈希值 一起 做成一个字节串 ，这个字节串就称之为 <strong>token</strong> 。</p>
<p>大家可以发现 token 里面 <strong>包含了用户数据信息 和 用于校验完整性的哈希值</strong>。</p>
<p>然后，服务端返回给客户的HTTP响应中 返回了这个token。 通常token是放在HTTP响应的头部中的。 具体哪个头部字段没有规定，开发者可以自行定义。</p>
</li>
<li><p>该用户的后续操作，触发的HTTP API请求， 会在请求消息里面 带上 token 。</p>
<p>具体在请求消息的什么地方 存放 token， 由开发者自己定义，通常也存放在http 请求 的头部中。</p>
<p>服务端接收到请求后，会根据 数据信息 和 密钥 使用哈希算法再次 生成 哈希值。</p>
<p>如果客户修改了数据信息， 因为他不知道密钥，没法得到正确的新的哈希值，那么 服务端根据 <strong>篡改后的数据+密钥</strong> 得到的新 哈希值一定和 保存在token中的老哈希值 不同。就知道数据被修改了。</p>
<p>如果客户没有修改数据，服务端 根据 原来的数据+密钥 得到的哈希值 和保存在token中原来的哈希值一致，就校验通过。</p>
<p>校验通过后，就确信了数据没有被修改，可以放心的使用token里面的数据 进行后续的业务逻辑处理了。</p>
<p>上述处理中，由于不需要服务端访问查找数据库，从而大大了提高了处理性能。</p>
</li>
</ul>
<h2 id="数据库表之间的关联"><a href="#数据库表之间的关联" class="headerlink" title="数据库表之间的关联"></a>数据库表之间的关联</h2><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>表之间 <code>一对多</code> 的关系，就是 <code>外键</code> 关联关系</p>
<p>现在我们还需要定义 <code>药品（Medicine）</code> 这张表，包括药品名称、编号和描述 这些信息。</p>
<p>这个也很简单，添加如下的类定义</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Medicine</span>(models.Model):</span><br><span class="line">    <span class="comment"># 药品名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 药品编号</span></span><br><span class="line">    sn = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 描述</span></span><br><span class="line">    desc = models.CharField(max_length=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>



<p>接下来我们要定义 <code>订单（Order）</code> 这张表，这个Order表 包括 创建日期、客户、药品、数量。</p>
<p>其中：</p>
<p>客户字段对应的客户 <code>只能是 Customer</code> 中的某个客户记录</p>
<p>可以说：</p>
<p>Order表里面 一条订单记录的客户 对应 Customer表里面的一条客户记录</p>
<p>而 <strong>多条</strong> Order记录里面的客户 是可以对应 Customer 表里面 同一个客户记录的，</p>
<p>反过来说，就是：一个客户记录可以对应多条订单记录</p>
<p>这就是一对多的关系，可以用如下图片表示</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220319185701794.png" alt="image-20220319185701794"></p>
<p>像这种一对多的关系，数据库中是用 <strong>外键</strong> 来表示的。</p>
<p>如果一个表中 的 某个字段是外键，那就意味着 这个外键字段的记录的取值，只能是它关联表的某个记录的主键的值。</p>
<p>我们定义表的 Model类的时候，如果没有指定主键字段，migrate 的时候 Django 会为该Model对应的数据库表自动生成一个id字段，作为主键。</p>
<p>现在我们要定义 订单 表 Order，</p>
<p>其中客户字段就应该是一个外键，对应Customer表的主键，也就是id字段</p>
<p>Django中定义外键 的方法就是 Model类的该属性字段 值为 <code>ForeignKey</code> 对象，如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(models.Model):</span><br><span class="line">    <span class="comment"># 订单名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>,null=<span class="literal">True</span>,blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建日期</span></span><br><span class="line">    create_date = models.DateTimeField(default=datetime.datetime.now)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 客户</span></span><br><span class="line">    customer = models.ForeignKey(Customer,on_delete=models.PROTECT)</span><br></pre></td></tr></table></figure>

<p>大家可以发现， customer 字段 是外键， 指向 Customer 类。 意思就是告诉Django： Order表的 customer 字段 指向 Customer表的主键 的一个外键。</p>
<p>另外一个参数 <strong>on_delete</strong> 指定了 当我们想 <code>删除</code> 外键指向的主键 记录时， 系统的行为。</p>
<p>比如 我们要删除客户记录， 那么 Order表中 对应这个客户的订单记录 该如何处理呢？</p>
<p>on_delete 不同取值对应不同的做法，常见的做法如下</p>
<ul>
<li><p>CASCADE</p>
<p>删除主键记录和 相应的外键表记录。</p>
<p>比如，我们要删除客户张三，在删除了客户表中张三记录同时，也删除Order表中所有这个张三的订单记录</p>
</li>
<li><p>PROTECT</p>
<p>禁止删除记录。</p>
<p>比如，我们要删除客户张三，如果Order表中有张三的订单记录，Django系统 就会抛出ProtectedError类型的异常，当然也就禁止删除 客户记录和相关的订单记录了。</p>
<p>除非我们将Order表中所有张三的订单记录都先删除掉，才能删除该客户表中的张三记录。</p>
</li>
<li><p>SET_NULL</p>
<p>删除主键记录，并且将外键记录中外键字段的值置为null。 当然前提是外键字段要设置为值允许是null。</p>
<p>比如，我们要删除客户张三时，在删除了客户张三记录同时，会将Order表里面所有的 张三记录里面的customer字段值置为 null。 但是上面我们并没有设置 customer 字段有 <code>null=True</code> 的参数设置，所以，是不能取值为 SET_NULL的。</p>
</li>
</ul>
<p>注意： 外键字段，实际在数据库表中的 字段名， 是 Django ForeignKey 定义 字段名加上后缀 <code>_id</code> 。</p>
<p>比如这里，在执行了 migrate 命令更新数据库后， customer 这个外键字段实际上在 数据库表中的字段名 是 <code>customer_id</code></p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>有的时候，表之间是 <code>一对一</code> 的关系。</p>
<p>比如，某个学校的学生 表 和学生的地址表，就形成一对一的关系，即 一条主键所在表的记录 只能对应一条 外键所在表的记录。</p>
<p>Django 中 用 <code>OneToOneField</code> 对象 实现 一对一 的关系，如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    <span class="comment"># 姓名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 班级</span></span><br><span class="line">    classname = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 描述</span></span><br><span class="line">    desc = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContactAddress</span>(models.Model):</span><br><span class="line">    <span class="comment"># 一对一 对应学生 </span></span><br><span class="line">    student = models.OneToOneField(Student, on_delete=models.PROTECT)</span><br><span class="line">    <span class="comment"># 家庭</span></span><br><span class="line">    homeaddress = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 电话号码</span></span><br><span class="line">    phone = models.CharField(max_length=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>Django发现这样一对一定定义，它会在migrate的时候，在数据库中定义该字段为外键的同时， 加上 <code>unique=True</code> 约束，表示在此表中，所有记录的该字段 取值必须唯一，不能重复。</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>数据库表还有一种 <strong>多对多</strong> 的关系。</p>
<p>在我们的 BYSMS系统中， 一个订单可以采购多种药品，就对应 Medicine表里面的多种药品；而一种药品也可以被多个订单采购， 那么Order表 和 Medicine表 之间就形成了多对多的关系。</p>
<p>其对应关系可以用下图来表示<img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220319191138331.png" alt="image-20220319191138331"></p>
<p>Django是通过 <code>ManyToManyField</code> 对象 表示 多对多的关系的。</p>
<p>如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(models.Model):</span><br><span class="line">    <span class="comment"># 订单名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>,null=<span class="literal">True</span>,blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建日期</span></span><br><span class="line">    create_date = models.DateTimeField(default=datetime.datetime.now)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 客户</span></span><br><span class="line">    customer = models.ForeignKey(Customer,on_delete=models.PROTECT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订单购买的药品，和Medicine表是多对多 的关系</span></span><br><span class="line">    medicines = models.ManyToManyField(Medicine, through=<span class="string">&#x27;OrderMedicine&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderMedicine</span>(models.Model):</span><br><span class="line">    order = models.ForeignKey(Order, on_delete=models.PROTECT)</span><br><span class="line">    medicine = models.ForeignKey(Medicine, on_delete=models.PROTECT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订单中药品的数量</span></span><br><span class="line">    amount = models.PositiveIntegerField()</span><br></pre></td></tr></table></figure>

<h3 id="药品管理"><a href="#药品管理" class="headerlink" title="药品管理"></a>药品管理</h3><p>其中药品管理部分比较简单， 和前面的 customer.py 的代码 基本类似。</p>
<p>我们在 mgr 目录下面新建 medicine.py，处理 客户端发过来的 列出药品、添加药品、修改药品、删除药品 的请求。</p>
<p>如下所示</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 Medicine 对象定义</span></span><br><span class="line"><span class="keyword">from</span>  common.models <span class="keyword">import</span>  Medicine</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dispatcher</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 根据session判断用户是否是登录的管理员用户</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;usertype&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.session:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">            <span class="string">&#x27;ret&#x27;</span>: <span class="number">302</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;未登录&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;/mgr/sign.html&#x27;</span>&#125;,</span><br><span class="line">            status=<span class="number">302</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.session[<span class="string">&#x27;usertype&#x27;</span>] != <span class="string">&#x27;mgr&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">            <span class="string">&#x27;ret&#x27;</span>: <span class="number">302</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;用户非mgr类型&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;/mgr/sign.html&#x27;</span>&#125;,</span><br><span class="line">            status=<span class="number">302</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将请求参数统一放入request 的 params 属性中，方便后续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET请求 参数 在 request 对象的 GET属性中</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        request.params = request.GET</span><br><span class="line"></span><br><span class="line">    <span class="comment"># POST/PUT/DELETE 请求 参数 从 request 对象的 body 属性中获取</span></span><br><span class="line">    <span class="keyword">elif</span> request.method <span class="keyword">in</span> [<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;PUT&#x27;</span>,<span class="string">&#x27;DELETE&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 根据接口，POST/PUT/DELETE 请求的消息体都是 json格式</span></span><br><span class="line">        request.params = json.loads(request.body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据不同的action分派给不同的函数进行处理</span></span><br><span class="line">    action = request.params[<span class="string">&#x27;action&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">&#x27;list_medicine&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> listmedicine(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;add_medicine&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> addmedicine(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;modify_medicine&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> modifymedicine(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;del_medicine&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> deletemedicine(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;不支持该类型http请求&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listmedicine</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Medicine.objects.values()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    <span class="comment"># 否则不能 被 转化为 JSON 字符串</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addmedicine</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    info    = request.params[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求消息中 获取要添加客户的信息</span></span><br><span class="line">    <span class="comment"># 并且插入到数据库中</span></span><br><span class="line">    medicine = Medicine.objects.create(name=info[<span class="string">&#x27;name&#x27;</span>] ,</span><br><span class="line">                            sn=info[<span class="string">&#x27;sn&#x27;</span>] ,</span><br><span class="line">                            desc=info[<span class="string">&#x27;desc&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;id&#x27;</span>:medicine.<span class="built_in">id</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modifymedicine</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求消息中 获取修改客户的信息</span></span><br><span class="line">    <span class="comment"># 找到该客户，并且进行修改操作</span></span><br><span class="line"></span><br><span class="line">    medicineid = request.params[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    newdata    = request.params[<span class="string">&#x27;newdata&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 根据 id 从数据库中找到相应的客户记录</span></span><br><span class="line">        medicine = Medicine.objects.get(<span class="built_in">id</span>=medicineid)</span><br><span class="line">    <span class="keyword">except</span> Medicine.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span>  &#123;</span><br><span class="line">                <span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;msg&#x27;</span>: <span class="string">f&#x27;id 为`<span class="subst">&#123;medicineid&#125;</span>`的药品不存在&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        medicine.name = newdata[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;sn&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        medicine.sn = newdata[<span class="string">&#x27;sn&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;desc&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        medicine.desc = newdata[<span class="string">&#x27;desc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意，一定要执行save才能将修改信息保存到数据库</span></span><br><span class="line">    medicine.save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletemedicine</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    medicineid = request.params[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 根据 id 从数据库中找到相应的药品记录</span></span><br><span class="line">        medicine = Medicine.objects.get(<span class="built_in">id</span>=medicineid)</span><br><span class="line">    <span class="keyword">except</span> Medicine.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span>  &#123;</span><br><span class="line">                <span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;msg&#x27;</span>: <span class="string">f&#x27;id 为`<span class="subst">&#123;medicineid&#125;</span>`的客户不存在&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># delete 方法就将该记录从数据库中删除了</span></span><br><span class="line">    medicine.delete()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>实现了请求处理的模块后，我们可以在 mgr\urls.py 里面加上 对 medicine 的 请求处理 路由设置</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> mgr <span class="keyword">import</span> customer,sign_in_out,medicine,order</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;customers&#x27;</span>, customer.dispatcher),</span><br><span class="line">    path(<span class="string">&#x27;medicines&#x27;</span>, medicine.dispatcher), <span class="comment"># 加上这行</span></span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;signin&#x27;</span>, sign_in_out.signin),</span><br><span class="line">    path(<span class="string">&#x27;signout&#x27;</span>, sign_in_out.signout),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我的前端代码已经开发好了对药品的 增删改查处理， 所以可以和我们上面的代码进行集成测试了。</p>
<h2 id="ORM关联表"><a href="#ORM关联表" class="headerlink" title="ORM关联表"></a>ORM关联表</h2><p>前面我们学过 一对多，一对一，多对多，都是通过外键来实现。</p>
<p>接下来，我们通过一个实例演示，Django ORM 如何 操作 外键关联关系</p>
<p>请大家在 <code>models.py</code> 中定义这样的两个Model，对应两张表</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 国家表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生表， country 字段是国家表的外键，形成一对多的关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    name    = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    grade   = models.PositiveSmallIntegerField()</span><br><span class="line">    country = models.ForeignKey(Country,</span><br><span class="line">                                on_delete=models.PROTECT)</span><br></pre></td></tr></table></figure>

<p>然后，执行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations common</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>使定义生效到数据库中。</p>
<p>然后，命令行中执行 <code>python manage.py shell</code> ，直接启动Django命令行，输入代码。</p>
<p>先输入如下代码，创建一些数据</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> common.models <span class="keyword">import</span> *</span><br><span class="line">c1 = Country.objects.create(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">c2 = Country.objects.create(name=<span class="string">&#x27;美国&#x27;</span>)</span><br><span class="line">c3 = Country.objects.create(name=<span class="string">&#x27;法国&#x27;</span>)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;白月&#x27;</span>, grade=<span class="number">1</span>, country=c1)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;黑羽&#x27;</span>, grade=<span class="number">2</span>, country=c1)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;大罗&#x27;</span>, grade=<span class="number">1</span>, country=c1)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;真佛&#x27;</span>, grade=<span class="number">2</span>, country=c1)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;Mike&#x27;</span>, grade=<span class="number">1</span>, country=c2)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;Gus&#x27;</span>,  grade=<span class="number">1</span>, country=c2)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;White&#x27;</span>, grade=<span class="number">2</span>, country=c2)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;Napolen&#x27;</span>, grade=<span class="number">2</span>, country=c3)</span><br></pre></td></tr></table></figure>



<h3 id="外键表字段访问"><a href="#外键表字段访问" class="headerlink" title="外键表字段访问"></a>外键表字段访问</h3><p>如果你已经获取了一个student对象，要得到他的国家名称只需这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s1 = Student.objects.get(name=<span class="string">&#x27;白月&#x27;</span>)</span><br><span class="line">s1.country.name</span><br></pre></td></tr></table></figure>



<h3 id="外键表字段过滤"><a href="#外键表字段过滤" class="headerlink" title="外键表字段过滤"></a>外键表字段过滤</h3><p>如果，我们要查找Student表中所有 <code>一年级</code> 学生，很简单</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>).values()</span><br></pre></td></tr></table></figure>



<p>如果现在，我们要查找Student表中所有 <code>一年级中国</code> 学生，该怎么写呢？</p>
<p>不能这么写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country=<span class="string">&#x27;中国&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>因为，Student表中 <code>country</code> 并不是国家名称字符串字段，而是一个外键字段，其实是对应 Country 表中 <code>id</code> 字段 。</p>
<p>可能有的朋友会这样想：我可以先获取中国的国家id，然后再通过id去找，像这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country_id=cn.<span class="built_in">id</span>).values()</span><br></pre></td></tr></table></figure>

<p>注意外键字段的id是通过后缀 <code>_id</code> 获取的。</p>
<p>或者这样，也是可以的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country=cn).values()</span><br></pre></td></tr></table></figure>



<p>上面的方法，写起来麻烦一些，有两步操作。而且需要发送两次数据请求给数据库服务，性能不高。</p>
<p>其实，Django ORM 中，对外键关联，有更方便的语法。</p>
<p>可以这样写</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country__name=<span class="string">&#x27;中国&#x27;</span>).values()</span><br></pre></td></tr></table></figure>

<p>写起来简单，一步到位，而且只需要发送一个数据库请求，性能更好。</p>
<p>如果返回结果只需要 学生姓名 和 国家名两个字段，可以这样指定values内容</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country__name=<span class="string">&#x27;中国&#x27;</span>)\</span><br><span class="line">     .values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;country__name&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>但是这样写有个问题：选择出来的记录中，国家名是 <code>country__name</code> 。 两个下划线比较怪。</p>
<p>有时候，前后端接口的设计者，定义好了接口格式，如果要求一定是 <code>countryname</code> 这样怎么办？</p>
<p>可以使用 <code>annotate</code> 方法将获取的字段值进行重命名，像下面这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># annotate 可以将表字段进行别名处理</span></span><br><span class="line">Student.objects.annotate(</span><br><span class="line">    countryname=F(<span class="string">&#x27;country__name&#x27;</span>),</span><br><span class="line">    studentname=F(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    )\</span><br><span class="line">    .<span class="built_in">filter</span>(grade=<span class="number">1</span>,countryname=<span class="string">&#x27;中国&#x27;</span>).values(<span class="string">&#x27;studentname&#x27;</span>,<span class="string">&#x27;countryname&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="外键表的反向访问"><a href="#外键表的反向访问" class="headerlink" title="外键表的反向访问"></a>外键表的反向访问</h3><p>前面学过， Django ORM中，关联表 正向关系是通过表外键字段（或者多对多）表示， 比如前面例子中Student表的 country字段。</p>
<p>而反向关系，是通过 <code>表Model名转化为小写</code> 表示的。</p>
<p>比如，你已经获取了一个Country对象，如何获取到所有属于这个国家的学生呢？</p>
<p>可以这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">cn.student_set.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure>

<p>通过 <code>表Model名转化为小写</code> ，后面加上一个 <code>_set</code> 来获取所有的反向外键关联对象</p>
<p>Django还给出了一个方法，可以更直观的反映 关联关系。</p>
<p>在定义Model的时候，外键字段使用 <code>related_name</code> 参数，像这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 国家表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># country 字段是国家表的外键，形成一对多的关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    name    = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    grade   = models.PositiveSmallIntegerField()</span><br><span class="line">    country = models.ForeignKey(Country,</span><br><span class="line">                on_delete = models.PROTECT,</span><br><span class="line">                <span class="comment"># 指定反向访问的名字</span></span><br><span class="line">                related_name=<span class="string">&#x27;students&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>就可以使用更直观的属性名，像这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">cn.students.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure>



<h3 id="外键表的反向过滤"><a href="#外键表的反向过滤" class="headerlink" title="外键表的反向过滤"></a>外键表的反向过滤</h3><p>如果我们要获取所有 具有一年级学生 的国家名，该怎么写？</p>
<p>当然可以这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先获取所有的一年级学生id列表</span></span><br><span class="line">country_ids = Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>).values_list(<span class="string">&#x27;country&#x27;</span>, flat=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再通过id列表使用  id__in  过滤</span></span><br><span class="line">Country.objects.<span class="built_in">filter</span>(id__in=country_ids).values()</span><br></pre></td></tr></table></figure>

<p>但是这样同样存在 麻烦 和性能的问题。</p>
<p>Django ORM 可以这样写</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Country.objects.<span class="built_in">filter</span>(students__grade=<span class="number">1</span>).values()</span><br></pre></td></tr></table></figure>

<p>注意， 因为，我们定义表的时候，用 <code>related_name=&#39;students&#39;</code> 指定了反向关联名称 <code>students</code> ，所以这里是 <code>students__grade</code> 。 使用了反向关联名字。</p>
<p>如果定义时，没有指定related_name， 则应该使用 <code>表名转化为小写</code> ，就是这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Country.objects.<span class="built_in">filter</span>(student__grade=<span class="number">1</span>).values()</span><br></pre></td></tr></table></figure>



<p>但是，我们发现，这种方式，会有重复的记录产生，如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;QuerySet [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;中国&#x27;</span>&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;中国&#x27;</span>&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;美国&#x27;</span>&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;美国&#x27;</span>&#125;]&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>.distinct()</code> 去重</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Country.objects.<span class="built_in">filter</span>(students__grade=<span class="number">1</span>).values().distinct()</span><br></pre></td></tr></table></figure>

<p>注意：据说 <code>.distinct()</code>对MySQL数据库无效，我没有来得及验证。实测 SQLite，Postgresql有效。</p>
<h3 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h3><h4 id="路由更新"><a href="#路由更新" class="headerlink" title="路由更新"></a>路由更新</h4><p>现在，我们在 mgr 目录下面新建 order.py 处理 客户端发过来的 列出订单、添加订单 的请求。</p>
<p>同样，先写 dispatcher 函数，代码如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> IntegrityError, transaction</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 Order 对象定义</span></span><br><span class="line"><span class="keyword">from</span>  common.models <span class="keyword">import</span>  Order,OrderMedicine</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dispatcher</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 根据session判断用户是否是登录的管理员用户</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;usertype&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.session:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">            <span class="string">&#x27;ret&#x27;</span>: <span class="number">302</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;未登录&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;/mgr/sign.html&#x27;</span>&#125;,</span><br><span class="line">            status=<span class="number">302</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.session[<span class="string">&#x27;usertype&#x27;</span>] != <span class="string">&#x27;mgr&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line">            <span class="string">&#x27;ret&#x27;</span>: <span class="number">302</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;用户非mgr类型&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;redirect&#x27;</span>: <span class="string">&#x27;/mgr/sign.html&#x27;</span>&#125;,</span><br><span class="line">            status=<span class="number">302</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将请求参数统一放入request 的 params 属性中，方便后续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET请求 参数 在 request 对象的 GET属性中</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        request.params = request.GET</span><br><span class="line"></span><br><span class="line">    <span class="comment"># POST/PUT/DELETE 请求 参数 从 request 对象的 body 属性中获取</span></span><br><span class="line">    <span class="keyword">elif</span> request.method <span class="keyword">in</span> [<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;PUT&#x27;</span>,<span class="string">&#x27;DELETE&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 根据接口，POST/PUT/DELETE 请求的消息体都是 json格式</span></span><br><span class="line">        request.params = json.loads(request.body)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据不同的action分派给不同的函数进行处理</span></span><br><span class="line">    action = request.params[<span class="string">&#x27;action&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">&#x27;list_order&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> listorder(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;add_order&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> addorder(request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订单 暂 不支持修改 和删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;不支持该类型http请求&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>和以前差不多，没有什么好说的。</p>
<p>然后，我们在 mgr\urls.py 里面加上 对 orders 请求处理的路由</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> mgr <span class="keyword">import</span> customer,sign_in_out,medicine,order</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;customers&#x27;</span>, customer.dispatcher),</span><br><span class="line">    path(<span class="string">&#x27;medicines&#x27;</span>, medicine.dispatcher),</span><br><span class="line">    path(<span class="string">&#x27;orders&#x27;</span>, order.dispatcher), <span class="comment"># 加上这行</span></span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;signin&#x27;</span>, sign_in_out.signin),</span><br><span class="line">    path(<span class="string">&#x27;signout&#x27;</span>, sign_in_out.signout),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h4 id="事务、多对多记录添加"><a href="#事务、多对多记录添加" class="headerlink" title="事务、多对多记录添加"></a>事务、多对多记录添加</h4><p>接下来，我们添加函数 addorder，来处理 <strong>添加订单</strong> 请求。</p>
<p>我们添加一条订单记录，需要在2张表（Order 和 OrderMedicine ）中添加记录。</p>
<p>这里就有个需要特别注意的地方， 两张表的插入，意味着我们要有两次数据库操作。</p>
<p>如果第一次插入成功， 而第二次插入失败， 就会出现 Order表中 把订单信息写了一部分，而OrderMedicine表中 该订单的信息 却没有写成功。</p>
<p>这是个大问题： 就会造成 这个处理 做了一半。</p>
<p>那么数据库中就会出现数据的不一致。术语叫 <code>脏数据</code></p>
<p>熟悉数据库的同学就会知道， 我们应该用 数据库 的 <code>事务</code> 机制来解决这个问题。</p>
<p>把一批数据库操作放在 <code>事务</code> 中， 该事务中的任何一次数据库操作 失败了， 数据库系统就会让 整个事务就会发生回滚，撤销前面的操作， 数据库回滚到这事务操作之前的状态。</p>
<p>Django 怎么实现 事务操作呢？</p>
<p>这里我们可以使用 Django 的 <code>with transaction.atomic()</code></p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">addorder</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    info  = request.params[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求消息中 获取要添加订单的信息</span></span><br><span class="line">    <span class="comment"># 并且插入到数据库中</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        new_order = Order.objects.create(name=info[<span class="string">&#x27;name&#x27;</span>] ,</span><br><span class="line">                                         customer_id=info[<span class="string">&#x27;customerid&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        batch = [OrderMedicine(order_id=new_order.<span class="built_in">id</span>,medicine_id=mid,amount=<span class="number">1</span>)  </span><br><span class="line">                    <span class="keyword">for</span> mid <span class="keyword">in</span> info[<span class="string">&#x27;medicineids&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  在多对多关系表中 添加了 多条关联记录</span></span><br><span class="line">        OrderMedicine.objects.bulk_create(batch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>,<span class="string">&#x27;id&#x27;</span>:new_order.<span class="built_in">id</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><code>with transaction.atomic()</code> 下面 缩进部分的代码，对数据库的操作，就都是在 <code>一个事务</code> 中进行了。</p>
<p>如果其中有任何一步数据操作失败了， 前面的操作都会回滚。</p>
<p>这就可以防止出现 前面的 Order表记录插入成功， 而后面的 订单药品 记录插入失败而导致的数据不一致现象。</p>
<p>OrderMedicine 对应的是订单和药品的多对对记录关系表。</p>
<p>要在多对多表中加上关联记录，就是添加一条记录， 可以这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">OrderMedicine.objects.create(order_id=new_order.<span class="built_in">id</span>,medicine_id=mid,amount=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>我们这个例子中，一个订单可能会关联多个药品，也就是需要 插入 OrderMedicine 表中的数据 可能有很多条， 如果我们循环用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">OrderMedicine.objects.create(order_id=new_order.<span class="built_in">id</span>,medicine_id=mid,amount=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>插入的话， 循环几次， 就会执行 几次SQL语句 插入的 数据库操作 这样性能不高。</p>
<p>我们可以把多条数据的插入，放在一个SQL语句中完成， 这样会大大提高性能。</p>
<p>方法就是使用 bulk_create， 参数是一个包含所有 该表的 Model 对象的 列表</p>
<p>就像上面代码这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">batch = [OrderMedicine(order_id=new_order.<span class="built_in">id</span>,medicine_id=mid,amount=<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">for</span> mid <span class="keyword">in</span> info[<span class="string">&#x27;medicineids&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#  在多对多关系表中 添加了 多条关联记录</span></span><br><span class="line">OrderMedicine.objects.bulk_create(batch)</span><br></pre></td></tr></table></figure>



<p>写好后， 大家可以运行服务 ， 用我们做好的前端系统添加几条 订单记录， 然后再查看一下数据库里面的数据是否正确。</p>
<p>接下来，我们来编写listorder 函数用来处理 列出订单请求。</p>
<p>根据接口文档，我们应该返回 订单记录格式，如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">id</span>: <span class="number">1</span>, </span><br><span class="line">        name: <span class="string">&quot;华山医院订单001&quot;</span>, </span><br><span class="line">        create_date: <span class="string">&quot;2018-12-26T14:10:15.419Z&quot;</span>,</span><br><span class="line">        customer_name: <span class="string">&quot;华山医院&quot;</span>,</span><br><span class="line">        medicines_name: <span class="string">&quot;青霉素&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">id</span>: <span class="number">2</span>, </span><br><span class="line">        name: <span class="string">&quot;华山医院订单002&quot;</span>, </span><br><span class="line">        create_date: <span class="string">&quot;2018-12-27T14:10:37.208Z&quot;</span>,</span><br><span class="line">        customer_name: <span class="string">&quot;华山医院&quot;</span>,</span><br><span class="line">        medicines_name: <span class="string">&quot;青霉素 | 红霉素 &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">] </span><br></pre></td></tr></table></figure>

<p>其中 ‘id’,‘name’,‘create_date’ 这些字段的内容获取很简单，order表中就有这些字段，</p>
<p>只需要这样写就可以了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Order.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: newlist&#125;)</span><br></pre></td></tr></table></figure>

<p>问题是：‘customer_name’ 和 ‘medicines_name’ 这两个字段的值怎么获取呢？ 因为 订单对应的客户名字 和 药品的名字 都不在 Order 表中啊。</p>
<p>Order 这个Model 中 有 ‘customer’ 字段 ， 它外键关联了 Customer 表中的一个 记录，这个记录里面 的 name字段 就是我们要取的字段。</p>
<p>取 外键关联的表记录的字段值，在Django中很简单，可以直接通过 外键字段 后面加 两个下划线 加 关联字段名的方式 来获取。</p>
<p>比如 这里我们就可以用 下面的代码来实现</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    qs = Order.objects\</span><br><span class="line">            .values(</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>,</span><br><span class="line">                <span class="comment"># 两个下划线，表示取customer外键关联的表中的name字段的值</span></span><br><span class="line">                <span class="string">&#x27;customer__name&#x27;</span></span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以 浏览器访问一下 订单管理界面， F12 查看 浏览器抓包。</p>
<hr>
<p>同样的道理 ， 订单对应 的药品 名字段，是 多对多 关联， 也同样可以用 两个下划线 获取 关联字段的值， 如下所示:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    qs = Order.objects\</span><br><span class="line">            .values(</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;customer__name&#x27;</span>,</span><br><span class="line">                <span class="comment"># 两个下划线，表示取medicines 关联的表中的name字段的值</span></span><br><span class="line">                <span class="comment"># 如果有多个，就会产生多条记录</span></span><br><span class="line">                <span class="string">&#x27;medicines__name&#x27;</span></span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以 浏览器访问一下 订单管理界面， F12 查看 浏览器抓包。</p>
<hr>
<p>首先，第一个问题， 接口文档需要的名字是 ‘customer_name’ 和 ‘medicines_name’。 里面只有一个下划线， 而我们这里却产生了 两个下划线。</p>
<p>怎么办？</p>
<p>可以使用 annotate 方法将获取的字段值进行重命名，像下面这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Order.objects\</span><br><span class="line">            .annotate(</span><br><span class="line">                customer_name=F(<span class="string">&#x27;customer__name&#x27;</span>),</span><br><span class="line">                medicines_name=F(<span class="string">&#x27;medicines__name&#x27;</span>)</span><br><span class="line">            )\</span><br><span class="line">            .values(</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;customer_name&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;medicines_name&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<p>第二个问题，如果一个订单里面有多个药品，就会产生多条记录， 这不是我们要的。</p>
<p>根据接口，一个订单里面的多个药品， 用 竖线 隔开。</p>
<p>怎么办？</p>
<p>我们可以用python代码来处理，像下面这样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Order.objects\</span><br><span class="line">            .annotate(</span><br><span class="line">                customer_name=F(<span class="string">&#x27;customer__name&#x27;</span>),</span><br><span class="line">                medicines_name=F(<span class="string">&#x27;medicines__name&#x27;</span>)</span><br><span class="line">            )\</span><br><span class="line">            .values(</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>,<span class="string">&#x27;customer_name&#x27;</span>,<span class="string">&#x27;medicines_name&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可能有 ID相同，药品不同的订单记录， 需要合并</span></span><br><span class="line">    newlist = []</span><br><span class="line">    id2order = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> retlist:</span><br><span class="line">        orderid = one[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> orderid <span class="keyword">not</span> <span class="keyword">in</span> id2order:</span><br><span class="line">            newlist.append(one)</span><br><span class="line">            id2order[orderid] = one</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            id2order[orderid][<span class="string">&#x27;medicines_name&#x27;</span>] += <span class="string">&#x27; | &#x27;</span> + one[<span class="string">&#x27;medicines_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: newlist&#125;)</span><br></pre></td></tr></table></figure>





<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django==2.2.7</span><br><span class="line">pip install PyMySQL</span><br><span class="line">pip3 install django-cors-headers</span><br><span class="line">pip install djangorestframework==3.9.4</span><br><span class="line">pip install pyjwt</span><br><span class="line">pip install treelib</span><br><span class="line"></span><br><span class="line">将&quot;E:\Anaconda3\lib\site-packages\django\db\backends\mysql\operations.py&quot;下</span><br><span class="line">将其中的query = query.decode(errors=&#x27;replace&#x27;)改为 query = query.encode(errors=&#x27;replace&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from cv2 import cv2 as cv, cv2</span><br><span class="line">改为  import cv2 as cv, cv2</span><br><span class="line"></span><br><span class="line">安装anaconda</span><br><span class="line">安装pytorch</span><br><span class="line">opencv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">后端启动：</span><br><span class="line">桌面 new文件夹</span><br><span class="line">python manage.py runserver 0.0.0.0:9000</span><br><span class="line">前端启动</span><br><span class="line">soybean_front文件夹</span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line">变更数据库</span><br><span class="line">python manage.py makemigrations server</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhubaoJay/article/details/94406212">(3条消息) rest_framework学习之序列化（Serializer）_zhubaoJay的博客-CSDN博客_rest_framework serializers</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cobwebzh.top">可乐就炸鸡</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cobwebzh.top/2022/07/07/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/django/">https://cobwebzh.top/2022/07/07/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/django/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cobwebzh.top" target="_blank">可乐就炸鸡の葵花宝典</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/django/">django</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/111" target="_blank"><img class="post-qr-code-img" src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202210241925598.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/08/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/1217.%E7%8E%A9%E7%AD%B9%E7%A0%81/"><img class="prev-cover" src="http://www.dmoe.cc/random.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1217.玩筹码</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/07/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/648.%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/"><img class="next-cover" src="http://www.dmoe.cc/random.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">648.单词替换</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">安装与运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#url%E8%B7%AF%E7%94%B1"><span class="toc-number">2.</span> <span class="toc-text">url路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AEapp"><span class="toc-number">2.1.</span> <span class="toc-text">创建项目app</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#view-py"><span class="toc-number">2.2.</span> <span class="toc-text">view.py</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E8%AE%B0%E5%BD%95"><span class="toc-number">2.3.</span> <span class="toc-text">添加路由记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AD%90%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">路由子表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.1.</span> <span class="toc-text">创建数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">读取数据库表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%87%E6%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">条件过滤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB"><span class="toc-number">4.</span> <span class="toc-text">前后端分离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%94%9F%E6%88%90HTML%E4%BB%A3%E7%A0%81%E8%BF%94%E5%9B%9E"><span class="toc-number">4.1.</span> <span class="toc-text">直接生成HTML代码返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.2.</span> <span class="toc-text">使用模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-1"><span class="toc-number">4.3.</span> <span class="toc-text">前后端分离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">5.</span> <span class="toc-text">对资源的增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-mgr%E5%BA%94%E7%94%A8%E7%9B%AE%E5%BD%95"><span class="toc-number">5.1.</span> <span class="toc-text">创建 mgr应用目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%AE%A2%E6%88%B7"><span class="toc-number">5.2.</span> <span class="toc-text">列出客户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AE%A2%E6%88%B7"><span class="toc-number">5.3.</span> <span class="toc-text">添加客户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%8F%96%E6%B6%88CSRF%E6%A0%A1%E9%AA%8C"><span class="toc-number">5.4.</span> <span class="toc-text">临时取消CSRF校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AE%A2%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">5.5.</span> <span class="toc-text">修改客户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%A2%E6%88%B7"><span class="toc-number">5.6.</span> <span class="toc-text">删除客户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83"><span class="toc-number">5.7.</span> <span class="toc-text">前端环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">实现登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%99%BB%E5%BD%95%EF%BC%8C%E7%99%BB%E5%87%BA%E8%AF%B7%E6%B1%82"><span class="toc-number">6.1.</span> <span class="toc-text">处理登录，登出请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1"><span class="toc-number">6.2.</span> <span class="toc-text">创建路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session%E5%92%8Ctoken"><span class="toc-number">7.</span> <span class="toc-text">Session和token</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-number">7.1.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#token%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">token机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">8.</span> <span class="toc-text">数据库表之间的关联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-number">8.1.</span> <span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-number">8.2.</span> <span class="toc-text">一对一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">8.3.</span> <span class="toc-text">多对多</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8D%AF%E5%93%81%E7%AE%A1%E7%90%86"><span class="toc-number">8.4.</span> <span class="toc-text">药品管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORM%E5%85%B3%E8%81%94%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">ORM关联表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E8%A1%A8%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE"><span class="toc-number">9.1.</span> <span class="toc-text">外键表字段访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E8%A1%A8%E5%AD%97%E6%AE%B5%E8%BF%87%E6%BB%A4"><span class="toc-number">9.2.</span> <span class="toc-text">外键表字段过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E8%A1%A8%E7%9A%84%E5%8F%8D%E5%90%91%E8%AE%BF%E9%97%AE"><span class="toc-number">9.3.</span> <span class="toc-text">外键表的反向访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E8%A1%A8%E7%9A%84%E5%8F%8D%E5%90%91%E8%BF%87%E6%BB%A4"><span class="toc-number">9.4.</span> <span class="toc-text">外键表的反向过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.5.</span> <span class="toc-text">项目实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%9B%B4%E6%96%B0"><span class="toc-number">9.5.1.</span> <span class="toc-text">路由更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%E8%AE%B0%E5%BD%95%E6%B7%BB%E5%8A%A0"><span class="toc-number">9.5.2.</span> <span class="toc-text">事务、多对多记录添加</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F"><span class="toc-number"></span> <span class="toc-text">结束</span></a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022.07 - 2023 By 可乐就炸鸡</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
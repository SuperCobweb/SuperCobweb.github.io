<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC | 可乐就炸鸡の葵花宝典</title><meta name="keywords" content="JUC"><meta name="author" content="可乐就炸鸡"><meta name="copyright" content="可乐就炸鸡"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础知识进程和线程 进程和线程的区别(超详细)_ThinkWon的博客-CSDN博客_进程和线程的区别 进程  一个在内存中运行的应用程序。是程序执行过程中管理和分配资源的基本单位。 每个进程都有自己独立的内存空间。  线程  线程是进程的一个执行单元，是进程中的一个实体。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可以共享同一进程的数据。一个线程只能属于一个进程。线程也被称为轻量级">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="https://cobwebzh.top/2022/07/08/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/JUC/index.html">
<meta property="og:site_name" content="可乐就炸鸡の葵花宝典">
<meta property="og:description" content="基础知识进程和线程 进程和线程的区别(超详细)_ThinkWon的博客-CSDN博客_进程和线程的区别 进程  一个在内存中运行的应用程序。是程序执行过程中管理和分配资源的基本单位。 每个进程都有自己独立的内存空间。  线程  线程是进程的一个执行单元，是进程中的一个实体。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可以共享同一进程的数据。一个线程只能属于一个进程。线程也被称为轻量级">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.dmoe.cc/random.php">
<meta property="article:published_time" content="2022-07-08T07:25:00.000Z">
<meta property="article:modified_time" content="2022-10-18T07:18:58.508Z">
<meta property="article:author" content="可乐就炸鸡">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.dmoe.cc/random.php"><link rel="shortcut icon" href="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012058447.png"><link rel="canonical" href="https://cobwebzh.top/2022/07/08/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/JUC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-10-18 15:18:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012052210.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://www.dmoe.cc/random.php')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">可乐就炸鸡の葵花宝典</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-08T07:25:00.000Z" title="发表于 2022-07-08 15:25:00">2022-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-18T07:18:58.508Z" title="更新于 2022-10-18 15:18:58">2022-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/">九阳神功</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/102021274"> 进程和线程的区别(超详细)_ThinkWon的博客-CSDN博客_进程和线程的区别</a></p>
<p>进程</p>
<ul>
<li>一个在内存中运行的应用程序。是程序执行过程中管理和分配资源的基本单位。 每个进程都有自己独立的内存空间。</li>
</ul>
<p>线程</p>
<ul>
<li>线程是进程的一个执行单元，是进程中的一个实体。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可以共享同一进程的数据。一个线程只能属于一个进程。线程也被称为轻量级进程。</li>
</ul>
<p>为什么要有线程：</p>
<ul>
<li>每个进程都有自己的地址空间，即进程空间。一个服务器通常需要接收大量的并发请求，为每个一请求创建一个进程，系统开销大，请求响应速度低，因此引入线程。</li>
<li>程序的运行必须依靠线程，进程的实际执行单元是线程。</li>
</ul>
<p>进程和线程的区别</p>
<ul>
<li><p><strong>根本</strong>：进程是操作系统资源分配的基本单位，线程是处理器任务调度和执行的基本单位</p>
</li>
<li><p>切换资源开销：每一个进程都有自己的独立的代码和数据空间，程序之间切换会有较大的开销。线程是轻量的进程，同一个进程的线程共享代码和数据空间，每一个线程都有自己的运行栈和程序计数器，线程之间切换代价小</p>
</li>
<li><p>包含关系：如果一个进程有多个线程，则执行过程不是一条线的，而是多个线程共同完成的。线程是进程的一部分，所以线程也被称为轻量级进程</p>
</li>
<li><p>内存分配：同一进程的线程之间共享资源和地址空间，进程之间是独立的</p>
</li>
<li><p>影响关系：一个进程崩溃之后，在保护模式下不会对其他进程产生影响。但是一个进程的线程崩溃，整个进程就会死掉，所以多进程比多线程健壮。</p>
</li>
<li><p>执行过程：每个进程都拥有自己的程序入口、执行顺序、程序出口，但是线程不能独立运行，必须依托于进程，由应用程序提供多个线程的执行控制，两者均可并发执行。</p>
</li>
</ul>
<p>JVM中理解</p>
<ul>
<li><p>多个线程共享堆、方法区（元空间），每个线程都有自己的程序计数器、Java虚拟机栈、本地方法栈。</p>
</li>
<li><p>程序计数器为啥设为线程私有的：</p>
<ul>
<li>程序计数器主要有下面两个作用：</li>
</ul>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
<li>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li>
</ol>
<p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p>
</li>
<li><p>栈为啥被设为私有的：</p>
<ul>
<li>虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</li>
</ul>
</li>
</ul>
<p>多进程与多线程的理解</p>
<p>多进程：操作系统中运行同时多个应用程序</p>
<p>多线程：同一进程中运行同时多个任务</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220327001150616.png" alt="image-20220327001150616"></p>
<p>多线程并不能提高运行速度，但可以提高运行效率，让CPU的使用率更高。但是如果多线程有安全问题或出现频繁的上下文切换时，运算速度可能反而更低。</p>
<p>Java中的多线程</p>
<p>java程序中几个线程：主线程、垃圾回收线程、后台线程</p>
<p>java中，启动main函数时，JVM进程启动，main函数所在的线程称为主线程，可以在main函数线程执行时开启多个线程A，B，C，此时，主线程、A、B、C四个线程同时执行，互相抢夺cpu。一个线程可以创建和撤消另一个线程</p>
<p>进程和线程的选择：</p>
<ul>
<li>需要频繁创建销毁的优先使用线程。因为进程创建、销毁一个进程代价很大，需要不停的分配资源；线程频繁的调用只改变 CPU 的执行</li>
<li>线程的切换速度快，需要大量计算，切换频繁时，用线程</li>
<li>耗时的操作使用线程可提高应用程序的响应</li>
<li>线程对 CPU 的使用效率更优，多机器分布的用进程，多核分布用线程</li>
<li>需要跨机器移植，优先考虑用进程</li>
<li>需要更稳定、安全时，优先考虑用进程</li>
<li>需要速度时，优先考虑用线程</li>
<li>并行性要求很高时，优先考虑用线程</li>
</ul>
<h3 id="wait-和sleep方法"><a href="#wait-和sleep方法" class="headerlink" title="wait 和sleep方法"></a>wait 和sleep方法</h3><p>sleep和wait都会发生状态的转换，变成阻塞状态。都可以被interrupted方法中断</p>
<p>sleep方法是Thread的静态方法。wait是Object类的方法，任何实例对象都能调用</p>
<p>sleep方法不会释放锁，他也不会占用锁。wait方法会释放锁，但前提是当前线程占有锁</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>Monitor监视器、锁</p>
<p>管程是一种程序结构，结构内的多个子程序（对象或模块）形成的多个线程互斥访问共享资源</p>
<p>是一种同步机制，保证在同一时刻，只有一个线程访问被保护数据或代码</p>
<p>JVM同步基于进入和退出，使用管程对象实现的</p>
<p>用户线程：自定义的线程，可以设为守护线程</p>
<p>守护线程：比如垃圾回收</p>
<p>Java中</p>
<ul>
<li>主线程结束，用户线程还在运行，JVM存活</li>
<li>没有用户线程，只有守护线程，JVM结束</li>
</ul>
<h3 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h3><p>start方法的作用是将线程由new状态，变为runable状态。线程创建成功后线程处于new状态，调用start方法变为runable状态，线程才可以运行。</p>
<p>调用start方法后，线程不是马上运行的，而是处于ready（就绪）状态，至于何时处于running状态，需要线程等待cpu的调度，不同的JVM有不同的调度算法，线程何时被调度是未知的。start方法的得调用顺序不能决定线程的执行顺序。</p>
<p>在线程的生命周期中，线程由new状态转为runable状态只会发生一次。一个线程只能调用一次start方法，多次启动一个线程是非法的。</p>
<p>run方式是一个普通方法，当线程调用了start方法后，线程启动后会有一个回调操作，调用的是run方法</p>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p> synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>
<ol>
<li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得 当前 class 的锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的<strong>对象</strong>； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用方法之前先获取当前实例对象的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用方法之前先获取当前class的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(ClassName.class) &#123;</span><br><span class="line">         <span class="comment">// todo</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<p>实例：实现三个售票员买票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出：&quot;</span> + (num--) + <span class="string">&quot;剩余：&quot;</span> + num );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="comment">//创建三个线程，代表三个售票员</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;   <span class="comment">//匿名内部类的方式</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;     <span class="comment">//lambda表达式的方式</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>lock方法获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>lock与synchronized的区别</p>
<ul>
<li>synchronized是java关键字，jvm内置，而lock不是内置，是一个类，可以实现同步访问且比synchronized中的方法更加丰富</li>
<li>synchronized不需要手动释放锁，而lock需手动释放锁（不解锁会出现死锁，需要在 finally 块中释放锁）</li>
<li>lock等待锁的线程会相应中断，而synchronized不会相应，只会一直等待</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</li>
<li>Lock 可以提高多个线程进行读操作的效率（当多个线程竞争的时候）</li>
</ul>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220331221906221.png" alt="image-20220331221906221"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220404192747424.png" alt="image-20220404192747424"></p>
<p>在线程的生命周期中，它要经过新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。尤其是当线程启动以后，它不可能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、就绪之间切换。</p>
<p>当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。</p>
<p>当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。</p>
<p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。</p>
<p>当一个线程开始运行后，它不可能一直处于运行状态，线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务。当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。当发生如下情况时，线程将会进入阻塞状态：</p>
<ul>
<li>线程调用sleep()方法主动放弃所占用的处理器资源。</li>
<li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。</li>
<li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。</li>
<li>线程在等待某个通知（notify）。</li>
<li>程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。</li>
</ul>
<p>针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：</p>
<ul>
<li>调用sleep()方法的线程经过了指定时间。</li>
<li>线程调用的阻塞式IO方法已经返回。</li>
<li>线程成功地获得了试图取得的同步监视器。</li>
<li>线程正在等待某个通知时，其他线程发出了一个通知。</li>
<li>处于挂起状态的线程被调用了resume()恢复方法。</li>
</ul>
<p>线程会以如下三种方式结束，结束后就处于死亡状态：</p>
<ul>
<li>run()或call()方法执行完成，线程正常结束。</li>
<li>线程抛出一个未捕获的Exception或Error。</li>
<li>直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用。</li>
<li>使用interrupt()方法</li>
</ul>
<p>启用stop方法原因：</p>
<ul>
<li>调用stop方法后，会立即停止运行run方法后面剩余的全部工作，包括catch和finally内的语句，并抛出ThreadDead异常，因此可能会有一些清理工作无法完成，如文件、数据库的关闭。</li>
<li>调用stop方法后，会立即释放该线程持有的所有锁，可能会导致数据得不到同步，出现数据不一致问题。</li>
</ul>
<p>interrupt方法</p>
<ul>
<li><p>调用interrupt方法，在当前线程中打一个停止的标记，并不是真的停止线程。线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public boolean Thread.isInterrupted() &#x2F;&#x2F;判断是否被中断<br>public static boolean Thread.interrupted() &#x2F;&#x2F;判断是否被中断，并清除当前中断状态</p>
<p>这两个方法使得当前线程能够感知到是否被中断了（通过检查标志位）<br>所以如果希望线程 t 在中断后停止，就必须先判断是否被中断，并为它增加相应的中断处理代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 线程间通信</span><br><span class="line"></span><br><span class="line">线程间通信的模型有两种：共享内存和消息传递</span><br><span class="line">**线程间的通信具体步骤：**（涉及上中下部）</span><br><span class="line"></span><br><span class="line">1. 创建资源类，在资源类中创建属性和操作方法</span><br><span class="line">2. 在资源类操作方法：判断、操作、通知</span><br><span class="line">3. 创建多个线程，调用资源类的操作方法</span><br><span class="line">4. 防止虚假唤醒问题</span><br><span class="line"></span><br><span class="line">### synchronized案例</span><br><span class="line"></span><br><span class="line">操作线程的时候，等待线程使用wait()，通知另外的线程操作用notify()、notifyAll()</span><br><span class="line">假设有两个线程，该线程在执行过程中，判断值（不是该值等待，让其他线程抢），操作值，通知另外一个线程的调度</span><br><span class="line"></span><br><span class="line">通过使用两个线程对0这个值操作，一个线程加1，一个线程减1，交替实现多次</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//第一步 创建资源类，定义属性和操作方法</span><br><span class="line">class Share &#123;</span><br><span class="line">    //初始值</span><br><span class="line">    private int number = 0;</span><br><span class="line">    //+1的方法</span><br><span class="line">    public synchronized void incr() throws InterruptedException &#123;</span><br><span class="line">        //第二步 判断 干活 通知</span><br><span class="line">       if(number != 0) &#123; //判断number值是否是0，如果不是0，等待</span><br><span class="line">            this.wait(); //在哪里睡，就在哪里醒</span><br><span class="line">        &#125;</span><br><span class="line">        //如果number值是0，就+1操作</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; :: &quot;+number);</span><br><span class="line">        //通知其他线程</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //-1的方法</span><br><span class="line">    public synchronized void decr() throws InterruptedException &#123;</span><br><span class="line">        //判断</span><br><span class="line">        if(number != 1) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        //干活</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; :: &quot;+number);</span><br><span class="line">        //通知其他线程</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadDemo1 &#123;</span><br><span class="line">    //第三步 创建多个线程，调用资源类的操作方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Share share = new Share();</span><br><span class="line">        //创建线程</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 1; i &lt;=10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    share.incr(); //+1</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;AA&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 1; i &lt;=10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    share.decr(); //-1</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;BB&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果再加CC，DD的线程，CC加一操作，DD减一操作，会出现虚假唤醒问题</p>
<p>这时需要将if的wait等待，换成while</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">this</span>.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="lock案例"><a href="#lock案例" class="headerlink" title="lock案例"></a>lock案例</h3><p>使用lock先要创建锁的对象以及通知的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Lock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上锁lock.lock();<br>解锁lock.unlock();<br>以下都为condition类：<br>唤醒所有等待的线程signalAll()，带上类名condition.signalAll();<br>唤醒一个等待线程signal()，带上类名，condition.signal();<br>造成当前线程在接到信号或者被中断之前一直处于等待状态await()，带上类名，condition.await();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步 创建资源类，定义属性和操作方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Lock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.incr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.decr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.incr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    share.decr();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;DD&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程间定制化通信"><a href="#线程间定制化通信" class="headerlink" title="线程间定制化通信"></a>线程间定制化通信</h3><p>定制化通信就是让线程按一定顺序执行</p>
<p><strong>案列</strong>：启动三个线程，按照如下要求：<br>AA打印5此，BB打印10次，CC打印15次，一共进行10轮</p>
<p><strong>具体思路</strong>：<br>每个线程添加一个标志位，是该标志位则执行操作，并且修改为下一个标志位，通知下一个标志位的线程</p>
<p>创建一个可重入锁private Lock lock &#x3D; new ReentrantLock();<br>分别创建三个开锁通知private Condition c1 &#x3D; lock.newCondition();</p>
<p>具体资源类中的A线程代码操作<br>上锁，（执行具体操作（判断、操作、通知），解锁）放于try、finally</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步 创建资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareResource</span> &#123;</span><br><span class="line">    <span class="comment">//定义标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 1 AA     2 BB     3 CC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建三个condition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印5次，参数第几轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+i+<span class="string">&quot; ：轮数：&quot;</span>+loop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            flag = <span class="number">2</span>; <span class="comment">//修改标志位 2</span></span><br><span class="line">            c2.signal(); <span class="comment">//通知BB线程</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印10次，参数第几轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+i+<span class="string">&quot; ：轮数：&quot;</span>+loop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知CC线程</span></span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印15次，参数第几轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">(<span class="type">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; :: &quot;</span>+i+<span class="string">&quot; ：轮数：&quot;</span>+loop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改标志位</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知AA线程</span></span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareResource</span> <span class="variable">shareResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareResource</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareResource.print5(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareResource.print10(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareResource.print15(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="集合的线程安全"><a href="#集合的线程安全" class="headerlink" title="集合的线程安全"></a>集合的线程安全</h2><p>实现List接口的线程安全的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Collectios</span>.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());<span class="comment">//返回指定列表的同步列表</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList 用到写时复制技术：</p>
<ul>
<li>读的时候并发读，都可以读</li>
<li>写的时候先复制到一个新的object数组中，将其写到新的数组中，新旧合并</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line">Map&lt;Integer, Integer&gt; map = ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h2 id="多线程锁"><a href="#多线程锁" class="headerlink" title="多线程锁"></a>多线程锁</h2><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会进入队列排队，永远是队列第一个线程得到锁</p>
<ul>
<li>优点：所有的线程都能得到资源，不会饿死在队列中。</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
<p>非公平锁：表示获取锁的抢占机制是随机获取的，多个线程获取锁的时候会直接尝试去获取，获取不到进入等待队列，如果能获取到，直接获取到锁</p>
<ul>
<li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//公平锁，默认非公平锁</span></span><br></pre></td></tr></table></figure>



<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁：以线程为单位，当一个线程获取对象锁后，这个线程可以再次获取本对象上的锁，而其他线程不可以</p>
<p>synchronized和ReentrantLock都是可重入锁</p>
<p>实现原理实现是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1 。</p>
<p>如果同一个线程再次请求这个锁，计数器将递增；</p>
<p>每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比如说A类中有个方法<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title function_">methodA1</span><span class="params">()</span>&#123;</span><br><span class="line">	methodA2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而且<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title function_">methodA2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//具体操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当当前线程调用A类的对象methodA1同步方法，如果其他线程没有获取A类的对象锁，那么当前线程就获得当前A类对象的锁，然后执行methodA1同步方法，方法体中调用methodA2同步方法，当前线程能够再次获取A类对象的锁，而其他线程是不可以的，这就是可重入锁。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个或以上的进程因为争夺资源而造成互相等待资源的现象称为死锁</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220329231309793.png" alt="image-20220329231309793"></p>
<p>造成死锁的原因：</p>
<ol>
<li>系统资源不足</li>
<li>系统资源分配不当</li>
<li>进程运行顺序不当</li>
</ol>
<p>验证死锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jps -l</span><br><span class="line">查看其编译代码的进程号后</span><br><span class="line">jstack 进程号</span><br></pre></td></tr></table></figure>

<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220329233650256.png" alt="image-20220329233650256"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220329233723712.png" alt="image-20220329233723712"></p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="comment">//创建两个对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;持有锁a， 试图获取锁b&quot;</span>);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(1);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;持有锁b， 试图获取锁a&quot;</span>);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(1);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>锁主要分为两类：</p>
<p>排他锁：在同一时刻只允许一个线程进行访问，其他线程等待；synchronized和lock都是排它锁</p>
<p>读写锁：在同一时刻允许多个读线程访问，但是当写线程访问，所有的写线程和读线程均被阻塞。读写锁维护了一个读锁加一个写锁，通过读写锁分离的模式来保证线程安全，性能高于一般的排他锁。</p>
<p>创建读写锁对象private ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();<br>写锁 加锁 rwLock.writeLock().lock();，解锁为rwLock.writeLock().unlock();<br>读锁 加锁rwLock.readLock().lock();，解锁为rwLock.readLock().unlock();</p>
<p>写锁降级为读锁</p>
<p>获取写锁—&gt; 获取读锁—-&gt; 释放写锁—-&gt; 释放读锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示读写锁降级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//可重入读写锁对象</span></span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();<span class="comment">//读锁</span></span><br><span class="line">        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();<span class="comment">//写锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁降级</span></span><br><span class="line">        <span class="comment">//1 获取写锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;manongyanjiuseng&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 获取读锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;---read&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3 释放写锁</span></span><br><span class="line">        writeLock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4 释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：为什么存在读锁的时候写锁不能获取？</strong><br> 读写锁要确保写锁的操作对读锁是可见的，假如允许读锁在已被获取的情况下还能获取写锁，那么正在运行的其他的读线程就无法感知到写线程的操作。所以，只有等待其他的读线程都释放了读锁，写锁才能被当前线程获取，当然，写锁一旦被获取，其他的读写线程的后续访问都会被阻塞。</p>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><p>悲观锁（同步互斥）</p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<p> 乐观锁 （非阻塞同步）</p>
<p>乐观锁，总是乐观地假设最好的情况，每次去拿数据的时候都认为别人不会修改这个数据，所以不会上锁，只会要对数据进行更新时判断一下在此期间(拿到数据到更新的期间)别人有没有去更改这个数据，可以使用版本号机制和CAS算法实现。</p>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<p>版本号控制机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</span><br><span class="line"></span><br><span class="line">举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 <span class="number">1</span> ；而当前帐户余额字段（ balance ）为 $<span class="number">100</span> 。</span><br><span class="line"></span><br><span class="line">操作员 A 此时将其读出（ version=<span class="number">1</span> ），并从其帐户余额中扣除 $<span class="number">50</span>（ $<span class="number">100</span>-$<span class="number">50</span> ）。</span><br><span class="line">在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=<span class="number">1</span> ），并从其帐户余额中扣除 $<span class="number">20</span> （ $<span class="number">100</span>-$<span class="number">20</span> ）。</span><br><span class="line">操作员 A 完成了修改工作，将数据版本号加一（ version=<span class="number">2</span> ），连同帐户扣除后余额（ balance=$<span class="number">50</span> ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 <span class="number">2</span> 。</span><br><span class="line">操作员 B 完成了操作，也将版本号加一（ version=<span class="number">2</span> ）试图向数据库提交数据（ balance=$<span class="number">80</span> ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 <span class="number">2</span> ，数据库记录当前版本也为 <span class="number">2</span> ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</span><br><span class="line">这样，就避免了操作员 B 用基于 version=<span class="number">1</span> 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</span><br></pre></td></tr></table></figure>

<p>CAS算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CAS（Compare And Swap）是一种常见的“乐观锁”，是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。大部分的CPU都有对应的汇编指令，它有三个操作数：内存地址V，旧值A，新值B。只有当前内存地址V上的值是A，B才会以原子方式写到V上，否则操作失败。失败的话，一般情况下是一个自旋操作，即不断的重试。关于自旋操作，https:<span class="comment">//blog.csdn.net/qq_34337272/article/details/81252853</span></span><br></pre></td></tr></table></figure>

<p>乐观锁中常见的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ABA 问题</span><br><span class="line">如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <span class="string">&quot;ABA&quot;</span>问题。</span><br><span class="line"></span><br><span class="line">JDK <span class="number">1.5</span> 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 循环时间长开销大</span><br><span class="line">自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 只能保证一个共享变量的原子操作</span><br><span class="line">CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK <span class="number">1.5</span>开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</span><br></pre></td></tr></table></figure>

<p> CAS与synchronized的使用情景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），<span class="keyword">synchronized</span>适用于写比较多的情况下（多写场景，冲突一般较多）</span><br><span class="line"></span><br><span class="line">对于资源竞争较少（线程冲突较轻）的情况，使用<span class="keyword">synchronized</span>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</span><br><span class="line">对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于<span class="keyword">synchronized</span>。</span><br><span class="line">补充： Java并发编程这个领域中<span class="keyword">synchronized</span>关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE <span class="number">1.6</span>之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。<span class="keyword">synchronized</span>的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35190492/article/details/116431270">(3条消息) ThreadLocal使用与原理_敖 丙的博客-CSDN博客_threadlocal</a></p>
<p>ThreadLocal 本地线程变量</p>
<p>每一个线程都有一个自己的ThreadLocalMap，ThreadLocalMap中存放着本线程所有的ThreadLocal变量，ThreadLocalMap中的key就是ThreadLocal对象实例</p>
<p>ThreadLocal.ThreadLocalMap是一个比较特殊的Map，它的每个Entry的key都是一个弱引用：</p>
<p>如果使用强引用，当<code>ThreadLocal</code> 对象的引用（强引用）被回收了，<code>ThreadLocalMap</code>本身依然还持有<code>ThreadLocal</code>的强引用，如果没有手动删除这个key ,则<code>ThreadLocal</code>不会被回收，所以只要当前线程不消亡，<code>ThreadLocalMap</code>引用的那些对象就不会被回收， 可以认为这导致<code>Entry</code>内存泄漏。</p>
<p>附：强引用-软引用-弱引用</p>
<ul>
<li>强引用：普通的引用，强引用指向的对象不会被回收；</li>
<li>软引用：仅有软引用指向的对象，只有发生gc且内存不足，才会被回收；</li>
<li>弱引用：仅有弱引用指向的对象，只要发生gc就会被回收。</li>
</ul>
<p>这样设计的好处是，如果这个变量不再被其他对象使用时，可以自动回收这个ThreadLocal对象，避免可能的内存泄露（注意，Entry中的value，依然是强引用，如何回收，见下文分解）</p>
<p>可以看到，只有当Thread被回收时，这个value才有被回收的机会，否则，只要线程不退出，value总是会存在一个强引用。但是，要求每个Thread都会退出，是一个极其苛刻的要求，对于线程池来说，大部分线程会一直存在在系统的整个生命周期内，那样的话，就会造成value对象出现泄漏的可能。处理的方法是，在ThreadLocalMap进行set(),get(),remove()的时候，都会进行清理</p>
<p>真正用来回收value的是expungeStaleEntry()方法，在remove()和set()方法中，都会直接或者间接调用到这个方法进行value的清理：</p>
<p>从这里可以看到，ThreadLocal为了避免内存泄露，也算是花了一番大心思。不仅使用了弱引用维护key，还会在每个操作上检查key是否被回收，进而再回收value。</p>
<p>但是从中也可以看到，ThreadLocal并不能100%保证不发生内存泄漏。</p>
<p>比如，很不幸的，你的get()方法总是访问固定几个一直存在的ThreadLocal，那么清理动作就不会执行，如果你没有机会调用set()和remove()，那么这个内存泄漏依然会发生。</p>
<p>因此，一个良好的习惯依然是：当你不需要这个ThreadLocal变量时，主动调用remove()，这样对整个系统是有好处的。</p>
<p>解决hash冲突使用的是线性探测法</p>
<p>InheritableThreadLocal是支持父子间继承的ThreadLocal</p>
<ol>
<li>变量的传递是发生在线程创建的时候，如果不是新建线程，而是用了线程池里的线程，就不灵了</li>
<li>变量的赋值就是从主线程的map复制到子线程，它们的value是同一个对象，如果这个对象本身不是线程安全的，那么就会有线程安全问题</li>
</ol>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><p>Thread类也实现了Runnable接口，这是需要重写run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mt.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h3><p>方式一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;     <span class="comment">//lambda表达式的方式</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;, <span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实现Callable"><a href="#实现Callable" class="headerlink" title="实现Callable"></a>实现Callable</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<p>因为Thread的构造函数中没有Callable接口的参数设置<br>直接替换不可以，只能用下面这种线程创建方法</p>
<p>FutureTask 实现了Runnable接口，并且构造函数有Callable参数</p>
<p>FutureTask的构造函数：</p>
<ul>
<li>FutureTask(Callable&lt;&gt; callable) 创建一个FutureTask，一旦运行就执行给定的Callable</li>
<li>FutureTask(Runnable runnable,V result)创建一个FutureTask，一旦运行就执行给定的Ru你那边了，并安排成功完成时get返回给定的结果</li>
</ul>
<p><code>get()</code>获取结果<br><code>isDone()</code>判断是否计算结束</p>
<p>实现方式一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1,<span class="string">&quot;lucy&quot;</span>).start(); <span class="comment">//创建线程</span></span><br><span class="line">System.out.println(futureTask1.get()); <span class="comment">//获取结果，这个是主线程进行汇总，lucy线程结束之后进行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lam表达式</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h2 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>减少计数</p>
<p>CountDownLatch能够使一个线程等待另外一些线程完成各自的工作后再执行。使用一个计数器来实现，计数器的初始值为需要等待的线程数量，每一个线程完成之后都要进行减一操作（countDown()），直到计数器的值为零，表示等待的所有线程完成工作，在CountDownLatch上等待的线程可以恢复接下来的操作。等待语句之前使用await()来阻塞当前线程。</p>
<p>例子：6位同学陆续离开教室，班长才能锁门</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示 CountDownLatch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建CountDownLatch对象，设置初始值</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6个同学陆续离开教室之后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 号同学离开了教室&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计数  -1</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待，阻塞当前线程</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 班长锁门走人了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>循环栅栏</p>
<p>作用：让所有线程都等待完成后才会继续下一步行动。</p>
<p>常用的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties，Runnable barrierAction)</span></span><br></pre></td></tr></table></figure>

<p>parties 是参与线程的个数<br>第二个构造方法有一个 Runnable 参数，这个参数的意思是最后一个到达线程要做的任务</p>
<p>常用的方法有：<br>await()：线程调用 await() 表示自己已经到达栅栏</p>
<p>例子：召集七个龙珠可以召唤神龙</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER,()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;*****集齐7颗龙珠就可以召唤神龙&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集齐七颗龙珠过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 星龙被收集到了&quot;</span>);</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量</p>
<p>可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。</p>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">acquire()  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。</span><br><span class="line">release()</span><br><span class="line">释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。</span><br></pre></td></tr></table></figure>

<p>例子：6辆车，抢3个车位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6辆汽车，停3个车位</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Semaphore，设置许可数量</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟6辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//抢占</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 抢到了车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ------离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220331195420620.png" alt="image-20220331195420620"></p>
<p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p>
<ul>
<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</li>
<li>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</li>
</ul>
<p>为什么需要阻塞队列：</p>
<p>在多线程领域，某些情况下需要挂起线程（阻塞），一旦某些条件满足，被挂起的线程就会被自动唤醒。使用阻塞队列的好处是我们不需要关心什么时候需要挂起线程，什么时候线程被唤醒，这都由BlockingQueue做了。在concurrent包发布之前，程序员需要自己实现控制这些细节，需要兼顾效率和线程安全，较为复杂。</p>
<p>BlockingQueue阻塞队列是属于一个接口，底下有七个实现类</p>
<ul>
<li><p>ArrayBlockQueue：由数组结构组成的有界阻塞队列</p>
</li>
<li><p>LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列</p>
</li>
<li><ul>
<li>有界，但是界限非常大，相当于无界，可以当成无界</li>
</ul>
</li>
<li><p>PriorityBlockQueue：支持优先级排序的无界阻塞队列</p>
</li>
<li><p>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</p>
</li>
<li><p>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列</p>
</li>
<li><ul>
<li>生产一个，消费一个，不存储元素，不消费不生产</li>
</ul>
</li>
<li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列</p>
</li>
<li><p>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</p>
</li>
</ul>
<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuoAT/p/6714762.html">Java线程池（ThreadPool）详解 - 适AT - 博客园 (cnblogs.com)</a></p>
<h3 id="种类与创建"><a href="#种类与创建" class="headerlink" title="种类与创建"></a>种类与创建</h3><p>线程池：一种线程的使用模式。线程过多会带来线程调度开销，影响缓存局部性和整体性。线程池维护着多个线程，等待着监督管理者分配可并发的任务。避免了处理短时间任务时线程的创建和销毁线程的代价。线程池不仅能保证内核的充分利用，还能防止过分调度。</p>
<p>特点：</p>
<ul>
<li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>
<li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220331201633892.png" alt="image-20220331201633892"></p>
<p>种类与创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Executors.newFixedThreadPool(<span class="type">int</span>)一池N线程,指定大小的线程池，可控制线程的最大并发数</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//5个窗口</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Executors.newSingleThreadExecutor()一池一线程</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//一个窗口</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Executors.newCachedThreadPool()一池可扩容根据需求创建线程</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Executors.newScheduledThreadPool() 定时任务线程池</span><br><span class="line">    创建一个定长的线程池，可以指定线程池核心线程数，支持定时及周期性任务的执行</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行线程execute()</span><br><span class="line">关闭线程shutdown()</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;参数为Runnable接口类，可以通过设置lambda</span><br><span class="line"></span><br><span class="line">　<span class="title function_">execute</span><span class="params">()</span>方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</span><br><span class="line"></span><br><span class="line">　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示线程池三种常用分类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//一池五线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//5个窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//一个窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池可扩容线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//执行</span></span><br><span class="line">                threadPool3.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            threadPool3.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p>Executors类提供4个静态工厂方法：newCachedThreadPool()、newFixedThreadPool(int)、newSingleThreadExecutor和newScheduledThreadPool(int)。这些方法最终都是通过ThreadPoolExecutor类来完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                         <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                         TimeUnit unit,</span></span><br><span class="line"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                         ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                         RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">     keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> corePoolSize, 常驻线程数量（核心）</span><br><span class="line"><span class="type">int</span> maximumPoolSize,最大线程数量</span><br><span class="line"><span class="type">long</span> keepAliveTime线程没有执行任务时的存活时间，</span><br><span class="line">TimeUnit unit,参数keepAliveTime的时间单位，有<span class="number">7</span>种取值，在TimeUnit类中有<span class="number">7</span>种静态属性</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,阻塞队列（排队的线程放入）</span><br><span class="line">ThreadFactory threadFactory,线程工厂，用于创建线程</span><br><span class="line">RejectedExecutionHandler handler拒绝处理任务的策略，有以下四种：（线程满了）</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.AbortPolicy;<span class="comment">//丢弃任务并抛出RejectedExecutionException异常。 默认的</span></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy;<span class="comment">//也是丢弃任务，但是不抛出异常。 </span></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy;<span class="comment">//丢弃队列最前面的任务(等待最久的任务)，把当前任务加入到队列中，然后重新尝试执行任务（重复此过程）</span></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy;<span class="comment">//既不会抛弃任务，也不会抛出异常，会退给调用者，由调用线程处理该任务，</span></span><br></pre></td></tr></table></figure>

<p>线程池的工作流程：</p>
<ol>
<li><p>创建了线程池之后，线程池中的线程数为0</p>
</li>
<li><p>当调用execute()方法添加一个请求任务时，线程池会做出以下判断：</p>
<p>2.1 如果正在运行的线程数小于corePoolSize时，马上创建线程运行这个任务</p>
<p>2.2 如果正在运行的线程数大于等于corePoolSize时，将这个任务放入队列中</p>
<p>2.3 如果这个时候队列满了并且当前正在运行的线程数小于maximumPoolSize时，创建非核心线程立刻运行这个任务</p>
<p>2.4 如果队列满了并且当前正在运行的线程数大于等于maximumPoolSize时，那么线程启动饱和拒绝策略来执行。</p>
</li>
<li><p>当一个线程完成任务时，他会从队列中选取下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做时并且超过了一定时间keepAliveTime, 线程会判断：</p>
<p>4.1 如果当前运行的线程超过了maximumPoolSize时，那么这个线程会停掉</p>
<p>4.2 当线程池的所有任务完成后，他最终会收缩到corePoolSize的大小</p>
</li>
</ol>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>在实际开发中，一般不会用Executors去创建线程池，而是通过ThreadPoolExecutor的方式自己定义线程池</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220331234602148.png" alt="image-20220331234602148"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    MyTask(<span class="type">int</span> i)&#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 办理业务 : &quot;</span>  + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()  <span class="comment">//抛出异常的局决策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//执行</span></span><br><span class="line">                <span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(i);</span><br><span class="line">                threadPool.execute(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220401000638016.png" alt="image-20220401000638016"></p>
<h2 id="Fork和Join"><a href="#Fork和Join" class="headerlink" title="Fork和Join"></a>Fork和Join</h2><p>将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果</p>
<p>案例：从1加到100</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分差值不能超过10，计算10以内运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin ;<span class="comment">//拆分开始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;<span class="comment">//拆分结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result ; <span class="comment">//返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建有参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分和合并过程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断相加两个数值是否大于10</span></span><br><span class="line">        <span class="keyword">if</span>((end-begin)&lt;=VALUE) &#123;</span><br><span class="line">            <span class="comment">//相加操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;=end; i++) &#123;</span><br><span class="line">                result = result+i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//进一步拆分</span></span><br><span class="line">            <span class="comment">//获取中间值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拆分左边</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);</span><br><span class="line">            <span class="comment">//拆分右边</span></span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//调用方法拆分</span></span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            <span class="comment">//合并结果</span></span><br><span class="line">            result = task01.join()+task02.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建MyTask对象</span></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建分支合并池对象</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line">        <span class="comment">//获取最终合并之后结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//关闭池对象</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>CompletableFuture类用于Java中异步编程，异步意味着非阻塞，可以是任务运行在与主线程分离的其他线程上，并且可以通过回调，主线程可以获得异步任务的执行状态，是否完成、是否异常等信息。</p>
<p>CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的CompletableFuture 类</p>
<p>异步调用没有返回值方法<code>runAsync</code><br>异步调用有返回值方法<code>supplyAsync</code></p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步调用和同步调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//同步调用</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : CompletableFuture1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture1.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mq消息队列</span></span><br><span class="line">        <span class="comment">//异步调用</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : CompletableFuture2&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture2.whenComplete((t,u)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------t=&quot;</span>+t);</span><br><span class="line">            System.out.println(<span class="string">&quot;------u=&quot;</span>+u);</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Future-和-CompletableFuture"><a href="#Future-和-CompletableFuture" class="headerlink" title="Future 和 CompletableFuture"></a>Future 和 CompletableFuture</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/344431341">CompletableFuture用法详解 - 知乎 (zhihu.com)</a></p>
<p>Java1.5以后出现Callable和Future，解决了创建的线程没有线程执行结果返回值问题。当我们需要返回之时，可以使用get方法<strong>等待线程完成</strong>并获取返回值，Future的get方法会阻塞主线程，Future获取得线程执行结果前，我们的主线程get()得到结果需要一直阻塞等待，即使我们使用isDone()方法轮询去查看线程执行状态，但是这样也非常浪费cpu资源。</p>
<p>Future对于结果的获取，不是很友好，只能通过<strong>阻塞</strong>或者<strong>轮询的方式</strong>得到任务的结果。</p>
<ul>
<li>Future.get() 就是阻塞调用，在线程获取结果之前<strong>get方法会一直阻塞</strong>。</li>
<li>Future提供了一个isDone方法，可以在程序中<strong>轮询这个方法查询</strong>执行结果。</li>
</ul>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220401200838670.png" alt="image-20220401200838670"></p>
<p><strong>阻塞的方式和异步编程的设计理念相违背，而轮询的方式会耗费无谓的CPU资源</strong>。在Java1.8中出现了CompletableFuture，CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。 CompletableFuture被设计在Java中进行异步编程。异步编程意味着在主线程之外创建一个独立的线程，与主线程分隔开，并在上面运行一个非阻塞的任务，然后<strong>通知</strong>主线程进展，成功或者失败。</p>
<p>通过这种方式，你的主线程不用为了任务的完成而阻塞&#x2F;等待，你可以用主线程去并行执行其他的任务。 使用这种并行方式，极大地提升了程序的表现。</p>
<p>创建异步任务</p>
<ul>
<li>supplyAsync执行CompletableFuture任务，支持返回值</li>
<li>runAsync执行CompletableFuture任务，没有返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="comment">//自定义线程，根据supplier构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> </span><br><span class="line"><span class="comment">//自定义线程，根据runnable构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,  Executor executor)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6970558076642394142">异步编程利器：CompletableFuture详解 ｜Java 开发实战 - 掘金 (juejin.cn)</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220401223032756.png" alt="image-20220401223032756"></p>
<h2 id="总得有个终点吧"><a href="#总得有个终点吧" class="headerlink" title="总得有个终点吧"></a>总得有个终点吧</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cobwebzh.top">可乐就炸鸡</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cobwebzh.top/2022/07/08/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/JUC/">https://cobwebzh.top/2022/07/08/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/JUC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cobwebzh.top" target="_blank">可乐就炸鸡の葵花宝典</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/111" target="_blank"><img class="post-qr-code-img" src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202210241925598.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/09/%E4%B9%9D%E9%98%B4%E7%9C%9F%E7%BB%8F/873.%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"><img class="prev-cover" src="http://www.dmoe.cc/random.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">873.最长的斐波那契子序列的长度</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/08/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/jvm/"><img class="next-cover" src="http://www.dmoe.cc/random.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E5%92%8Csleep%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">wait 和sleep方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#start%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">start方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">Lock接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">2.1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock"><span class="toc-number">2.2.</span> <span class="toc-text">lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lock%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.</span> <span class="toc-text">lock案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%AE%9A%E5%88%B6%E5%8C%96%E9%80%9A%E4%BF%A1"><span class="toc-number">3.2.</span> <span class="toc-text">线程间定制化通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.</span> <span class="toc-text">集合的线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">多线程锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">5.4.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">5.5.</span> <span class="toc-text">悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">5.6.</span> <span class="toc-text">ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread"><span class="toc-number">6.1.</span> <span class="toc-text">继承Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable"><span class="toc-number">6.2.</span> <span class="toc-text">实现Runnable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable"><span class="toc-number">6.3.</span> <span class="toc-text">实现Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.4.</span> <span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">7.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">7.2.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">7.3.</span> <span class="toc-text">Semaphore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-1"><span class="toc-number">9.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA"><span class="toc-number">9.1.</span> <span class="toc-text">种类与创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">线程池原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.3.</span> <span class="toc-text">自定义线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork%E5%92%8CJoin"><span class="toc-number">10.</span> <span class="toc-text">Fork和Join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-number">11.</span> <span class="toc-text">异步回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-%E5%92%8C-CompletableFuture"><span class="toc-number">11.1.</span> <span class="toc-text">Future 和 CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E5%BE%97%E6%9C%89%E4%B8%AA%E7%BB%88%E7%82%B9%E5%90%A7"><span class="toc-number">12.</span> <span class="toc-text">总得有个终点吧</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022.07 - 2023 By 可乐就炸鸡</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
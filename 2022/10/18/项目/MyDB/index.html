<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MyDB | 可乐就炸鸡の葵花宝典</title><meta name="keywords" content="MyDB"><meta name="author" content="可乐就炸鸡"><meta name="copyright" content="可乐就炸鸡"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MyDB前提知识BIO与NIO与AIO这个项目中用的是NIO 同步：调用者发起一个调用后，被调用者未处理完之前，调用是不返回的。 异步：调用者发起一个调用后，被调用者没有返回结果之前，调用者可以处理其他请求，被调用者通过回调机制通知调用者其返回结果。 同步和异步最大的区别就是：异步调用者不需要等待处理结果，被调用者会通过回调机制通知调用者其返回结果。 阻塞：调用者发起一个请求后，调用者一直等待请求">
<meta property="og:type" content="article">
<meta property="og:title" content="MyDB">
<meta property="og:url" content="https://cobwebzh.top/2022/10/18/%E9%A1%B9%E7%9B%AE/MyDB/index.html">
<meta property="og:site_name" content="可乐就炸鸡の葵花宝典">
<meta property="og:description" content="MyDB前提知识BIO与NIO与AIO这个项目中用的是NIO 同步：调用者发起一个调用后，被调用者未处理完之前，调用是不返回的。 异步：调用者发起一个调用后，被调用者没有返回结果之前，调用者可以处理其他请求，被调用者通过回调机制通知调用者其返回结果。 同步和异步最大的区别就是：异步调用者不需要等待处理结果，被调用者会通过回调机制通知调用者其返回结果。 阻塞：调用者发起一个请求后，调用者一直等待请求">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.ghser.com/random/api.php">
<meta property="article:published_time" content="2022-10-18T07:34:00.000Z">
<meta property="article:modified_time" content="2023-04-03T15:58:43.639Z">
<meta property="article:author" content="可乐就炸鸡">
<meta property="article:tag" content="MyDB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.ghser.com/random/api.php"><link rel="shortcut icon" href="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012058447.png"><link rel="canonical" href="https://cobwebzh.top/2022/10/18/%E9%A1%B9%E7%9B%AE/MyDB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MyDB',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-04-03 23:58:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012052210.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://www.dmoe.cc/random.php')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">可乐就炸鸡の葵花宝典</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MyDB</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-18T07:34:00.000Z" title="发表于 2022-10-18 15:34:00">2022-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-03T15:58:43.639Z" title="更新于 2023-04-03 23:58:43">2023-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MyDB"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MyDB"><a href="#MyDB" class="headerlink" title="MyDB"></a>MyDB</h1><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><h3 id="BIO与NIO与AIO"><a href="#BIO与NIO与AIO" class="headerlink" title="BIO与NIO与AIO"></a>BIO与NIO与AIO</h3><p>这个项目中用的是NIO</p>
<p>同步：调用者发起一个调用后，被调用者未处理完之前，调用是不返回的。</p>
<p>异步：调用者发起一个调用后，被调用者没有返回结果之前，调用者可以处理其他请求，被调用者通过回调机制通知调用者其返回结果。</p>
<p>同步和异步最大的区别就是：异步调用者不需要等待处理结果，被调用者会通过回调机制通知调用者其返回结果。</p>
<p>阻塞：调用者发起一个请求后，调用者一直等待请求结果的返回，当前线程会被挂起，无法处理其他任务。</p>
<p>非阻塞：调用者发起一个请求，调用者不用一直等待返回结果，可以去处理别的请求。</p>
<p>阻塞与非阻塞是线程等待调用结果时的状态。</p>
<p>同步、异步关注的是消息通知的机制，而阻塞、非阻塞关注的是线程等待消息通知时的状态。</p>
<p>BIO是传统的Java IO编程， blacking I&#x2F;O：同步阻塞，服务器连接模式是一个连接一个线程，即客户端有连接请求时服务端就需要启动一个线程来进行处理，没处理完之前此线程不能做其他操作。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高。java1.4 之前唯一选择</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220529210544452.png" alt="image-20220529210544452"></p>
<p>NIO 同步非阻塞IO，三大核心：Channel（通道）、Buffer（缓冲区）、Selector（选择器）</p>
<p>NIO是面向缓冲区的，或者是面向块编程的，基于通道的I&#x2F;O操作，当数据读取到一个缓冲区时，可以再缓冲区内前后移动，增加了灵活性。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器</p>
<p>NIO与IO的区别：</p>
<ol>
<li>IO流式阻塞的，NIO是非阻塞的。单线程从通道中读取数据到buffer中，在这个过程中，线程可以做别的事情，等到读取到buffer后，线程再继续处理数据。</li>
<li>IO是面向流的，NIO是面向缓冲区的。在面向IO流中，数据直接写入或读到Stream对象中，虽然Stream中也有Buffer开头的扩展类，但只是流的包装类，也是需要从流读到缓冲区；NIO可以直接将数据读到Buffer进行操作，所有的数据都是用缓冲区处理的，最常用的缓冲区为ByteBuffer。</li>
<li>NIO通过通道进行读写，通道是双向的，可读可写，通道只能与Buffer进行交互，因为Buffer，通道可以异步的读写</li>
<li>选择器，NIO选择器用于是单个线程处理多通道，可以使用较少的线程处理多个通道。</li>
</ol>
<p>NIO读写数据的方式：</p>
<ol>
<li>所有的IO都是从通道开始的</li>
<li>从通道读取数据：创建一个缓冲区，然后请求通道读取数据</li>
<li>从通道写入数据：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ol>
<p>为什么大家都不用JDK原生的NIO进行开发？</p>
<ol>
<li>JDK原生的NIO底层有epoll实现，空轮询会导致cpu飙升到100%。</li>
<li>项目庞大后，自行实现NIO很容易出现bug，维护成本高。</li>
</ol>
<p>非阻塞模式：一个线程从某通道发送或获取数据，仅能得到目前可用的数据，如果没有可用的数据时，就什么都不会获取，而不是保持线程阻塞，直到数据获取之前，该线程可以做其他的事情。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220529211200027.png" alt="image-20220529211200027"></p>
<p>区别</p>
<ul>
<li>BIO以流的方式处理数据，NIO以块的方式处理数据，块IO的效率比流IO高很多。（比如说流IO他是一个流，你必须时刻去接着他，不然一些流就会丢失造成数据丢失，所以处理这个请求的线程就阻塞了他无法去处理别的请求，他必须时刻盯着这个请求防止数据丢失。而块IO就不一样了，线程可以等他的数据全部写入到缓冲区中形成一个数据块然后再去处理他，在这期间该线程可以去处理其他请求）</li>
<li>BIO是阻塞的，NIO是非阻塞的</li>
<li>BIO基于字节流和字符流进行操作的，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作的，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道事件，因此使用单个线程就可以监听多个客户端通道</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51001708/article/details/120243503">(4条消息) FileChannel详细用法_一个普通的大学生的博客-CSDN博客_filechannel</a></p>
<p><a target="_blank" rel="noopener" href="https://ly9527.blog.csdn.net/article/details/81044759?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-81044759-blog-43268257.pc_relevant_scanpaymentv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-81044759-blog-43268257.pc_relevant_scanpaymentv1&utm_relevant_index=1">(4条消息) JAVA NIO缓冲区(Buffer)——ByteBuffer常用方法详解_沧海龙腾LV的博客-CSDN博客_buffer.put</a></p>
<p>AIO也就是NIO2，java7中引入NIO2，是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，应用操作之后会直接返回，不会阻塞在那里，当后台处理完之后，操作系统会通知相应的线程来进行后续的操作。</p>
<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206151643876.png" alt="image-20220615164358786"></p>
<p>常用方法</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206151644436.png" alt="image-20220615164452346"></p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建FileChannel</span></span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:/e.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> raf.getChannel();</span><br><span class="line"><span class="comment">// 创建bytebuffer，并向buffer中写入数据</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">bf.put(data.getBytes());</span><br><span class="line">System.out.println(bf.array()); <span class="comment">//输出</span></span><br><span class="line"><span class="comment">// 将buffer的内容写入到filechannel中</span></span><br><span class="line">bf.flip(); <span class="comment">//将pos置为0</span></span><br><span class="line"><span class="keyword">while</span> (bf.hasRemaining())&#123;</span><br><span class="line">    fc.write(bf);</span><br><span class="line">&#125;</span><br><span class="line">fc.close();</span><br></pre></td></tr></table></figure>









<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>MyDB包含5个模块</p>
<ol>
<li>Data Manager(DM)</li>
<li>Transaction Manager(TM)</li>
<li>Version Manager(VM)</li>
<li>Index Manager(IM)</li>
<li>Table Manager(TBM)</li>
</ol>
<p>DM为最底层的模块, 直接管理数据库文件(DB, database)和日志文件(LF, log file). </p>
<ul>
<li><p>DM的主要职责大致有下面这些:</p>
<p>​	 1)  分页管理DB, 并进行缓存, 提高MyDB访问DB的速率; </p>
<p>​	 2) 管理日志文件, 保证MyDB的可恢复性; </p>
<p>​	 3) 抽象DB文件为DateItem，并提供适当的抽象给上层模块, 使上层模块不用关心DB的读写细节.</p>
</li>
</ul>
<p>TM是一个相对简单的模块, 其作用是管理事务状态, 并提供接口给其他模块供它们查询. 如查询某个事务是否已经结束, 某个事务是被commit还是被abort.</p>
<p>VM基于两段锁协议，实现了调度的可串行化，并实现了MVCC(多版本并发控制), 以完全消除事务操作中的读写的阻塞. , 以及实现两种隔离度.</p>
<p>IM维护了MyDB的索引结构, 目前的索引只有B+树，目前where只支持已索引字段。</p>
<p>TBM用于维护表的结构, 会解析语句, 并根据语句内容, 对表做适当的操作.</p>
<p>5个模块的依赖关系：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220529230346890.png" alt="image-20220529230346890"></p>
<p>运行项目</p>
<ol>
<li><p>编译项目</p>
<p><code>mvn compile</code></p>
</li>
<li><p>创建数据库</p>
<p><code>mvn exec:java -Dexec.mainClass=&quot;top.cobweb.mydb.backend.Launcher&quot; -Dexec.args=&quot;-create F:\code\IDEA\mydb\db&quot;</code></p>
</li>
<li><p>以默认参数启动数据库，执行完后数据库就启动在本机的9999端口</p>
<p><code>mvn exec:java -Dexec.mainClass=&quot;top.cobweb.mydb.backend.Launcher&quot; -Dexec.args=&quot;-open F:\code\IDEA\mydb\db&quot;</code></p>
</li>
<li><p>重开一个终端，启动客户端数据库</p>
<p><code>mvn exec:java -Dexec.mainClass=&quot;top.cobweb.mydb.client.Launcher&quot;</code></p>
</li>
</ol>
<h2 id="事务管理-TM"><a href="#事务管理-TM" class="headerlink" title="事务管理 TM"></a>事务管理 TM</h2><p>这个事务的管理是对XID文件的管理，是对事务的状态记录下来的管理，而实际内存中正在处理的事务是由VM这个模块进行管理，包括开启事务，事务的隔离级别等。同样事务也存在缓存中。</p>
<p>TransactionManage维护一个XID格式的文件，用来记录事务的各个转态，每个事务有三个状态</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220529220031014.png" alt="image-20220529220031014"></p>
<p>每个事务都有一个trx_id, 事务的id从1开始，并且自增，不能重复。并且规定id为0为超级事务，当一些操作在没有申请事务的情况下进行，可以将操作的id设置为0，id为0 的事务状态永远是committed。</p>
<p>XID文件的内容，文件头：8个字节的数字，记录这个XID文件管理的事务数量；事务的状态：一个字节。</p>
<p>id为0的状态不需要记录，因此，事务的xid在文件中的状态就存储在(xid - 1) + 8字节处。</p>
<p>TransactionManage 提供创建事务和查询事务状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建XID文件 并设置XID文件头即XID管理的事务数量，为8个字节的0,并创建TM</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">create</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从已有的XID文件来创建TM</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">open</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>TransactionManagerImpl</p>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RandomAccessFile file;</span><br><span class="line"><span class="keyword">private</span> FileChannel fc;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> xidCounter;</span><br><span class="line"><span class="keyword">private</span> Lock counterLock;</span><br><span class="line"></span><br><span class="line">TransactionManagerImpl(RandomAccessFile raf, FileChannel fc) &#123;</span><br><span class="line">    <span class="built_in">this</span>.file = raf;</span><br><span class="line">    <span class="built_in">this</span>.fc = fc;</span><br><span class="line">    counterLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    checkXIDCounter(); <span class="comment">// 对XID文件进行校验，保证XID是一个合法的XID文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查XID文件是否合法</span></span><br><span class="line"><span class="comment"> * 读取XID_FILE_HEADER中的xidcounter，根据它计算文件的理论长度，对比实际长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileLen = file.length();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.xidCounter = Parser.parseLong(buf.array());</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> getXidPosition(<span class="built_in">this</span>.xidCounter + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(end != fileLen) &#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始一个事务，设置一个xidcounter+1的状态为active，更新文件头，需要上锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始一个事务，并返回XID</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">    counterLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xidCounter + <span class="number">1</span>;</span><br><span class="line">        updateXID(xid, FIELD_TRAN_ACTIVE);</span><br><span class="line">        incrXIDCounter();</span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        counterLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更新xid事务的状态为status</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE];</span><br><span class="line">    tmp[<span class="number">0</span>] = status;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(tmp);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将XID加一，并更新XID Header</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    xidCounter ++;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：这里所有的文件操作在执行结束后立刻刷入文件中，放置在崩溃后文件丢失数据，fileChannel的force()方法，强制同步缓存中的内容到文件，类似于BIO中的flush()方法。</p>
<h2 id="数据管理-DM"><a href="#数据管理-DM" class="headerlink" title="数据管理 DM"></a>数据管理 DM</h2><p>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：</p>
<ol>
<li><p>分页管理 DB 文件，并进行缓存；</p>
</li>
<li><p>管理日志文件，保证在发生错误时可以根据日志进行恢复；</p>
</li>
<li><p>抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p>
</li>
</ol>
<p>DB的首要工作是对磁盘文件进行封装，向下直接读写文件，向上提供数据的包装。另外就是日志功能。</p>
<p>DM会对DB进行缓存以加快对DB的读写。</p>
<h3 id="共享内存数组"><a href="#共享内存数组" class="headerlink" title="共享内存数组"></a>共享内存数组</h3><p>在 Java 中，当你执行类似 subArray 的操作时，只会在底层进行一个复制，而不是同一块内存。 于是，我写了一个 SubArray 类，来（松散地）规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="引用计数缓存"><a href="#引用计数缓存" class="headerlink" title="引用计数缓存"></a>引用计数缓存</h3><p>引用计数法，只有上层模块不使用某资源时，会释放对资源的引用，只有当引用归零时，缓存就会驱逐这个资源。  缓存的是一个页面，计数是对一个页面的计数。</p>
<p>不使用LRU（最近最少使用）缓存策略原因：某一时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷会数据源，这个资源恰好是刚刚被驱逐的资源。上层模块发现缓存中没有了，陷入一个尴尬的境地，是否有必要做回源操作：1.不回源，没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样既不安全。2.回源，如果数据项被驱逐时的数据和现在又是相同的，那这就是无效回源。</p>
<p>问题根源：在LRU策略中，资源驱逐不可控，上层模块无法感知。引用计数法，只有上层模块不使用某资源时，会释放对资源的引用，只有当引用归零时，缓存就会驱逐这个资源。同时，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错，类似于JVM的OOM。</p>
<p>实现</p>
<p>在common包下写了 AbstractCache<T>的抽象类，内部有两个抽象方法，留给实现类具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源不在缓存时从数据源获取数据的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当资源被驱逐时写回数据源的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br></pre></td></tr></table></figure>

<p>引用计数嘛，除了普通的缓存功能，还需要另外维护一个计数。除此以外，为了应对多线程场景，还需要记录哪些资源正在从数据源获取中（从数据源获取资源是一个相对费时的操作）。于是有下面三个 Map：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 元素的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 某线程正在从数据源获取的资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxResource;                            <span class="comment">// 缓存的最大缓存资源数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;                              <span class="comment">// 缓存中元素的个数</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过get()方法获取资源，</span><br><span class="line">// 首先进入一个死循环，来无限尝试从缓存中获取。首先判断这个时候是否有其他线程从数据源获取这个资源，如果有过一会再来看看，</span><br><span class="line">//  如果缓存中有这个资源，将这个资源的引用个数加一，直接返回这个资源，</span><br><span class="line">// 如果缓存中没有，判断缓存是否满了，没满的话在getting中注册一下，表示该线程准备从数据源获取这个资源，</span><br><span class="line">// 调用抽象方法getForCache从数据源获取，得到资源存入缓存，在getting中删除key，该资源的引用计数置为1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(getting.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 请求的资源正在被其他线程获取</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 资源在缓存中，直接返回</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">                references.put(key, references.get(key) + <span class="number">1</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获取该资源</span></span><br><span class="line">            <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">throw</span> Error.CacheFullException;</span><br><span class="line">            &#125;</span><br><span class="line">            count ++;</span><br><span class="line">            getting.put(key, <span class="literal">true</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = getForCache(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            count --;</span><br><span class="line">            getting.remove(key);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        getting.remove(key);</span><br><span class="line">        cache.put(key, obj);</span><br><span class="line">        references.put(key, <span class="number">1</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>释放资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强行释放一个缓存</span></span><br><span class="line"><span class="comment"> * 判断该资源引用是否为0，为0的话删除缓存中的所有相关记录，并且将数据回源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ref == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            releaseForCache(obj); <span class="comment">//继承的子类去详细完善释放一个页面</span></span><br><span class="line">            references.remove(key);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">            count --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            references.put(key, ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关闭缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭缓存，写回所有资源，将缓存中所有资源强行回源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;Long&gt; keys = cache.keySet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> key : keys) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            releaseForCache(obj);</span><br><span class="line">            references.remove(key);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h3><p>DM模块将文件系统抽象成页面，每次对文件系统的读写都是以页面为单位的。同样，从文件系统读进来的数据也是以页面为单位缓存的。</p>
<p>设计一页数据的大小为2^13个字节，8KB，从db文件中根据页号读入一页数据，由页号可以定位到在db文件中的位置，页号从1开始的，i页在db中的起始位置是 (i - 1) * 2 ^ 13</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220530205904952.png" alt="image-20220530205904952"></p>
<p><strong>1.页面的定义</strong></p>
<p>首先看一下一个页面的定义，属性有页号、页内包含的字节数据、是否有脏数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageImpl</span> <span class="keyword">implements</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber; <span class="comment">//页号，从1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;    <span class="comment">//这个页包含的字节数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;  <span class="comment">//这个页面是否是脏页面，在缓存驱逐的时候脏页面需要被写回到磁盘</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> PageCache pc;   <span class="comment">//方便拿到page的引用时可以快速地对这个页面的缓存进行释放操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageImpl</span><span class="params">(<span class="type">int</span> pageNumber, <span class="type">byte</span>[] data, PageCache pc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageNumber = pageNumber;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.pc = pc;</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>



<p><strong>2.缓存页面</strong></p>
<p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>;</span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>页面缓存使用的是引用计数缓存，所以要继承AbstractCache<Page>类</p>
<p>缓存页面的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageCacheImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractCache</span>&lt;Page&gt; <span class="keyword">implements</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> AtomicInteger pageNumbers;  <span class="comment">//记录当前打开的数据文件有多少页，这个数字在数据库文件被打开时就会计算，并在新建页面时自增</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承于AbstractCache，需要实现 getForCache() 和 releaseForCache() 两个抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page,放到Page的data属性中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)key;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以页号计算在数据文件中的位置，页号从1开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pageOffset</span><span class="params">(<span class="type">int</span> pgno)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pgno-<span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>releaseForCache() ：驱逐一个页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 驱逐一个页面，根据是否是脏页面来判断是否需要写回到数据文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pg.isDirty()) &#123;</span><br><span class="line">            flush(pg);</span><br><span class="line">            pg.setDirty(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放一个页面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span> &#123;</span><br><span class="line">        release((<span class="type">long</span>)page.getPageNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数据文件写入一个页面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">        flush(pg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将pg页面的数据写回到数据文件，以 (页号 - 1) * page_size 得到在数据文件中存放的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber();</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">        fileLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData());</span><br><span class="line">            fc.position(offset);</span><br><span class="line">            fc.write(buf);</span><br><span class="line">            fc.force(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fileLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>新建一页时，需要立即写回数据文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一页，页数加一，并被立刻写回数据文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();   <span class="comment">//页数加一</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);</span><br><span class="line">    flush(pg);  <span class="comment">//新建的页面需要立刻被写回数据文件</span></span><br><span class="line">    <span class="keyword">return</span> pgno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h3><p>在Page类中有byte[] data 的属性，里面存的是一页的数据，至于里面有什么数据是不清楚的。这时候需要有一个类来管理页面的数据。</p>
<p>第一页的数据 PageOne</p>
<p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是用来做启动检查。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。 </p>
<p>这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>启动时设置初始字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动时设置初始字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭时拷贝字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭时拷贝字节</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">       pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">       setVcClose(pg.getData());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">       System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>校检字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校检字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="number">2</span>*LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>普通的页面 PageX</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FreeSpaceOffset] [Data]</span><br><span class="line">FreeSpaceOffset: 2字节无符号数据  表示这一页空闲位置的偏移</span><br></pre></td></tr></table></figure>

<p>MYDB 对于普通数据页的管理就比较简单了。一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移，FreeSpaceOffset。剩下的部分都是实际存储的数据。</p>
<p>其实Data是由一条条的dataitem组成</p>
<p>向页面插入数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 更新FSO</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">       System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取pg的FSO</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getFSO(pg.getData());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把byte数组转为short类型数据</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将raw插入pg中，返回插入位置</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">       pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">       <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">       System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">       setFSO(pg.getData(), (<span class="type">short</span>)(offset + raw.length));</span><br><span class="line">       <span class="keyword">return</span> offset;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>)getFSO(pg.getData());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>剩余两个函数 recoverInsert() 和 recoverUpdate() 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line"> </span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    <span class="keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;</span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>)(offset+raw.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h3><p>DM层每次对数据底层操作时，都会记录一条记录日志到磁盘上，当数据库崩溃时，再次启动时，可以根据日志的内容进行恢复数据文件，保证其一致性。</p>
<h4 id="日志的读写"><a href="#日志的读写" class="headerlink" title="日志的读写"></a>日志的读写</h4><p>日志的二进制文件的格式：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206161000997.png" alt="image-20220616100001890"></p>
<p>Xchecksum是一个四字节的整数，是对后续所有日志的校验和。Log1~LogN是常规的日志记录。BadTail是在数据库崩溃时没来记得写完的日志记录，这个BadTail不一定存在。</p>
<p>每一条日志的格式如下：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206161002638.png" alt="image-20220616100229584"></p>
<p>Size是一个四字节的整数，标志着Data字段的字节长度。Checksum也是一个四字节的整数，是该条日志的校验和，是对Data的校验。</p>
<p>其中每一条日志中data的内容组成：[LogType] [XID] [Pgno] [Offset] [Raw]，在日志恢复中会用到</p>
<p>校验和：通过一个指定的种子实现：seed &#x3D; 13331</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单条日志的校验和为：calChecksum(0, data)，总的校验和为: calChecksum(xCheck, log)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calChecksum</span><span class="params">(<span class="type">int</span> xCheck, <span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> b : log) &#123;</span><br><span class="line">        xCheck = xCheck * SEED + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xCheck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Logger 被实现成迭代器模式，通过 next() 方法，不断地从文件中读取下一条日志，并将其中的 Data 解析出来并返回。next() 方法的实现主要依靠 internNext()，大致如下，其中 position 是当前日志文件读到的位置偏移：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取一条日志，包括size(4个字节)，checksum(4个字节)，data</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] internNext() &#123;</span><br><span class="line">    <span class="keyword">if</span>(position + OF_DATA &gt;= fileSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取size</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">tmp</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(position);</span><br><span class="line">        fc.read(tmp);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Parser.parseInt(tmp.array());</span><br><span class="line">    <span class="keyword">if</span>(position + size + OF_DATA &gt; fileSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取checksum和data</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(OF_DATA + size);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(position);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] log = buf.array();</span><br><span class="line">    <span class="comment">// 校验checksum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum1</span> <span class="operator">=</span> calChecksum(<span class="number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));</span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum2</span> <span class="operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));</span><br><span class="line">    <span class="keyword">if</span>(checkSum1 != checkSum2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    position += log.length;</span><br><span class="line">    <span class="keyword">return</span> log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] next() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] log = internNext();</span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在打开一个日志文件时，初始化，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        size = file.length();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(size &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        Panic.panic(Error.BadLogFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从日志文件中读入 xChecksum</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">raw</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        fc.read(raw);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xChecksum</span> <span class="operator">=</span> Parser.parseInt(raw.array());</span><br><span class="line">    <span class="built_in">this</span>.fileSize = size;</span><br><span class="line">    <span class="built_in">this</span>.xChecksum = xChecksum;</span><br><span class="line"></span><br><span class="line">    checkAndRemoveTail();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查并移除bad tail</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAndRemoveTail</span><span class="params">()</span> &#123;</span><br><span class="line">    rewind();  <span class="comment">// position = 4</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">xCheck</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">byte</span>[] log = internNext();</span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        xCheck = calChecksum(xCheck, log);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(xCheck != xChecksum) &#123;</span><br><span class="line">        Panic.panic(Error.BadLogFileException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        truncate(position); <span class="comment">//截取完整的log</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.seek(position);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    rewind();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取指定长度的文件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">truncate</span><span class="params">(<span class="type">long</span> x)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.truncate(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>向日志文件中插入一条日志，首先将数据包装成一条日志的格式，size，checksum，data，写入文件后，在更新Xchecksum，更新完成后强制刷出到磁盘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向日志文件中写入一条日志</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] log = wrapLog(data);  <span class="comment">// 将data转成日志格式</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(log);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    updateXChecksum(log); <span class="comment">// 写入一条日志后，更新总的校验和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新Xchecksum</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXChecksum</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.xChecksum = calChecksum(<span class="built_in">this</span>.xChecksum, log);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将data 字节数组转成日志格式 size，checksum，data</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] wrapLog(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="number">0</span>, data));</span><br><span class="line">    <span class="type">byte</span>[] size = Parser.int2Byte(data.length);</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(size, checksum, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="日志恢复"><a href="#日志恢复" class="headerlink" title="日志恢复"></a>日志恢复</h4><p>日志策略：</p>
<p>在进行 Insert和 Update 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。至于delete，涉及到VM层，以后了解</p>
<p>这个日志策略使得DM层对于数据操作的磁盘同步可以更加随意，日志在数据操作之前已经到达磁盘，即使后来的数据操作没来记得写入磁盘，数据库发生崩溃，也可以通过磁盘上的日志恢复数据操作。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206161508397.png" alt="image-20220616150832324"></p>
<p>对于单线程的情况比较简单</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206161509141.png" alt="image-20220616150951027"></p>
<p>对于多线程</p>
<p>有两条规定：1. 正在进行的事务，不会读取其他未提交事务的产生的数据</p>
<p>​						2. 正在进行的事务，不会修改其他未提交事务修改或产生的数据</p>
<p>这两条规定在VM层可以控制</p>
<p>恢复的策略：1. 重做所有已完成（committed和aborted）的事务</p>
<p>​						2. 撤销所有崩溃时未完成的（active）的事务</p>
<p>在log日志文件中的格式：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206161519130.png" alt="image-20220616151928052"></p>
<p>insert日志的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[LogType] [XID] [Pgno] [Offset] [Raw]</span><br></pre></td></tr></table></figure>

<p>其中 LogType 1个字节  表示insert还是update</p>
<p>​        Xid            8个字节  表示事务的id</p>
<p>​		Pgno        4个字节   表示页号</p>
<p>​		Offset      2个字节   表示当前记录在一页中的偏移量</p>
<p>​		raw                           表示insert的数据</p>
<p>update日志的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br></pre></td></tr></table></figure>

<p>其中 LogType 1个字节  表示insert还是update</p>
<p>​        Xid            8个字节  表示事务的id</p>
<p>​		UID           8个字节    一共64位，高32位表示pgno，低16位表示offset</p>
<p>​		OldRaw                    表示原先的数据，字节长度与Newraw相同</p>
<p>​		Newraw                    表示新的数据</p>
<p>对于重做或是撤销记录都是使用pagecache的，将记录写入pagecache中，由pagecache写入磁盘。</p>
<h3 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h3><p><strong>页面索引，缓存了每一页的空闲空间。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而无需从磁盘或者缓存中检查每一个页面的信息。</strong> </p>
<p>MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 40 个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，将页面按剩余空间划分为 40 类。insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.cobweb.mydb.backend.dm.pageIndex;</span><br><span class="line"><span class="comment">// 页面索引：将每个页面划分成40个区间，用list数组将每个页面按剩余区间数分类，并存下剩余不同区间数下的页号构成list</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageIndex</span> &#123;</span><br><span class="line">    <span class="comment">// 将一页划成40个区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERVALS_NO</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    <span class="comment">// 每个区间的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;PageInfo&gt;[] lists;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        lists = <span class="keyword">new</span> <span class="title class_">List</span>[INTERVALS_NO+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; INTERVALS_NO+<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            lists[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数：页号，页面空闲空间的大小</span></span><br><span class="line">    <span class="comment">// 给定页号和页面空闲空间的大小，将这个页面的页号和剩余空间加入到区间的分类中，注意没有存储页面的数据，只是记录页号和剩余空间，方便以后查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> pgno, <span class="type">int</span> freeSpace)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> freeSpace / THRESHOLD;</span><br><span class="line">            lists[number].add(<span class="keyword">new</span> <span class="title class_">PageInfo</span>(pgno, freeSpace));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有页面中选择一个剩余空间为spaceSize的页面，spaceSize占几个区间，在这个区间中找到第一个页面返回，并在list中删除</span></span><br><span class="line">    <span class="keyword">public</span> PageInfo <span class="title function_">select</span><span class="params">(<span class="type">int</span> spaceSize)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> spaceSize / THRESHOLD;</span><br><span class="line">            <span class="keyword">if</span>(number &lt; INTERVALS_NO) number ++;</span><br><span class="line">            <span class="keyword">while</span>(number &lt;= INTERVALS_NO) &#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[number].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    number ++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> lists[number].remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 DataManager 被创建时，需要获取所有页面并填充 PageIndex：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化pageIndex</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fillPageIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageNumber</span> <span class="operator">=</span> pc.getPageNumber();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= pageNumber; i ++) &#123;</span><br><span class="line">            <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pg = pc.getPage(i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Panic.panic(e);</span><br><span class="line">            &#125;</span><br><span class="line">            pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));</span><br><span class="line">            pg.release();  <span class="comment">// 遍历时，将一页的页号和剩余空间分类存储后，一定要释放当前页，不然可能会撑爆内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h3><p>DataItem 是 DM 层向上层提供的数据抽象。上层模块通过地址，向 DM 请求到对应的 DataItem，再获取到其中的数据。</p>
<p>DateItem中保存的数据如下：</p>
<p>[ValidFlag] [DataSize] [Data]</p>
<p>其中 ValidFlag 占用 1 字节，标识了该 DataItem 是否有效。删除一个 DataItem，只需要简单地将其有效位设置为 0。DataSize 占用 2 字节，标识了后面 Data 的长度。</p>
<p>一个个DataItem组成了一页数据，也就是Page类中的data对象。也就是PageX对象的组成。</p>
<p>uid是由页号和页内偏移组成的唯一标志，代表唯一的一个dataitem。  uid是一个long型，64位，高32位是页号，低16位是offset偏移。</p>
<p>interface DataItem</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从页面的offset处解析处dataitem, offset处，数据结构为[ValidFlag] [DataSize] [Data]....(dateitems)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataItem <span class="title function_">parseDataItem</span><span class="params">(Page pg, <span class="type">short</span> offset, DataManagerImpl dm)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = pg.getData();</span><br><span class="line">    <span class="type">short</span> <span class="variable">size</span> <span class="operator">=</span> Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA));</span><br><span class="line">    <span class="type">short</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">short</span>)(size + DataItemImpl.OF_DATA);</span><br><span class="line">    <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> Types.addressToUid(pg.getPageNumber(), offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataItemImpl</span>(<span class="keyword">new</span> <span class="title class_">SubArray</span>(raw, offset, offset+length), <span class="keyword">new</span> <span class="title class_">byte</span>[length], pg, uid, dm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上层模块在获取到 DataItem 后，可以通过 data() 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 SubArray。</p>
<p>在上层模块试图对 DataItem 进行修改时，需要遵循一定的流程：在修改之前需要调用 before() 方法，想要撤销修改时，调用 unBefore() 方法，在修改完成后，调用 after() 方法。整个流程，主要是为了保存前相数据，并及时回落日志。DM 会保证对 DataItem 的修改是原子性的。</p>
<p> DataItemImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    wLock.lock();</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="number">0</span>, oldRaw.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unBefore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.arraycopy(oldRaw, <span class="number">0</span>, raw.raw, raw.start, oldRaw.length);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dm.logDataItem(xid, <span class="built_in">this</span>);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>after 的方法 主要调用dm的方法，实现对数据的操作以及日志的回落。</p>
<h3 id="DM-的实现"><a href="#DM-的实现" class="headerlink" title="DM 的实现"></a>DM 的实现</h3><p>DataManager 是DM层直接对外提供方法的类，同时，也实现了DataItem对象的缓存，缓存的key是dataitem的uid，可以唯一的标志一个dataitem。因此DataManagerImpl 同PagecacheImpl 一样 继承于 AbstractCache ，实现getForCache和releaseForCache 方法。</p>
<p>getForCache方法</p>
<p>在DataItem节中uid可以标志唯一的dataitem，可以由uid获取dataitem，uid 是64位，高32位是页号，低16位是页内偏移，从dataitem缓存中得不到时，需要通过页内缓存中获取dataitem。</p>
<p>releaseForCache方法</p>
<p>使用page的release方法，page的release方法调用了PageCache的release方法，接着调用了AbstractCache的release方法，AbstractCache会用到PageCache的releaseForCache。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DataItem <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">short</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>));</span><br><span class="line">    uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> pc.getPage(pgno);</span><br><span class="line">    <span class="keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dataitem 缓存释放</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(DataItem di)</span> &#123;</span><br><span class="line">    di.page().release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>从已有文件创建 DataManager 和从空文件创建 DataManager 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验，来判断是否需要执行恢复流程。并生成页面索引，还有重新对第一页生成随机字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 从空文件中创建DataManager，创建页面缓存、日志、初始化页面缓存中的第一页</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">create</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.create(path, mem);   <span class="comment">// 创建页面缓存</span></span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.create(path);    <span class="comment">// 创建日志</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    dm.initPageOne();   <span class="comment">// 对页面缓存中第一页初始化</span></span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从已有文件中创建DataManage，打开页面页面缓存、日志，检验第一页</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">open</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.open(path, mem);</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.open(path);</span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    <span class="keyword">if</span>(!dm.loadCheckPageOne()) &#123;</span><br><span class="line">        Recover.recover(tm, lg, pc);  <span class="comment">// 第一页校验失败，数据恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">    dm.fillPageIndex();   <span class="comment">//初始化pageIndex</span></span><br><span class="line">    PageOne.setVcOpen(dm.pageOne); <span class="comment">// 重新对第一页生成随机字节，用于验证是否正常关闭</span></span><br><span class="line">    dm.pc.flushPage(dm.pageOne); <span class="comment">// 将第一页刷回磁盘</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，初始化第一页和校验第一页，都是调用PageOne类的方法实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在创建文件时初始化PageOne</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initPageOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pc.newPage(PageOne.InitRaw());</span><br><span class="line">        <span class="type">assert</span> <span class="variable">pgno</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pageOne = pc.getPage(pgno);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        pc.flushPage(pageOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在打开已有文件时时读入PageOne，并验证正确性</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">loadCheckPageOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pageOne = pc.getPage(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PageOne.checkVc(pageOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化pageIndex, 跳过第一页，第一页是用于校验</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fillPageIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageNumber</span> <span class="operator">=</span> pc.getPageNumber();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= pageNumber; i ++) &#123;</span><br><span class="line">            <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pg = pc.getPage(i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Panic.panic(e);</span><br><span class="line">            &#125;</span><br><span class="line">            pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));</span><br><span class="line">            pg.release();  <span class="comment">// 遍历时，将一页的页号和剩余空间分类存储后，一定要释放当前页，不然可能会撑爆内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>DM 层提供了三个功能供上层使用，分别是读、插入和修改。修改是通过读出的 DataItem 实现的，于是 DataManager 只需要提供 read() 和 insert() 方法。 read() 根据 UID 从缓存中获取 DataItem，并校验有效位：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DataItem <span class="title function_">read</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DataItemImpl</span> <span class="variable">di</span> <span class="operator">=</span> (DataItemImpl)<span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">if</span>(!di.isValid()) &#123;</span><br><span class="line">        di.release();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> di;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>insert() 方法，在 pageIndex 中获取一个足以存储插入内容的页面的页号，获取页面后，首先需要写入插入日志，接着才可以通过 pageX 插入数据，并返回插入位置的偏移。最后需要将页面信息重新插入 pageIndex。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务xid插入一条dataitem，返回插入之后dataitem的uid</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);  <span class="comment">// 将数据整合成一条dataitem  ，invalid, size, data</span></span><br><span class="line">        <span class="keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.DataTooLargeException;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取可用页</span></span><br><span class="line">        <span class="type">PageInfo</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            pi = pIndex.select(raw.length);</span><br><span class="line">            <span class="keyword">if</span> (pi != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newPgno</span> <span class="operator">=</span> pc.newPage(PageX.initRaw());  <span class="comment">// 新建一个页面，写回磁盘</span></span><br><span class="line">                pIndex.add(newPgno, PageX.MAX_FREE_SPACE);   <span class="comment">// 将新建的页面加入到页面索引中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pi == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.DatabaseBusyException;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freeSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pg = pc.getPage(pi.pgno);</span><br><span class="line">            <span class="type">byte</span>[] log = Recover.insertLog(xid, pg, raw); <span class="comment">// 将数据整合成一条insertlog</span></span><br><span class="line">            logger.log(log);  <span class="comment">// 插入到日志中</span></span><br><span class="line"></span><br><span class="line">            <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> PageX.insert(pg, raw);</span><br><span class="line"></span><br><span class="line">            pg.release();</span><br><span class="line">            <span class="keyword">return</span> Types.addressToUid(pi.pgno, offset);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 将取出的pg重新插入pIndex</span></span><br><span class="line">            <span class="keyword">if</span>(pg != <span class="literal">null</span>) &#123;</span><br><span class="line">                pIndex.add(pi.pgno, PageX.getFreeSpace(pg));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pIndex.add(pi.pgno, freeSpace);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>DataManager 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置第一页的字节校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.close();</span><br><span class="line">    logger.close();</span><br><span class="line"> </span><br><span class="line">    PageOne.setVcClose(pageOne);</span><br><span class="line">    pageOne.release();</span><br><span class="line">    pc.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="总结DM"><a href="#总结DM" class="headerlink" title="总结DM"></a>总结DM</h3><p>1、AbstractCache：引用计数法的缓存框架，留了两个从数据源获取数据和释放缓存的抽象方法给具体实现类去实现。 </p>
<p>2、PageImpl：数据页的数据结构，包含页号、是否脏数据页、数据内容、所在的PageCache缓存。 </p>
<p>3、PageOne：校验页面，用于启动DM的时候进行文件校验。 </p>
<p>4、PageX：每个数据页的管理器。initRaw()新建一个数据页并设置FSO值，FSO后面存的其实就是一个个DataItem数据包 </p>
<p>5、PageCacheImpl：数据页的缓存具体实现类，除了重写获取 和释放两个方法外，还完成了所有数据页的统一管理：   </p>
<p>​	 1）获取数据库中的数据页总数；getPageNumber()   </p>
<p>​	 2）新建一个数据页并写入数据库文件；newPage(byte[] initData)   </p>
<p>​	 3）从缓存中获取指定的数据页；getPage(int pgno)    </p>
<p>​	4）删除指定位置后面的数据页；truncateByBgno(int maxPgno) </p>
<p>6、PageIndex：方便DataItem的快速定位插入，其实现原理可以理解为HashMap那种数组+链表结构（实际实现是 List+ArrayList），先是一个大小为41的数组 存的是区间号（区间号从1&gt;开始），然后每个区间号数组后面跟一个数组存满足空闲大小的所有数据页信息（PageInfo）。</p>
<p> 7、Recover：日志恢复策略，主要维护两个日志：updateLog和insertLog，重做所有已完成事务 redo，撤销所有未完成事务undo</p>
<p> 8、DataManager：统揽全局的类，主要方法也就是读写和修改，全部通过DataItem进行。</p>
<p>首先从DataManager进去创建DM（打开DM就不谈了，只是多了个检验PageOne 和更新PageIndex），需要执行的操作是： </p>
<p>1）新建PageCache，DM里面有 页面缓存 和 DataItem缓存 两个实现；DataItem缓存也是在PageCache中获取的，DataItem缓存不存在的时候就去PageCache缓存获取，PageCache缓存没有才去数据库文件中获取； </p>
<p>2）新建日志，</p>
<p>3）构建DM管理器； </p>
<p>4）初始化校验页面1：    initPageOne() 和 启动时候进行校验：loadCheckPageOne()   </p>
<ol start="5">
<li>DM层对上层提供的方法，也就是read, insert, update,</li>
</ol>
<ol>
<li>读取数据 read(long uid)：    从DataItem缓存中读取一个DataItem数据包并进行并判断是否有效invalid，如果DataItem缓存中没有就会调用 DataManager下的getForCache(long uid)从PageCache缓存中读取DataItem数据包并加入DataItem缓存（其实PageCache缓存和DataItem缓存都是共用的一个cache Map存的，只是key不一样，page的key是页号，DataItem的key是uid，页号+偏移量），如果PgeCache也没有就去数据库文件读取。   </li>
<li>插入数据 insert(long xid, byte[] data)：    先把数据打包成DataItem格式，然后在 pageIndex 中获取一个足以存储插入内容的页面的页号； 获取页面后，需要先写入插入日志，需要先将数据整合成插入日志的格式Recover.insertLog(xid, pg, raw)，才插入到日志中Log.log(log)，接着才可以通过 pageX 在目标数据页插入数据PageX.insert(pg, raw)，并返回插入位置的偏移。如果在pageIndex中没有空闲空间足够插入数据了，就需要新建一个数据页pc.newPage(PageX.initRaw())。最后需要将页面信息重新插入 pageIndex。 </li>
<li>修改数据就是先读取数据，然后修改DataItem内容，再插入DataItem数据。但是在修改数据操作的前后需要调用DataItemImp.after()进行解写锁并记录更新日志，这里需要依赖DataManager里面的logDataItem(long xid, DataItem di)方法；</li>
</ol>
<ol start="6">
<li>释放缓存： 释放DataItem的缓存，实质上就是释放DataItem所在页的PageCache缓存</li>
</ol>
<h2 id="版本管理-VM"><a href="#版本管理-VM" class="headerlink" title="版本管理 VM"></a>版本管理 VM</h2><p>VM基于两段锁协议实现了事务的可串行化调度，并且实现了MVCC 以消除读写阻塞，同时实现了两个隔离级别，读已提交、可重复读</p>
<p>两段锁协议：所有事务必须分两个阶段对数据项加锁和解锁</p>
<ul>
<li>在对任何数据读、写操作之前，必须申请并获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他的封锁</li>
</ul>
<p>遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件</p>
<p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p>
<p>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。 MYDB 通过 MVCC，降低了事务的阻塞概率。</p>
<p>譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p>
<h3 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h3><p>对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。 一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM向上层抽象出entry</span></span><br><span class="line"><span class="comment"> * dataitem中的结构：</span></span><br><span class="line"><span class="comment"> * [ValidFlag] [DataSize] [Data]</span></span><br><span class="line"><span class="comment"> * 而entry就是dataitem中的data，一条entry对应一条dataitem</span></span><br><span class="line"><span class="comment"> * entry结构：</span></span><br><span class="line"><span class="comment"> * [XMIN] [XMAX] [data]</span></span><br><span class="line"><span class="comment"> * XMIN：创建该记录的事务编号(版本号)，8个字节</span></span><br><span class="line"><span class="comment"> * XMAX：删除该记录的事务编号，8个字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMIN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMAX</span> <span class="operator">=</span> OF_XMIN+<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_XMAX+<span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> DataItem dataItem;</span><br><span class="line">    <span class="keyword">private</span> VersionManager vm;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">loadEntry</span><span class="params">(VersionManager vm, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DataItem</span> <span class="variable">di</span> <span class="operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);</span><br><span class="line">        <span class="keyword">return</span> newEntry(vm, di, uid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        dataItem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们规定，一条 Entry 中存储的数据格式如下：</p>
<p>[XMIN] [XMAX] [data]</p>
<p>dataitem中的结构：</p>
<p>[ValidFlag] [DataSize] [Data]</p>
<p>而entry就是dataitem中的data，一条entry对应一条dataitem</p>
<p>MIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。它们的作用将在下一节中说明。DATA 就是这条记录持有的数据。根据这个结构，在创建记录时调用的 wrapEntryRaw() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapEntryRaw(<span class="type">long</span> xid, <span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] xmin = Parser.long2Byte(xid);</span><br><span class="line">    <span class="type">byte</span>[] xmax = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(xmin, xmax, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样，如果要获取记录中持有的数据，也就需要按照这个结构来解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以拷贝的形式返回entry中data内容，从dataitem中获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] data() &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();  <span class="comment">// SubArray: [raw : dataitem, start: 3, end: dataitem.length]，也就是说sa中存的是dataitem的data部分</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[sa.end - sa.start - OF_DATA];</span><br><span class="line">        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="number">0</span>, data.length); <span class="comment">// 将dataitem的内容start + 16位置开始拷贝到data中</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 DataItem 执行 before() 方法，这个在设置 XMAX 的值中体现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改entry，也就是修改dataitem，先调用dataitem的before方法，保存原先的数据，再修改，最后调用after生成日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXmax</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dataItem.before();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        System.arraycopy(Parser.long2Byte(xid), <span class="number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.after(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>MyDB实现了两种隔离级别：读已提交、可重复读</p>
<p>读已提交</p>
<p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 XMIN 和 XMAX： </p>
<p>XMIN：创建该版本的事务编号 </p>
<p>XMAX：删除该版本的事务编号</p>
<p> XMIN 应当在版本创建时填写，而 XMAX 则在版本被删除，或者有新版本出现时填写。 XMAX 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XMAX，这样，这个版本对每一个 XMAX 之后的事务都是不可见的，也就等价于删除了。 如此，在读提交下，版本对事务的可见性逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(XMIN == Ti and                             <span class="comment">// 由Ti创建且</span></span><br><span class="line">    XMAX == NULL                            <span class="comment">// 还未被删除</span></span><br><span class="line">)</span><br><span class="line">or                                          <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and                       <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line">    (XMAX == NULL or                        <span class="comment">// 尚未删除或</span></span><br><span class="line">    (XMAX != Ti and XMAX is not commited)   <span class="comment">// 由一个未提交的事务删除</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<p>以下方法判断某个记录对事务 t 是否可见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读已提交的级别下，判断某个记录对事务t是否可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">readCommitted</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可重复读</p>
<p>规定：事务只能读取它开始时, 就已经结束的那些事务产生的数据版本</p>
<p>这条规定，增加于，事务需要忽略： </p>
<ul>
<li>在本事务后开始的事务的数据; </li>
<li>本事务开始时还是 active 状态的事务的数据</li>
</ul>
<p>对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。 于是，可重复读的判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(XMIN == Ti and                 <span class="comment">// 由Ti创建且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除</span></span><br><span class="line">))</span><br><span class="line">or                              <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and           <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line"> XMIN &lt; XID and                 <span class="comment">// 这个事务小于Ti且</span></span><br><span class="line"> XMIN is not in <span class="title function_">SP</span><span class="params">(Ti)</span> and      <span class="comment">// 这个事务在Ti开始前提交且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除或</span></span><br><span class="line">  (XMAX != Ti and               <span class="comment">// 由其他事务删除但是</span></span><br><span class="line">   (XMAX is not commited or     <span class="comment">// 这个事务尚未提交或</span></span><br><span class="line">XMAX &gt; Ti or                    <span class="comment">// 这个事务在Ti开始之后才开始或</span></span><br><span class="line">XMAX is in <span class="title function_">SP</span><span class="params">(Ti)</span>               <span class="comment">// 这个事务在Ti开始前还未提交</span></span><br><span class="line">))))</span><br></pre></td></tr></table></figure>



<p>抽象一个事务，记录当前事务开始时处于活跃的事务，类似于InnoDB中readView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vm对一个事务的抽象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> xid;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> level;   <span class="comment">// 隔离级别：0为读已提交，1为可重复读</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;   <span class="comment">// 当前事务开始时，尚在活跃的事务</span></span><br><span class="line">    <span class="keyword">public</span> Exception err;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> autoAborted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数中的 active，保存着当前所有 active 的事务。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">newTransaction</span><span class="params">(<span class="type">long</span> xid, <span class="type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">        t.xid = xid;</span><br><span class="line">        t.level = level;</span><br><span class="line">        <span class="keyword">if</span>(level != <span class="number">0</span>) &#123;</span><br><span class="line">            t.snapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Long x : active.keySet()) &#123;</span><br><span class="line">                t.snapshot.put(x, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断当前事务开始时，xid事务是否处于活跃中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInSnapshot</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> snapshot.containsKey(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以下方法判断 可重复读级别下，一个版本的事务是否可见</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可重复读的级别下，判断某个记录对事务t是否可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatableRead</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">        <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">        <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123; <span class="comment">// 创建这条记录的事务已提交 &amp;&amp; 这个事务小于xid &amp;&amp; 这个事务在xid开始之前提交</span></span><br><span class="line">            <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// 没有删除，返回可见</span></span><br><span class="line">            <span class="keyword">if</span>(xmax != xid) &#123;   <span class="comment">// 不是由xid删除时，要确保xid在删除提交前能可见</span></span><br><span class="line">                <span class="keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;  <span class="comment">//  这个删除的事务尚未提交 or 这个事务在xid之后开始 or  这个事务在xid之前还没提交</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在InnoDB中判断哪个版本对当前事物是否可见</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206211655260.png" alt="image-20220621165530156"></p>
<h3 id="版本跳跃"><a href="#版本跳跃" class="headerlink" title="版本跳跃"></a>版本跳跃</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line"><span class="title function_">R1</span><span class="params">(X)</span> <span class="comment">// T1读取x0</span></span><br><span class="line">R2(X) <span class="comment">// T2读取x0</span></span><br><span class="line">U1(X) <span class="comment">// T1将X更新到x1</span></span><br><span class="line">T1 commit</span><br><span class="line"><span class="title function_">U2</span><span class="params">(X)</span> <span class="comment">// T2将X更新到x2</span></span><br><span class="line">T2 commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。</p>
<p> 读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。</p>
<p>解决版本跳跃的思路也很简单：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚。 上一节中就总结了，Ti 不可见的 Tj，有两种情况：</p>
<ol>
<li>XID(Tj) &gt; XID(Ti)</li>
<li>Tj in SP(Ti)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否版本跳跃</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVersionSkip</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(t.level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid || t.isInSnapshot(xmax));   <span class="comment">// xmax提交并且xmax对事务t是不可见的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。 MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="comment">// 某个XID已经获得的资源的UID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="comment">// UID被某个XID持有</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="comment">// 正在等待UID的XID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="comment">// 正在等待资源的XID的锁</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="comment">// XID正在等待的UID</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要等待则返回null，否则返回锁对象</span></span><br><span class="line"><span class="comment">// 会造成死锁则抛出异常</span></span><br><span class="line"><span class="keyword">public</span> Lock <span class="title function_">add</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isInList(x2u, xid, uid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!u2x.containsKey(uid)) &#123;</span><br><span class="line">            u2x.put(uid, xid);</span><br><span class="line">            putIntoList(x2u, xid, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.put(xid, uid);</span><br><span class="line">        putIntoList(wait, xid, uid);</span><br><span class="line">        <span class="keyword">if</span>(hasDeadLock()) &#123;</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            removeFromList(wait, uid, xid);</span><br><span class="line">            <span class="keyword">throw</span> Error.DeadlockException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        l.lock();</span><br><span class="line">        waitLock.put(xid, l);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>查找图中是否有环的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。 实现很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Long, Integer&gt; xidStamp;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> stamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否有死锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    xidStamp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stamp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> xid : x2u.keySet()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">null</span> &amp;&amp; s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stamp ++;</span><br><span class="line">        <span class="keyword">if</span>(dfs(xid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp == stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp &lt; stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xidStamp.put(xid, stamp);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(uid == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid);</span><br><span class="line">    <span class="keyword">assert</span> x != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p>
<p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取</p>
<p>从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当一个事务提交或是撤销后，释放它所持有的锁，并将它从等待图中删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Long&gt; l = x2u.get(xid); <span class="comment">// xid 占有的资源的列表</span></span><br><span class="line">            <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">                    selectNewXID(uid);  <span class="comment">// 从等待队列中选择一个xid来占用uid</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            x2u.remove(xid);</span><br><span class="line">            waitLock.remove(xid);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从等待队列中选择一个xid来占用uid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selectNewXID</span><span class="params">(<span class="type">long</span> uid)</span> &#123;</span><br><span class="line">        u2x.remove(uid);</span><br><span class="line">        List&lt;Long&gt; l = wait.get(uid);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">assert</span> l.size() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(!waitLock.containsKey(xid)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                u2x.put(uid, xid);</span><br><span class="line">                <span class="type">Lock</span> <span class="variable">lo</span> <span class="operator">=</span> waitLock.remove(xid);</span><br><span class="line">                waitU.remove(xid);</span><br><span class="line">                lo.unlock();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l.size() == <span class="number">0</span>) wait.remove(uid);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h3><p>VM 层通过 VersionManager 接口，向上层提供功能，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VersionManager</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同时，VM 的实现类还被设计为 Entry 的缓存，需要继承 AbstractCache。需要实现的获取到缓存和从缓存释放的方法很简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存，依据dataitem得到entry</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Entry <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> Entry.loadEntry(<span class="built_in">this</span>, uid);</span><br><span class="line">    <span class="keyword">if</span>(entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.NullEntryException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">    entry.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>begin() 开启一个事务，并初始化事务的结构，将其存放在 activeTransaction 中，用于检查和快照使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启一个事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> tm.begin();  <span class="comment">// 在XID文件记录层面创建一个事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);   <span class="comment">// 抽象层面创建一个事务</span></span><br><span class="line">        activeTransaction.put(xid, t);   <span class="comment">// 将事务添加进当前活跃的事务中</span></span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>commit() 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交一个事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NullPointerException n) &#123;</span><br><span class="line">        System.out.println(xid);</span><br><span class="line">        System.out.println(activeTransaction.keySet());</span><br><span class="line">        Panic.panic(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    activeTransaction.remove(xid);   <span class="comment">// 从当前活跃的事务中删除该事务</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    lt.remove(xid); <span class="comment">// 当一个事务提交或是撤销后，释放它所持有的锁，并将它从等待图中删除</span></span><br><span class="line">    tm.commit(xid); <span class="comment">// XID文件层面提交该事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>abort 事务的方法则有两种，手动和自动。手动指的是调用 abort() 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动撤销</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    internAbort(xid, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部自动撤销</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internAbort</span><span class="params">(<span class="type">long</span> xid, <span class="type">boolean</span> autoAborted)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(!autoAborted) &#123;</span><br><span class="line">        activeTransaction.remove(xid);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t.autoAborted) <span class="keyword">return</span>;</span><br><span class="line">    lt.remove(xid);    <span class="comment">// 当一个事务提交或是撤销后，释放它所持有的锁，并将它从等待图中删除</span></span><br><span class="line">    tm.abort(xid);   <span class="comment">// 更新xid文件中事务的状态为abort</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>read()</code> 方法读取一个 entry，注意判断下可见性即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取一个entry，需要注意可见性</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry = <span class="built_in">super</span>.get(uid);  <span class="comment">// 从缓存中读取entry</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e == Error.NullEntryException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;  <span class="comment">// 判断是否可见</span></span><br><span class="line">            <span class="keyword">return</span> entry.data();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>insert() 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一个一条数据，将数据包装成entry，交给DM插入即可</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">       lock.unlock();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> t.err;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);</span><br><span class="line">       <span class="keyword">return</span> dm.insert(xid, raw);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>delete() </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除一条entry ：1.根据uid得到entry，2.判断该事务对entry可见性，3.获取资源的锁：判断是否造成死锁或等待，4.版本跳跃判断</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">       lock.unlock();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> t.err;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           entry = <span class="built_in">super</span>.get(uid);</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           <span class="keyword">if</span>(e == Error.NullEntryException) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;  <span class="comment">// entry对事务t不可见</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               l = lt.add(xid, uid);  <span class="comment">// 添加到锁图中，判断是否造成死锁或是需要等待</span></span><br><span class="line">           &#125; <span class="keyword">catch</span>(Exception e) &#123;   <span class="comment">// 造成死锁</span></span><br><span class="line">               t.err = Error.ConcurrentUpdateException;</span><br><span class="line">               internAbort(xid, <span class="literal">true</span>);  <span class="comment">// 撤销xid事务</span></span><br><span class="line">               t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">throw</span> t.err;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">               l.lock();</span><br><span class="line">               l.unlock();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(entry.getXmax() == xid) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;</span><br><span class="line">               t.err = Error.ConcurrentUpdateException;</span><br><span class="line">               internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">               t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">throw</span> t.err;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           entry.setXmax(xid);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           entry.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h2 id="索引管理-IM"><a href="#索引管理-IM" class="headerlink" title="索引管理 IM"></a>索引管理 IM</h2><p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。</p>
<p>在依赖关系图中，IM直接依赖于DM，没有基于VM。索引的数据被直接插入数据库文件，而不需要经过版本的管理。</p>
<h3 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h3><p>二叉树是由一个个Node组成，每个Node都存储在一条DataItem中，结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[LeafFlag][KeyNumber][SiblingUid]</span><br><span class="line">[Son0][Key0][Son1][Key1]...[SonN][KeyN]</span><br></pre></td></tr></table></figure>

<p>其中 LeafFlag 标记了该节点是否是个叶子节点；KeyNumber 为该节点中 key 的个数；SiblingUid 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（SonN）和 KeyN。最后的一个 KeyN 始终为 MAX_VALUE，以此方便查找。</p>
<p>占用的字节数为：1B、2B、8B、（8B、8B)*n</p>
<p>Node 类持有了其 B+ 树结构的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改数据和释放数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    BPlusTree tree;</span><br><span class="line">    DataItem dataItem;</span><br><span class="line">    SubArray raw;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建根节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个根节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newRootRaw(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> key)  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line"></span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">false</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">2</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, left, <span class="number">0</span>);</span><br><span class="line">    setRawKthKey(raw, key, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, right, <span class="number">1</span>);</span><br><span class="line">    setRawKthKey(raw, Long.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个空的根节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newNilRootRaw()  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line"></span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">true</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">0</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 searchNext 方法和 leafSearchRange 方法。</p>
<p>searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID</span></span><br><span class="line">    <span class="keyword">public</span> SearchNextRes <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">        dataItem.rLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNextRes</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; noKeys; i ++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, i);</span><br><span class="line">                <span class="keyword">if</span>(key &lt; ik) &#123;</span><br><span class="line">                    res.uid = getRawKthSon(raw, i);</span><br><span class="line">                    res.siblingUid = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.uid = <span class="number">0</span>;</span><br><span class="line">            res.siblingUid = getRawSibling(raw);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            dataItem.rUnLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>leafSearchRange 方法在当前节点进行范围查找，范围是 [leftKey, rightKey]，这里约定如果 rightKey 大于等于该节点的最大的 key, 则还同时返回兄弟节点的 UID，方便继续搜索下一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在当前节点进行范围查找</span></span><br><span class="line"><span class="keyword">public</span> LeafSearchRangeRes <span class="title function_">leafSearchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &gt;= leftKey) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            kth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &lt;= rightKey) &#123;</span><br><span class="line">                uids.add(getRawKthSon(raw, kth));</span><br><span class="line">                kth ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">siblingUid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth == noKeys) &#123;</span><br><span class="line">            siblingUid = getRawSibling(raw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafSearchRangeRes</span>();</span><br><span class="line">        res.uids = uids;</span><br><span class="line">        res.siblingUid = siblingUid;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 B+ 树在插入删除时，会动态调整，根节点不是固定节点，于是设置一个 bootDataItem，该 DataItem 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 SUPER_XID。</p>
<p>IM 对上层模块主要提供两种能力：插入索引和搜索节点。向 B+ 树插入节点和搜索节点的算法和实现，不再赘述。</p>
<p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其 XMAX。如果不去删除对应索引的话，当后续再次尝试读取该 Entry 时，是可以通过索引寻找到的，但是由于设置了 XMAX，寻找不到合适的版本而返回一个找不到内容的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">    DataManager dm;</span><br><span class="line">    <span class="type">long</span> bootUid;   <span class="comment">// 存的是根节点uid的uid，将根节点的uid也保存在了dataitem中</span></span><br><span class="line">    DataItem bootDataItem;  <span class="comment">// 存根节点uid 的dataitem</span></span><br><span class="line">    Lock bootLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个空根节点，并将这个根节点存到dataitem中，同时根节点的uid也存到dataitem中，作为B+树的起点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">create</span><span class="params">(DataManager dm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawRoot = Node.newNilRootRaw();   <span class="comment">// 生成一个空的根节点</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">rootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rawRoot);  <span class="comment">// 将根节点插入到dataitem中，返回根节点的uid</span></span><br><span class="line">        <span class="keyword">return</span> dm.insert(TransactionManagerImpl.SUPER_XID, Parser.long2Byte(rootUid));  <span class="comment">//将根节点的UId存到dataitem中，返回存储了根节点uid的uid</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由根节点的 UID 创建一个B+树，算是真正创建一个B+树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BPlusTree <span class="title function_">load</span><span class="params">(<span class="type">long</span> bootUid, DataManager dm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DataItem</span> <span class="variable">bootDataItem</span> <span class="operator">=</span> dm.read(bootUid); <span class="comment">// 由bootUid得到根节点的uid</span></span><br><span class="line">        <span class="keyword">assert</span> bootDataItem != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BPlusTree</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BPlusTree</span>();</span><br><span class="line">        t.bootUid = bootUid;</span><br><span class="line">        t.dm = dm;</span><br><span class="line">        t.bootDataItem = bootDataItem;</span><br><span class="line">        t.bootLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此处看，DataItem中data，前八个字节存的是rootuid</span></span><br><span class="line">    <span class="comment">// 返回这个字段B+树根节点的UID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">rootUid</span><span class="params">()</span> &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootUid</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);</span><br><span class="line">            <span class="type">long</span> <span class="variable">newRootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);</span><br><span class="line">            bootDataItem.before();</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">diRaw</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            System.arraycopy(Parser.long2Byte(newRootUid), <span class="number">0</span>, diRaw.raw, diRaw.start, <span class="number">8</span>);</span><br><span class="line">            bootDataItem.after(TransactionManagerImpl.SUPER_XID);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从nodeUid处递归的开始寻找为key的uid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">searchLeaf</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> node.isLeaf();</span><br><span class="line">        node.release();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isLeaf) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodeUid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> searchNext(nodeUid, key);</span><br><span class="line">            <span class="keyword">return</span> searchLeaf(next, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);</span><br><span class="line">            <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> node.searchNext(key);</span><br><span class="line">            node.release();</span><br><span class="line">            <span class="keyword">if</span>(res.uid != <span class="number">0</span>) <span class="keyword">return</span> res.uid;</span><br><span class="line">            nodeUid = res.siblingUid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">search</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRange(key, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tbm会调用这个函数搜索 在where语句中</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">searchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rootUid</span> <span class="operator">=</span> rootUid();</span><br><span class="line">        <span class="type">long</span> <span class="variable">leafUid</span> <span class="operator">=</span> searchLeaf(rootUid, leftKey);</span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">leaf</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, leafUid);</span><br><span class="line">            <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> leaf.leafSearchRange(leftKey, rightKey);</span><br><span class="line">            leaf.release();</span><br><span class="line">            uids.addAll(res.uids);</span><br><span class="line">            <span class="keyword">if</span>(res.siblingUid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leafUid = res.siblingUid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uids;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B+树中插入一条记录，也就是说往表里插入一条记录，这条记录对应的索引字段的B+树需要增添这条记录，</span></span><br><span class="line">    <span class="comment">// key为索引的key，uid为dataitem中记录的位置，这个是通过VM插入的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> key, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rootUid</span> <span class="operator">=</span> rootUid(); <span class="comment">// 得到根节点的UID</span></span><br><span class="line">        <span class="type">InsertRes</span> <span class="variable">res</span> <span class="operator">=</span> insert(rootUid, uid, key);</span><br><span class="line">        <span class="keyword">assert</span> res != <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.newNode != <span class="number">0</span>) &#123;</span><br><span class="line">            updateRootUid(rootUid, res.newNode, res.newKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InsertRes</span> &#123;</span><br><span class="line">        <span class="type">long</span> newNode, newKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InsertRes <span class="title function_">insert</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> uid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> node.isLeaf();</span><br><span class="line">        node.release();</span><br><span class="line"></span><br><span class="line">        <span class="type">InsertRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf) &#123;</span><br><span class="line">            res = insertAndSplit(nodeUid, uid, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> searchNext(nodeUid, key);</span><br><span class="line">            <span class="type">InsertRes</span> <span class="variable">ir</span> <span class="operator">=</span> insert(next, uid, key);</span><br><span class="line">            <span class="keyword">if</span>(ir.newNode != <span class="number">0</span>) &#123;</span><br><span class="line">                res = insertAndSplit(nodeUid, ir.newNode, ir.newKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">InsertRes</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InsertRes <span class="title function_">insertAndSplit</span><span class="params">(<span class="type">long</span> nodeUid, <span class="type">long</span> uid, <span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> Node.loadNode(<span class="built_in">this</span>, nodeUid);</span><br><span class="line">            <span class="type">InsertAndSplitRes</span> <span class="variable">iasr</span> <span class="operator">=</span> node.insertAndSplit(uid, key);</span><br><span class="line">            node.release();</span><br><span class="line">            <span class="keyword">if</span>(iasr.siblingUid != <span class="number">0</span>) &#123;</span><br><span class="line">                nodeUid = iasr.siblingUid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">InsertRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertRes</span>();</span><br><span class="line">                res.newNode = iasr.newSon;</span><br><span class="line">                res.newKey = iasr.newKey;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        bootDataItem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="字段与表管理TBM"><a href="#字段与表管理TBM" class="headerlink" title="字段与表管理TBM"></a>字段与表管理TBM</h2><p>TBM实现了对字段和表结构的管理，同时实现了对SQL语句的解析。</p>
<h3 id="SQL解析器"><a href="#SQL解析器" class="headerlink" title="SQL解析器"></a>SQL解析器</h3><p>Parser 实现了对类 SQL 语句的结构化解析，将语句中包含的信息封装为对应语句的类</p>
<p>MyDB实现的sql语法如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">begin</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">begin</span> [isolation level (read committed<span class="operator">|</span>repeatable read)]</span><br><span class="line">        <span class="keyword">begin</span> isolation level read committed</span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">commit</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">commit</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span>abort statement<span class="operator">&gt;</span></span><br><span class="line">    abort</span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">create</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    [(index <span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>)]</span><br><span class="line">        <span class="keyword">create</span> <span class="keyword">table</span> students</span><br><span class="line">        id int32,</span><br><span class="line">        name string,</span><br><span class="line">        age int32 </span><br><span class="line">        (index id name)</span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">drop</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">drop</span> <span class="keyword">table</span> students</span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> (<span class="operator">*</span><span class="operator">|</span><span class="operator">&lt;</span>field name list<span class="operator">&gt;</span>) <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">select</span> name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">4</span></span><br><span class="line">        <span class="keyword">select</span> name, age, id <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">values</span> <span class="operator">&lt;</span><span class="keyword">value</span> list<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> <span class="number">5</span> &quot;Zhang Yuanjia&quot; <span class="number">22</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">delete</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> &quot;Zhang Yuanjia&quot;</span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">update</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;=</span><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> &quot;ZYJ&quot; <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">where</span> statement<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">where</span> <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span><span class="operator">|</span><span class="operator">=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span> [(<span class="keyword">and</span><span class="operator">|</span><span class="keyword">or</span>) <span class="operator">&lt;</span>field name<span class="operator">&gt;</span> (<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span><span class="operator">|</span><span class="operator">=</span>) <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>]</span><br><span class="line">        <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br><span class="line">    [a<span class="operator">-</span>zA<span class="operator">-</span>Z][a<span class="operator">-</span>zA<span class="operator">-</span>Z0<span class="number">-9</span>_]<span class="operator">*</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span>field type<span class="operator">&gt;</span></span><br><span class="line">    int32 int64 string</span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span></span><br><span class="line">    .<span class="operator">*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>parser 包的 Tokenizer 类，对语句进行逐字节解析，根据空白符或者上述词法规则，将语句切割成多个 token。对外提供了 peek()、pop() 方法方便取出 Token 进行解析。切割的实现不赘述。 </p>
<p>Parser 类则直接对外提供了 Parse(byte[] statement) 方法，核心就是一个调用 Tokenizer 类分割 Token，并根据词法规则包装成具体的 Statement 类并返回。解析过程很简单，仅仅是根据第一个 Token 来区分语句类型，并分别处理，比如 select * from student where id &#x3D; 1， 先解析select，根据select后面语法的规定进行解析，并将select包装成一个类。</p>
<p>where 后面的条件只能是索引的字段 并且 where 条件为&gt;&lt;&#x3D;这三种，最多两个条件 使用and或or</p>
<p>update 中set 后面只能修改一个字段</p>
<h3 id="字段与表管理"><a href="#字段与表管理" class="headerlink" title="字段与表管理"></a>字段与表管理</h3><p>注意，这里的字段与表管理，不是管理各个条目中不同的字段的数值等信息，而是管理表和字段的结构数据，例如表名、表字段信息和字段索引等。</p>
<p>由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[FieldName][TypeName][IndexUid]</span><br></pre></td></tr></table></figure>

<p>这里 FieldName 和 TypeName，以及后面的表明，存储的都是字节形式的字符串。这里规定一个字符串的存储方式，以明确其存储边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[StringLength][StringData]</span><br></pre></td></tr></table></figure>

<p>TypeName 为字段的类型，限定为 int32、int64 和 string 类型。如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根，否则该字段为 0。</p>
<p>根据这个结构，通过一个 UID 从 VM 中读取并解析如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 根据表和字段uid，得到字段的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">loadField</span><span class="params">(Table tb, <span class="type">long</span> uid)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] raw = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Field</span>(uid, tb).parseSelf(raw);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 得到fieldName和typeName</span></span><br><span class="line">    <span class="keyword">private</span> Field <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);</span><br><span class="line">        fieldName = res.str;</span><br><span class="line">        position += res.next;</span><br><span class="line">        res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));</span><br><span class="line">        fieldType = res.str;</span><br><span class="line">        position += res.next;</span><br><span class="line">        <span class="built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm); <span class="comment">// 创建一个B+树</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                Panic.panic(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字段信息通过VM持久化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);</span><br><span class="line">    <span class="type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);</span><br><span class="line">    <span class="type">byte</span>[] indexRaw = Parser.long2Byte(index);</span><br><span class="line">    <span class="built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[TableName][NextTableUid]</span><br><span class="line">[Field1Uid][Field2Uid]...[FieldNUid]</span><br></pre></td></tr></table></figure>

<p>这里由于每个 Entry 中的数据，字节数是确定的，于是无需保存字段的个数。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。</p>
<p>对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where 只支持两个条件的与和或。例如有条件的 Delete，计算 Where，最终就需要获取到条件范围内所有的 UID。MYDB 只支持已索引字段作为 Where 的条件。计算 Where 的范围，具体可以查看 Table 的 <code>parseWhere()</code> 和 <code>calWhere()</code> 方法，以及 Field 类的 <code>calExp()</code> 方法。</p>
<p>创建一张表，其中nextUid为原先头表的Uid，由于采用的是头插法，新表的uid就变成了头uid</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一张表，其中nextUid为原先头表的Uid，由于采用的是头插法，新表的uid就变成了头uid</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Table <span class="title function_">createTable</span><span class="params">(TableManager tbm, <span class="type">long</span> nextUid, <span class="type">long</span> xid, Create create)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Table</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>(tbm, create.tableName, nextUid);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; create.fieldName.length; i ++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> create.fieldName[i];</span><br><span class="line">           <span class="type">String</span> <span class="variable">fieldType</span> <span class="operator">=</span> create.fieldType[i];</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">indexed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; create.index.length; j ++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(fieldName.equals(create.index[j])) &#123;</span><br><span class="line">                   indexed = <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           tb.fields.add(Field.createField(tb, xid, fieldName, fieldType, indexed)); <span class="comment">// 依次创建字段和类型、索引</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> tb.persistSelf(xid); <span class="comment">// 将table表结构通过vm持久化</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>表结构是由VM进行持久化的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将table表结构通过vm持久化</span></span><br><span class="line">  <span class="keyword">private</span> Table <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">byte</span>[] nameRaw = Parser.string2Byte(name);</span><br><span class="line">      <span class="type">byte</span>[] nextRaw = Parser.long2Byte(nextUid);</span><br><span class="line">      <span class="type">byte</span>[] fieldRaw = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">          fieldRaw = Bytes.concat(fieldRaw, Parser.long2Byte(field.uid));</span><br><span class="line">      &#125;</span><br><span class="line">      uid = ((TableManagerImpl)tbm).vm.insert(xid, Bytes.concat(nameRaw, nextRaw, fieldRaw));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>对表数据内容读取、插入、删除、更新操作</p>
<p>读取：通过索引找到存在dataitem中的uid列表，再通过VM读取信息内容</p>
<p>插入时：通过vm将字段值字节数组持久化，然后将索引的key和位置信息插入到B+树中</p>
<p>删除：通过索引找到存在dataitem中的uid列表，再通过VM删除信息内容（改xmax的信息），不同更改B+树上的内容。</p>
<p>更新：通过B+树得到要更新的dateitem的uid列表，再通过VM删除信息内容（改xmax的信息），在通过VM新建dataitem，在更改B+树的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, Delete delete)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Long&gt; uids = parseWhere(delete.where);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long uid : uids) &#123;</span><br><span class="line">            <span class="keyword">if</span>(((TableManagerImpl)tbm).vm.delete(xid, uid)) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> xid, Update update)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Long&gt; uids = parseWhere(update.where);   <span class="comment">// 通过where得到需要修改的数据的uid</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">fd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f.fieldName.equals(update.fieldName)) &#123;</span><br><span class="line">                fd = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.FieldNotFoundException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> fd.string2Value(update.value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long uid : uids) &#123;</span><br><span class="line">            <span class="type">byte</span>[] raw = ((TableManagerImpl)tbm).vm.read(xid, uid);</span><br><span class="line">            <span class="keyword">if</span>(raw == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            ((TableManagerImpl)tbm).vm.delete(xid, uid);  <span class="comment">// 修改时先删除</span></span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; entry = parseEntry(raw);</span><br><span class="line">            entry.put(fd.fieldName, value);</span><br><span class="line">            raw = entry2Raw(entry);</span><br><span class="line">            <span class="type">long</span> <span class="variable">uuid</span> <span class="operator">=</span> ((TableManagerImpl)tbm).vm.insert(xid, raw); <span class="comment">// 新的数据通过VM插入到entry中</span></span><br><span class="line">            </span><br><span class="line">            count ++;  <span class="comment">// 修改的数据条数加一</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;   <span class="comment">// 修改B+树中的内容</span></span><br><span class="line">                <span class="keyword">if</span>(field.isIndexed()) &#123;</span><br><span class="line">                    field.insert(entry.get(field.fieldName), uuid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select语句的查找，得到对应的数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">read</span><span class="params">(<span class="type">long</span> xid, Select read)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Long&gt; uids = parseWhere(read.where);   <span class="comment">// 通过索引找到存在dataitem中的uid列表</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Long uid : uids) &#123;</span><br><span class="line">            <span class="type">byte</span>[] raw = ((TableManagerImpl)tbm).vm.read(xid, uid);</span><br><span class="line">            <span class="keyword">if</span>(raw == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Map&lt;String, Object&gt; entry = parseEntry(raw);</span><br><span class="line">            sb.append(printEntry(entry)).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, Insert insert)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;String, Object&gt; entry = string2Entry(insert.values);  <span class="comment">// 将插入的数据变为  属性---值  的形式</span></span><br><span class="line">        <span class="type">byte</span>[] raw = entry2Raw(entry);  <span class="comment">// 将字段的值连接起来 转换为字节数组</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> ((TableManagerImpl)tbm).vm.insert(xid, raw);  <span class="comment">// 通过vm将字段值字节数组持久化</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isIndexed()) &#123;  <span class="comment">// 遍历字段找到是索引的字段</span></span><br><span class="line">                field.insert(entry.get(field.fieldName), uid);  <span class="comment">// 将索引的key和位置信息插入到B+树中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须保存一个链表的头节点，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。</p>
<p>MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期通过操作系统重命名文件的原子性，来保证操作的原子性。</p>
<p>TBM 层对外提供服务的是 TableManager 接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TableManager</span> &#123;</span><br><span class="line">    BeginRes <span class="title function_">begin</span><span class="params">(Begin begin)</span>;</span><br><span class="line">    <span class="type">byte</span>[] commit(<span class="type">long</span> xid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] abort(<span class="type">long</span> xid);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] show(<span class="type">long</span> xid);</span><br><span class="line">    <span class="type">byte</span>[] create(<span class="type">long</span> xid, Create create) <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] insert(<span class="type">long</span> xid, Insert insert) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, Select select) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] update(<span class="type">long</span> xid, Update update) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] delete(<span class="type">long</span> xid, Delete delete) <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TableManager <span class="title function_">create</span><span class="params">(String path, VersionManager vm, DataManager dm)</span> &#123;</span><br><span class="line">        <span class="type">Booter</span> <span class="variable">booter</span> <span class="operator">=</span> Booter.create(path);</span><br><span class="line">        booter.update(Parser.long2Byte(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TableManagerImpl</span>(vm, dm, booter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TableManager <span class="title function_">open</span><span class="params">(String path, VersionManager vm, DataManager dm)</span> &#123;</span><br><span class="line">        <span class="type">Booter</span> <span class="variable">booter</span> <span class="operator">=</span> Booter.open(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TableManagerImpl</span>(vm, dm, booter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 C&#x2F;S 结构），这些方法直接返回执行的结果，例如错误信息或者结果信息的字节数组（可读）。</p>
<p>各个方法的具体实现很简单，不再赘述，无非是调用 VM 的相关方法。唯一值得注意的一个小点是，在创建新表时，采用的时头插法，所以每次创建表都需要更新 Booter 文件。</p>
<h2 id="服务端及客户端实现"><a href="#服务端及客户端实现" class="headerlink" title="服务端及客户端实现"></a>服务端及客户端实现</h2><p>MyDB被设计为 C&#x2F;S 结构，类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果。</p>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。当然如果嫌麻烦的话，其实直接用明文也不是不可以。</p>
<p>传输的最基本结构，是 Package：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data;</span><br><span class="line">    Exception err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 Package 在发送前，由 Encoder 编码为字节数组，在对方收到后同样会由 Encoder 解码成 Package 对象。编码和解码的规则如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Flag][data]</span><br></pre></td></tr></table></figure>

<p>若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；如果 flag 为 1，表示发送的是错误，data 是 Exception.getMessage() 的错误提示信息。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encode(Package pkg) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> pkg.getErr();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Intern server error!&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(err.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                msg = err.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>&#125;, msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>&#125;, pkg.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length))));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码之后的信息会通过 Transporter 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用 BufferedReader 和 Writer 来直接按行读写了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="keyword">private</span> BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="built_in">this</span>.writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> hexEncode(data);</span><br><span class="line">        writer.write(raw);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] receive() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexDecode(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hexEncode</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(buf, <span class="literal">true</span>)+<span class="string">&quot;n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] hexDecode(String buf) <span class="keyword">throws</span> DecoderException &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.decodeHex(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Packager 则是 Encoder 和 Transporter 的结合体，直接对外提供 send 和 receive 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Packager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Transporter transpoter;</span><br><span class="line">    <span class="keyword">private</span> Encoder encoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Packager</span><span class="params">(Transporter transpoter, Encoder encoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transpoter = transpoter;</span><br><span class="line">        <span class="built_in">this</span>.encoder = encoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = encoder.encode(pkg);</span><br><span class="line">        transpoter.send(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">receive</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = transpoter.receive();</span><br><span class="line">        <span class="keyword">return</span> encoder.decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        transpoter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Server-和-Client实现"><a href="#Server-和-Client实现" class="headerlink" title="Server 和 Client实现"></a>Server 和 Client实现</h3><p>Server 和 Client，偷懒直接使用了 Java 的 socket。</p>
<p>Server 启动一个 ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理。这部分应该直接背板了。</p>
<p>HandleSocket 类实现了 Runnable 接口，在建立连接后初始化 Packager，随后就循环接收来自客户端的数据并处理，并且使用线程池，多线程处理多个客户端请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    TableManager tbm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Server</span><span class="params">(<span class="type">int</span> port, TableManager tbm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.tbm = tbm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server listen to port: &quot;</span> + port);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">tpe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandleSocket</span>(socket, tbm);</span><br><span class="line">                tpe.execute(worker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandleSocket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> TableManager tbm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandleSocket</span><span class="params">(Socket socket, TableManager tbm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.tbm = tbm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InetSocketAddress)socket.getRemoteSocketAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;Establish connection: &quot;</span> + address.getAddress().getHostAddress()+<span class="string">&quot;:&quot;</span>+address.getPort());</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">            <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">            packager = <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>(tbm);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pkg = packager.receive();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] sql = pkg.getData();</span><br><span class="line">            <span class="type">byte</span>[] result = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = exe.execute(sql);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                e = e1;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            pkg = <span class="keyword">new</span> <span class="title class_">Package</span>(result, e);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                packager.send(pkg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exe.close();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            packager.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理sql的核心类是Executor类，Executor 调用 Parser 获取到对应语句的结构化信息对象，并根据对象的类型，调用 TBM 的不同方法进行处理。具体不再赘述。</p>
<p>Launcher类是服务器的启动入口。这个类解析了命令行参数，很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Options</span>();</span><br><span class="line">        options.addOption(<span class="string">&quot;open&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;-open DBPath&quot;</span>);</span><br><span class="line">        options.addOption(<span class="string">&quot;create&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;-create DBPath&quot;</span>);</span><br><span class="line">        options.addOption(<span class="string">&quot;mem&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;-mem 64MB&quot;</span>);</span><br><span class="line">        <span class="type">CommandLineParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultParser</span>();</span><br><span class="line">        <span class="type">CommandLine</span> <span class="variable">cmd</span> <span class="operator">=</span> parser.parse(options,args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cmd.hasOption(<span class="string">&quot;open&quot;</span>)) &#123;</span><br><span class="line">            openDB(cmd.getOptionValue(<span class="string">&quot;open&quot;</span>), parseMem(cmd.getOptionValue(<span class="string">&quot;mem&quot;</span>)));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cmd.hasOption(<span class="string">&quot;create&quot;</span>)) &#123;</span><br><span class="line">            createDB(cmd.getOptionValue(<span class="string">&quot;create&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usage: launcher (open|create) DBPath&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createDB</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.create(path);</span><br><span class="line">        <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);</span><br><span class="line">        <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">        TableManager.create(path, vm, dm);</span><br><span class="line">        tm.close();</span><br><span class="line">        dm.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">openDB</span><span class="params">(String path, <span class="type">long</span> mem)</span> &#123;</span><br><span class="line">        <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.open(path);</span><br><span class="line">        <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.open(path, mem, tm);</span><br><span class="line">        <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">        <span class="type">TableManager</span> <span class="variable">tbm</span> <span class="operator">=</span> TableManager.open(path, vm, dm);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Server</span>(port, tbm).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>客户端连接服务器的过程，也是背板。客户端有一个简单的 Shell，实际上只是读入用户的输入，并调用 Client.execute()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] execute(<span class="type">byte</span>[] stat) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(stat, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Package</span> <span class="variable">resPkg</span> <span class="operator">=</span> rt.roundTrip(pkg);</span><br><span class="line">    <span class="keyword">if</span>(resPkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> resPkg.getErr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resPkg.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RoundTripper 类实际上实现了单次收发动作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">roundTrip</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    packager.send(pkg);</span><br><span class="line">    <span class="keyword">return</span> packager.receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后附上客户端的启动入口，很简单，把 Shell run 起来即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line"></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(packager);</span><br><span class="line">        <span class="type">Shell</span> <span class="variable">shell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell</span>(client);</span><br><span class="line">        shell.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h4 id="sql执行过程"><a href="#sql执行过程" class="headerlink" title="sql执行过程"></a>sql执行过程</h4><p>若数据库执行 <code>select * from student where id = 5</code>语句执行过程是怎样的？</p>
<ol>
<li>TBM对sql语句进行解析</li>
<li>TBM调用IM，查询得到id&#x3D;5的那条记录的句柄（也就是地址）</li>
<li>TBM根据得到的地址，从VM中读取数据</li>
<li>TBM将从VM中读取到得到的二进制数据进行解析，解析出记录原本的内容</li>
<li>将还原的记录内容返还给用户</li>
</ol>
<p>假设现在数据库需要执行: insert into student values “zhangyuanjia” 2012141461290 这条语句. 那么执行的过程大致如下:</p>
<ol>
<li>TBM对语句进行解析, 并生成记录.</li>
<li>TBM将记录二进制化, 并调用VM, 将其存入DB中, 并得到一个句柄.</li>
<li>TBM调用IM, 将句柄, 作为value让IM给存入索引中.</li>
<li>返回.</li>
</ol>
<h4 id="两段锁协议怎么实现调度序列的串行化"><a href="#两段锁协议怎么实现调度序列的串行化" class="headerlink" title="两段锁协议怎么实现调度序列的串行化"></a>两段锁协议怎么实现调度序列的串行化</h4><p>可串行化调度：多个事务之间的执行方式。如果这多个事务没有共同的操作对象，事务之间的执行顺序前后置换没有关系，但是如果有共同的操作对象，则事务之间的执行顺序需要区分，多个并发的事务操作共同对象的执行结果等价于串行化调度，，则这个调度是可串行化的。</p>
<p>两段锁协议：</p>
<p>对数据进行读写之前需要进行加锁操作，释放一个锁之后不在申请获取其他的锁。</p>
<p>如何采用两段锁协议实现调度序列的可串行化：</p>
<p>当采用2PL时，如果事务i已经对x加锁了，且另一个事务j也想操作x，但是这个操作与事务i之前的操作互相冲突的话，事务j就会被阻塞。例如，T1已经因为U(x)锁定了x，那么T2对x的读或者写操作都会被阻塞，T2必须等T1释放对x的锁。</p>
<p>缺点：</p>
<p>导致事务之间相互阻塞，甚至死锁。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>什么是 MVCC？<br>   VM 在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本</p>
<p>通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</p>
<p>【版本链】：update操作的时候，通过where后面的索引项，TBM调用IM进行查找，比如where id &#x3D; 5，会得到索引为5的所有的地址，包括各种版本数据的地址，存到一个list列表里，然后TBM调用VM根据地址查找到数据项entry，进行删除（实际是设置一个关于某个事务的删除标志），然后再创建一个entry通过DM存起来，返回一个地址，将这个地址和这个索引通过IM插入到当前表的B+树中。</p>
<p>MVCC 解决什么问题？</p>
<p>能解决 2PL 实现调度序列可串行化的读写阻塞，降低事务的阻塞概率</p>
<h4 id="如何实现的读已提交："><a href="#如何实现的读已提交：" class="headerlink" title="如何实现的读已提交："></a>如何实现的读已提交：</h4><p>通过VM为每一条entry维护两个字段：</p>
<p>XMIN：创建该版本时的事务编号</p>
<p>XMAX：删除该版本时的事务编号</p>
<p>entry 的结构：【XMIN】【XMAX】【Data】，其中data内存的是一行数据记录</p>
<p>在读已提交下，版本对事务的可见性逻辑为：如果该记录由该事务创建的且还未被删除   或   由一个已提交事务创建且尚未被删除   或   由一个已提交事务创建虽然删除了但是删除事务还未被提交</p>
<p>如何实现可重复读：</p>
<p> 逻辑为：如果该记录由该事务Ti创建且还未被删除  或   创建这条记录的事务版本号xid小于Ti，在Ti之前提交（并且没有被删除  或是删除事务的xid在Ti之后开始的）</p>
<h4 id="如何判定有无死锁"><a href="#如何判定有无死锁" class="headerlink" title="如何判定有无死锁"></a>如何判定有无死锁</h4><p>如果Ti锁定了X，现在Tj准备更新X，那么Tj就会被阻塞，等待Ti释放X 的锁。这种等待关系可以用有向图表示出来，这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。 MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="comment">// 某个XID已经获得的资源的UID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="comment">// UID被某个XID持有</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="comment">// 正在等待UID的XID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="comment">// 正在等待资源的XID的锁</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="comment">// XID正在等待的UID</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<p>查找图中是否有环的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。 </p>
<p>在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p>
<p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取</p>
<p>从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了</p>
<h4 id="为什么不提供删除方法"><a href="#为什么不提供删除方法" class="headerlink" title="为什么不提供删除方法"></a>为什么不提供删除方法</h4><ol>
<li>TBM解析语句</li>
<li>TBM根据where条件去IM中查询X 的地址</li>
<li>TBM调用VM，将X删除</li>
<li>VM将X对该事务可见的那个版本的entry的XMAX设置为该事务的XID，</li>
<li>删除结束</li>
</ol>
<h4 id="表结构是怎样的"><a href="#表结构是怎样的" class="headerlink" title="表结构是怎样的"></a>表结构是怎样的</h4><p>表的字段的结构：</p>
<p>【FileName】【TypeName】【Index Boot Address】：字段名；字段类型；如果该字段是索引的话为该字段索引的地址</p>
<p>表的结构：</p>
<p>【TableName】【isDroped】【NextTableAddress】【NoFields】【filed0Address】【filed1Address】。。。：表名；是否删除；下一张表的地址；字段个数；每个字段的信息</p>
<h4 id="SQL语句是如何进行解析的"><a href="#SQL语句是如何进行解析的" class="headerlink" title="SQL语句是如何进行解析的"></a>SQL语句是如何进行解析的</h4><p>定义了SQL的语法规则，使用 Tokenizer 类，根据空白符或者词法规则，对语句进行逐字节解析，将语句切割成多个 token，然后进行解析，解析过程为根据第一个 Token 来区分语句类型，并分别处理，就是if-else方法进行判断和对语句进行组装，根据词法规则包装成具体的statement对象，比如insert、select、where这种对象。</p>
<p>token的理解：如语句select name，age from student  中token有：select、name、，、age、from、student</p>
<p>Server模块，得到前端传过来的sql，先对sql进行解析，只有调用TBM对应的各种方法，进行执行sql，如begin、commit、abort、select、insert、update、delte操作</p>
<h4 id="怎么实现的B-树进行索引查找"><a href="#怎么实现的B-树进行索引查找" class="headerlink" title="怎么实现的B+树进行索引查找"></a>怎么实现的B+树进行索引查找</h4><p>sql中实现的查找支持where中的索引字段的查找。</p>
<p>IM模块对外提供了两个接口：insert（key，value）和select（key），key为索引字段的记录，value为该记录在DM中的地址。</p>
<p>定义的表结构中存在字段结构，字段结构中存着B+树根节点的地址。</p>
<p>B+树中节点Node的结构格式为：<code>[LeafFlag][KeyNumber][SiblingUid]                     [Son0][Key0][Son1][Key1]...[SonN][KeyN]</code></p>
<p>叶子节点存储的是当前key 在DateItem中的地址</p>
<p>Node节点存在于DM模块的DataItem中的data字段。多个node节点构成了一个B+树。</p>
<p>IM模块自己管理锁，控制B+树访问不会出现死锁，通过IM模块对B+树节点进行读取操作前需要进行加锁，并且规定了任意事务Ti某一时刻最多只能获取到一个节点的锁，也就是说，Ti取得节点u的锁，如果想访问下一个节点，必须先释放掉u的锁，这样保证并发访问情况下，不会出现死锁。</p>
<p>事务通过IM模块对DM模块进行操作的时候使用的事务为超级事务Super_XID，如果某个事务回滚了，该事务的索引依然留在B+树中，通过VM读不出来，所以是安全的。如果B+树在执行过程中崩溃，节点u内部结构就会被破坏，但是IM是基于DM 的，在下一次数据库重启的时候，节点u就会被恢复成修改之前的状态，全部都回滚了，满足原子性。</p>
<p>B+树接口没有删除</p>
<p>用户删除的某条记录的过程</p>
<ol>
<li>TBM解析语句;</li>
<li>TBM利用IM, 查询到X的地址;</li>
<li>TBM调用VM, 将X删除;</li>
<li>VM将X对该事务可见的那个版本的XMAX设置为该事务的XID;</li>
<li>删除结束.</li>
</ol>
<p>上述过程并没有要求从IM中删除X对应的索引, 假如T1删除X之后, 又有T5事务, 尝试读取X, 那会怎样呢? 过程大致如下:</p>
<ol>
<li>TBM解析语句;</li>
<li>TBM利用IM, 查询到X的地址;</li>
<li>TBM利用VM读取X;</li>
<li>由于X已经被删除, VM将找不到合适的版本, 于是返回nil;</li>
<li>TBM接受到nil, 当做该条记录不存在, 返回给用户这个结果.</li>
</ol>
<p>可见, 由于VM的存在, 使得IM不用删除这些索引也没关系.</p>
<p>但是如果IM一直不删除这些索引的话, 索引树又会变得极其的庞大, 占用资源, 也降低NYADB效率. 所以, 在必要的时候, 可以让IM对索引树进行整理.</p>
<h4 id="什么是XID文件"><a href="#什么是XID文件" class="headerlink" title="什么是XID文件"></a>什么是XID文件</h4><p>XID文件是对事务状态的记录，对事务的管理就是对XID文件的管理，内存中的事务是通过VM模块进行管理，包括开启事务，事务的隔离级别。</p>
<p>XID文件中开头保存了8个字节的数字，记录文件中事务的个数，为每个事务分配一个字节，有三种转态，正在进行、提交、已撤销（active、commit、above），其中8个字节之后首先为一个超级事务，操作在没有事务的情况下进行，超级事务永远是已提交状态。每个事务都对应一个id，从1开始是自增的，0为超级事务，这样就能通过事务的id在XID文件中获取和修改他的状态</p>
<p>接口有：开启一个新事务、提交一个事务、取消一个事务、查询一个事务。</p>
<h4 id="DM-的主要职责"><a href="#DM-的主要职责" class="headerlink" title="DM 的主要职责"></a>DM 的主要职责</h4><p>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：</p>
<ol>
<li><p>分页管理 DB 文件，并进行缓存；</p>
</li>
<li><p>管理日志文件，保证在发生错误时可以根据日志进行恢复；</p>
</li>
<li><p>抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p>
</li>
</ol>
<p>DB的首要工作是对磁盘文件进行封装，向下直接读写文件，向上提供数据的包装。另外就是日志功能。</p>
<p>DM会对DB进行缓存以加快对DB的读写。</p>
<h4 id="为什么使用缓存，怎么使用的缓存"><a href="#为什么使用缓存，怎么使用的缓存" class="headerlink" title="为什么使用缓存，怎么使用的缓存"></a>为什么使用缓存，怎么使用的缓存</h4><p>假如用户第一次访问数据库中的某些数据的话，这个过程比较慢，需要从磁盘中读取，如果将经常访问的数据放到缓存中的话，用户下次访问就可以直接从缓存中获取。</p>
<p>使用引用计数法，可以称为计数缓存吧，只有上层模块不使用某资源时，会释放对资源的引用，只有当引用归零时，缓存就会驱逐这个资源。LRU策略中，资源驱逐不可控的，上层模块无法感知。    如果缓存满了，引用计数器无法自动释放缓存，会报OOM错误。</p>
<p> 缓存的是一个页面，计数是对一个页面的计数。</p>
<p>引用计数策略接口：get(key)   release(key)   close()</p>
<p> 通过get()方法获取资源，首先进入一个死循环，来无限尝试从缓存中获取。首先判断这个时候是否有其他线程从数据源获取这个资源，如果有过一会再来看看，如果缓存中有这个资源，将这个资源的引用个数加一，直接返回这个资源， 如果缓存中没有，判断缓存是否满了，没满的话在getting中注册一下，表示该线程准备从数据源获取这个资源，调用抽象方法getForCache从数据源获取，得到资源存入缓存，在getting中删除key，该资源的引用计数置为1</p>
<h4 id="怎么实现的计数缓存"><a href="#怎么实现的计数缓存" class="headerlink" title="怎么实现的计数缓存"></a>怎么实现的计数缓存</h4><ol>
<li>抽象类AbstractCache<T>，以HashMap的方式进行记录 （缓存，引用计数，其他线程正在获取的资源）。</li>
<li>通过get(key)方法获取资源，首先进入一个死循环，来无限尝试从缓存中获取。首先判断这个时候是否有其他线程从数据源获取这个资源，如果有过一会再来看看，如果缓存中有这个资源，将这个资源的引用个数加一，直接返回这个资源， 如果缓存中没有，判断缓存是否满了，没满的话在getting中注册一下，表示该线程准备从数据源获取这个资源，调用抽象方法getForCache从数据源获取，得到资源存入缓存，在getting中删除key，该资源的引用计数置为1</li>
<li>release(key)方法强行释放资源，引用数减一，当引用数为0的时候，进行回写操作，并删除缓存中的内容，不为0的话，引用数减一。</li>
<li>close()方法，关闭缓存 ，回写缓存中的所有资源：遍历所有对象，执行回写操作，并删除缓存中的数据。</li>
<li>使用缓存的业务，只需要继承抽象类，实现两个抽象方法：getForCache()：当资源不在缓存中时的获取资源的行为；releaseForCache():从缓存中驱逐资源的行为，包括回写操作。</li>
</ol>
<h4 id="DM层怎么管理DB文件（数据文件）："><a href="#DM层怎么管理DB文件（数据文件）：" class="headerlink" title="DM层怎么管理DB文件（数据文件）："></a>DM层怎么管理DB文件（数据文件）：</h4><p>采用NIO方式的fileChannel进行文件读取和写入的。</p>
<p>以页面的方式从DB文件中读取数据，使用引用计数缓存对读取到的页面进行缓存，默认的数据页面的大小为8KB，如果想要提升数据库写入大量数据下的性能可以适当增大此值。</p>
<p>DB文件中的内容也是以页面的方式存的，第一页是一个特殊的页面，用来启动检查什么的。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。 这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>普通页面的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FreeSpaceOffset] [Data]</span><br><span class="line">FreeSpaceOffset: 2字节无符号数据  表示这一页空闲位置的偏移</span><br></pre></td></tr></table></figure>

<p>MYDB 对于普通数据页的管理就比较简单了。一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移，FreeSpaceOffset。剩下的部分都是实际存储的数据。</p>
<p>数据页的页面结构：页号、实际包含的字节数据、是否包含脏数据、页面缓存</p>
<p>什么是脏页面：缓存页被驱逐时，脏页面必须被写回磁盘，数据执行的一些插入和修改操作，都是对缓存页的内容执行的，对于缓存页有变动的，最后都需要写回磁盘。</p>
<h4 id="为什么需要日志？"><a href="#为什么需要日志？" class="headerlink" title="为什么需要日志？"></a>为什么需要日志？</h4><p>DM操作数据项时, 先修改的是内存中的数据, 至于什么时候刷新到磁盘, 是需要策略的. 如果在修改数据项之前, 能够保证对应日志已经到达磁盘, 那在修改数据项后, 即使暂时不刷新到磁盘, 也没关系. 假如在该段时间内数据库发生了崩溃, 那磁盘上的数据项则会有误, 因为正确的数据项内容还未被刷新到磁盘上. 但是因为数据库在修改数据项前就保证了日志已经到达磁盘，数据库再次启动时，可以根据日志的内容进行恢复数据文件，保证其一致性。</p>
<h4 id="日志的结构"><a href="#日志的结构" class="headerlink" title="日志的结构"></a>日志的结构</h4><p>日志的二进制文件的格式：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206161000997.png" alt="image-20220616100001890"></p>
<p>Xchecksum是一个四字节的整数，是对后续所有日志的校验和。Log1~LogN是常规的日志记录。BadTail是在数据库崩溃时没来记得写完的日志记录，这个BadTail不一定存在。</p>
<p>每一条日志的格式如下：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202206161002638.png" alt="image-20220616100229584"></p>
<p>Size是一个四字节的整数，标志着Data字段的字节长度。Checksum也是一个四字节的整数，是该条日志的校验和，是对Data的校验。</p>
<p>其中每一条日志中data的内容组成：[LogType] [XID] [Pgno] [Offset] [Raw]，在日志恢复中会用到</p>
<p>在打开一个日志文件时，初始化，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。</p>
<p>向日志文件中插入一条日志，首先将数据包装成一条日志的格式，size，checksum，data，写入文件后，在更新Xchecksum，更新完成后强制刷出到磁盘。</p>
<h4 id="日志的恢复"><a href="#日志的恢复" class="headerlink" title="日志的恢复"></a>日志的恢复</h4><p>日志策略：</p>
<p>在进行 Insert和 Update 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。至于delete，涉及到VM层</p>
<p>这个日志策略使得DM层对于数据操作的磁盘同步可以更加随意，日志在数据操作之前已经到达磁盘，即使后来的数据操作没来记得写入磁盘，数据库发生崩溃，也可以通过磁盘上的日志恢复数据操作。</p>
<p>如何利用日志进行输入恢复：（单线程）</p>
<p>假设最后一个出现在日志中的事务是Ti，那么可以分为两步：</p>
<ol>
<li>对Ti之前的事务，进行重做redo</li>
<li>检查Ti，如果Ti是commit，那么对Ti进行重做，否则，进行撤销undo</li>
</ol>
<p>怎么对事务进行redo操作：</p>
<ol>
<li>正序扫描事务T的所有日志</li>
<li>如果该日志是插入操作（T，I，X），那么将X插入到DB文件中。</li>
<li>如果是更新操作（T，U，oldx，newx），则将DB文件中x的值设置为newx。</li>
</ol>
<p>怎么对事务进行undo操作：</p>
<ol>
<li>倒序扫描事务T的所有日志</li>
<li>如果是插入操作，则将x从DB文件中删除</li>
<li>如果是更新操作，则将DB文件中的X值设置为oldx。</li>
</ol>
<p>在多线程中需要满足：</p>
<ol>
<li>正在进行的事务，不会读取其他未提交事物产生的数据</li>
<li>正在进行的事务，不会修改其他未提交事物修改或产生的数据。</li>
</ol>
<h4 id="项目中socket实现"><a href="#项目中socket实现" class="headerlink" title="项目中socket实现"></a>项目中socket实现</h4><p>Server端：创建一个ServerSocket，指定某个端口；创建Socket，监听客户端，按照一定协议，通过读写流的方式从客户端接受或发送数据；当有一个请求到来的时候直接丢给一个新线程去处理</p>
<p>Client端：创建Socket，指定地址和端口，按照一定协议，通过读写流的方式从客户端发送或接受数据。</p>
<p>编码协议：建立一个packager类，两部分：【flag】【data】，flag表示是不是错误信息，是的话data为错误信息，不是的话data为数据信息。</p>
<p>编码之后的信息会通过 Transporter 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用 BufferedReader 和 Writer 来直接按行读写了。</p>
<h4 id="Buffer-和-Cache-的区别"><a href="#Buffer-和-Cache-的区别" class="headerlink" title="Buffer 和 Cache 的区别"></a>Buffer 和 Cache 的区别</h4><p>Buffer：缓冲，一般是顺序读写，特指内存中临时存放IO设备的数据—-包括读取和写入；Cache：缓存，一般是随机读写，而Cache的用途有很多，很多IO设备（如硬盘）上有cache，cpu内部也有cache。</p>
<p>涉及到IO设备读写的场景中，Cache的一部分本身就是Buffer中的一种。如果说某些场合Buffer可以提升IO设备读写性能，只不是是因为Buffer本身是Cache系统的一部分</p>
<p>例子：</p>
<p>Read Buffer 和 Read Cache:</p>
<p>cpu访问硬盘数据，存放数据到内存中，这块内存就是buffer，cpu可以对这些存放的数据进行操作，操作完成后，Buffer所占内存就会被回收。</p>
<p>如果一个应用需要频繁的读取文件A，每次从硬盘读取速度很慢，如果在第一次读取完成之后，不直接清空Buffer所占内存，而是把这段内存留下来或是复制到其他内存地址，以后对这个文件的读取就可以直接从内存中访问，无需访问硬盘，应用程序就会快很多，这就是Cache，严格来说为Read Cache，但不是所有从硬盘上读取到Buffer中数据都会被Cache。</p>
<p>Write Buffer 和 Write Cache：</p>
<p>对于数据写入磁盘上的操作，小数据的写入，需要填满write buffer 再一次性写入，对于大数据，大数据会被分割到buffer尺寸的大小分批写入。Write buffer的用处使得每次写入的数据量相对固定。</p>
<p>write cache就是设法减少写入次数，如果某些数据需要产生多次写入，那么使用cache就可以将最终的数据写入磁盘，导致最终写入数据减少。</p>
<p>在read（读取）的场合，cache通常被用于减少重复读取数据时的开销，而buffer则用于规整化每次读取数据的尺寸，在读取场合两者用途差别很大。</p>
<p>在write（写入）的场合，两者功能依然没变，但由于cache跟buffer的功能在写入场合可以融合使用，所以两者可以被混淆，写入缓冲跟写入缓存往往会同时担当规整化写入尺寸以及减少写入次数的功能，所以两者有时会被混淆，但这只是个名称问题，没有原则性关系。</p>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>377</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cobwebzh.top">可乐就炸鸡</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cobwebzh.top/2022/10/18/%E9%A1%B9%E7%9B%AE/MyDB/">https://cobwebzh.top/2022/10/18/%E9%A1%B9%E7%9B%AE/MyDB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cobwebzh.top" target="_blank">可乐就炸鸡の葵花宝典</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MyDB/">MyDB</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/111" target="_blank"><img class="post-qr-code-img" src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202210241925598.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/18/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/SSM/"><img class="prev-cover" src="https://api.ghser.com/random/api.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SSM</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/18/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/%E5%88%B7%E9%A2%98/"><img class="next-cover" src="https://api.ghser.com/random/api.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">刷题算法笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MyDB"><span class="toc-number">1.</span> <span class="toc-text">MyDB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">前提知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO%E4%B8%8ENIO%E4%B8%8EAIO"><span class="toc-number">1.1.1.</span> <span class="toc-text">BIO与NIO与AIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ByteBuffer"><span class="toc-number">1.1.2.</span> <span class="toc-text">ByteBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel"><span class="toc-number">1.1.3.</span> <span class="toc-text">FileChannel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-TM"><span class="toc-number">1.3.</span> <span class="toc-text">事务管理 TM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-DM"><span class="toc-number">1.4.</span> <span class="toc-text">数据管理 DM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">共享内存数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">引用计数缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">页面缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">数据页管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.5.</span> <span class="toc-text">日志文件与恢复策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">日志的读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">日志恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.6.</span> <span class="toc-text">页面索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataItem"><span class="toc-number">1.4.7.</span> <span class="toc-text">DataItem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DM-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.8.</span> <span class="toc-text">DM 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93DM"><span class="toc-number">1.4.9.</span> <span class="toc-text">总结DM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-VM"><span class="toc-number">1.5.</span> <span class="toc-text">版本管理 VM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">记录的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.5.2.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83"><span class="toc-number">1.5.3.</span> <span class="toc-text">版本跳跃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.4.</span> <span class="toc-text">死锁检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VM%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.5.</span> <span class="toc-text">VM的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86-IM"><span class="toc-number">1.6.</span> <span class="toc-text">索引管理 IM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">二叉树索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86TBM"><span class="toc-number">1.7.</span> <span class="toc-text">字段与表管理TBM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">SQL解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">字段与表管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.</span> <span class="toc-text">服务端及客户端实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server-%E5%92%8C-Client%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">Server 和 Client实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">1.9.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">sql执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%B0%83%E5%BA%A6%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">两段锁协议怎么实现调度序列的串行化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC"><span class="toc-number">1.9.0.3.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%9A"><span class="toc-number">1.9.0.4.</span> <span class="toc-text">如何实现的读已提交：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%9C%89%E6%97%A0%E6%AD%BB%E9%94%81"><span class="toc-number">1.9.0.5.</span> <span class="toc-text">如何判定有无死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8F%90%E4%BE%9B%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.0.6.</span> <span class="toc-text">为什么不提供删除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">1.9.0.7.</span> <span class="toc-text">表结构是怎样的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90%E7%9A%84"><span class="toc-number">1.9.0.8.</span> <span class="toc-text">SQL语句是如何进行解析的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84B-%E6%A0%91%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE"><span class="toc-number">1.9.0.9.</span> <span class="toc-text">怎么实现的B+树进行索引查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFXID%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.0.10.</span> <span class="toc-text">什么是XID文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DM-%E7%9A%84%E4%B8%BB%E8%A6%81%E8%81%8C%E8%B4%A3"><span class="toc-number">1.9.0.11.</span> <span class="toc-text">DM 的主要职责</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">1.9.0.12.</span> <span class="toc-text">为什么使用缓存，怎么使用的缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-number">1.9.0.13.</span> <span class="toc-text">怎么实现的计数缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DM%E5%B1%82%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86DB%E6%96%87%E4%BB%B6%EF%BC%88%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%9A"><span class="toc-number">1.9.0.14.</span> <span class="toc-text">DM层怎么管理DB文件（数据文件）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">1.9.0.15.</span> <span class="toc-text">为什么需要日志？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.0.16.</span> <span class="toc-text">日志的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">1.9.0.17.</span> <span class="toc-text">日志的恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%ADsocket%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.0.18.</span> <span class="toc-text">项目中socket实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-%E5%92%8C-Cache-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.0.19.</span> <span class="toc-text">Buffer 和 Cache 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#end"><span class="toc-number">1.10.</span> <span class="toc-text">end</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022.07 - 2023 By 可乐就炸鸡</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
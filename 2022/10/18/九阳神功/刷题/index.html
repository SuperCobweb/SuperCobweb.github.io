<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>刷题算法笔记 | 可乐就炸鸡の葵花宝典</title><meta name="keywords" content="算法笔记"><meta name="author" content="可乐就炸鸡"><meta name="copyright" content="可乐就炸鸡"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="需要复盘的题目1月4日 913. 猫和老鼠 - 力扣 1月10日 306. 累加数 - 力扣 2月27日 1696. 跳跃游戏 VI - 力扣    dp + 单调队列 1871. 跳跃游戏 VII - 力扣    dp + 前缀和 3月2日 564. 寻找最近的回文数     贪心分析上下界+边界情况 3月8日 2055. 蜡烛之间的盘子 - 力扣（LeetCode） (leetcode-cn.">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题算法笔记">
<meta property="og:url" content="https://cobwebzh.top/2022/10/18/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="可乐就炸鸡の葵花宝典">
<meta property="og:description" content="需要复盘的题目1月4日 913. 猫和老鼠 - 力扣 1月10日 306. 累加数 - 力扣 2月27日 1696. 跳跃游戏 VI - 力扣    dp + 单调队列 1871. 跳跃游戏 VII - 力扣    dp + 前缀和 3月2日 564. 寻找最近的回文数     贪心分析上下界+边界情况 3月8日 2055. 蜡烛之间的盘子 - 力扣（LeetCode） (leetcode-cn.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.ghser.com/random/api.php">
<meta property="article:published_time" content="2022-10-18T07:34:00.000Z">
<meta property="article:modified_time" content="2023-04-12T15:02:23.630Z">
<meta property="article:author" content="可乐就炸鸡">
<meta property="article:tag" content="算法笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.ghser.com/random/api.php"><link rel="shortcut icon" href="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012058447.png"><link rel="canonical" href="https://cobwebzh.top/2022/10/18/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/%E5%88%B7%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '刷题算法笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-04-12 23:02:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207012052210.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://www.dmoe.cc/random.php')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">可乐就炸鸡の葵花宝典</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">刷题算法笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-18T07:34:00.000Z" title="发表于 2022-10-18 15:34:00">2022-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T15:02:23.630Z" title="更新于 2023-04-12 23:02:23">2023-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/">九阳神功</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="刷题算法笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="需要复盘的题目"><a href="#需要复盘的题目" class="headerlink" title="需要复盘的题目"></a>需要复盘的题目</h2><p>1月4日</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cat-and-mouse/">913. 猫和老鼠 - 力扣</a></p>
<p>1月10日</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/additive-number/">306. 累加数 - 力扣</a></p>
<p>2月27日</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-vi/">1696. 跳跃游戏 VI - 力扣</a>    dp + 单调队列</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-vii/">1871. 跳跃游戏 VII - 力扣</a>    dp + 前缀和</p>
<p>3月2日</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-closest-palindrome/">564. 寻找最近的回文数 </a>    贪心分析上下界+边界情况</p>
<p>3月8日</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plates-between-candles/">2055. 蜡烛之间的盘子 - 力扣（LeetCode） (leetcode-cn.com)</a>  前缀和+记录每个点左右最近的蜡烛</p>
<p>3月23日</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字 - 力扣（LeetCode） (leetcode-cn.com)</a>  借助字典树的思想，统计子树下面的结点数来判断是否进入子树还是跳过这个子树</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II - 力扣</a></p>
<p>思路 ： 根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的。我们可以知道容器内水的高度取决于最外层高度最低的方块。</p>
<p>我们假设已经知道最外层的方块接水后的高度的最小值，则此时我们根据木桶原理，肯定可以确定最小高度方块的相邻方块的接水高度。我们同时更新最外层的方块标记，我们在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapRainWater</span><span class="params">(<span class="type">int</span>[][] heightMap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heightMap.length, n = heightMap[<span class="number">0</span>].length;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, i, heightMap[<span class="number">0</span>][i]&#125;);</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;m - <span class="number">1</span>, i, heightMap[m - <span class="number">1</span>][i]&#125;);</span><br><span class="line">            vis[<span class="number">0</span>][i] = vis[m - <span class="number">1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>, heightMap[i][<span class="number">0</span>]&#125;);</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, n - <span class="number">1</span>, heightMap[i][n - <span class="number">1</span>]&#125;);</span><br><span class="line">            vis[i][<span class="number">0</span>] = vis[i][n - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] poll = q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> poll[<span class="number">0</span>], y = poll[<span class="number">1</span>], h = poll[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] d : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + d[<span class="number">0</span>], ny = y + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (vis[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (h &gt; heightMap[nx][ny]) ans += h - heightMap[nx][ny];</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny, Math.max(heightMap[nx][ny], h)&#125;);</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
<li></li>
</ol>
<h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><h4 id="序列DP"><a href="#序列DP" class="headerlink" title="序列DP"></a>序列DP</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-divisible-subset/">368. 最大整除子集 </a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211112113400272.png" alt="image-20211112113400272"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//序列DP dp[i] 表示前i个数字中，且以i为结尾的最长整除子集的长度</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestDivisibleSubset</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] g = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_id</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">//前i个数中，整除子集的取最大长度时，最后一个n的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_len</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//前i个数中，整除子集的最大长度</span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; len)&#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        g[i] = j;</span><br><span class="line">                        len = dp[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; max_len)&#123;</span><br><span class="line">                max_id = i;</span><br><span class="line">                max_len = dp[i];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_id == -<span class="number">1</span>)&#123;</span><br><span class="line">            ans.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> max_id;</span><br><span class="line">        <span class="keyword">while</span> (ans.size() &lt;= max_len)&#123;</span><br><span class="line">            ans.add(nums[r]);</span><br><span class="line">            r = g[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-inverse-pairs-array/">629. K个逆序对数组 </a></p>
<h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏 </a></p>
<p>思路：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211112112501427.png" alt="image-20211112112501427"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">stoneGame</span><span class="params">(<span class="type">int</span>[] piles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt;= n; len++) &#123; <span class="comment">// 枚举区间长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++) &#123; <span class="comment">// 枚举左端点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + len - <span class="number">1</span>; <span class="comment">// 计算右端点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> piles[l - <span class="number">1</span>] - dp[l + <span class="number">1</span>][r];</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> piles[r - <span class="number">1</span>] - dp[l][r - <span class="number">1</span>];</span><br><span class="line">                dp[l][r] = Math.max(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II </a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 区间DP dp[l,r] = max(dp[l,x-1],dp[x+1,r]) + x;</span></span><br><span class="line">    <span class="comment">// dp[l][r] 表示[l,r]范围内能获胜的最小成本</span></span><br><span class="line">    <span class="comment">// 我们可以决策的是在[l,r]范围内可以选哪个数的成本最小，而不能决策的是选了一个数之后真实值落在哪边得是最大的。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [][]dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 区间长度为1时，已经知道答案啦，不需要猜了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + len - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l; x &lt;= r; x++)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(dp[l][x - <span class="number">1</span>], dp[x + <span class="number">1</span>][r]) + x;</span><br><span class="line">                    ans = Math.min(cur, ans);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[l][r] = ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归 + 记忆搜索</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] cache = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[l][r] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cache[l][r];</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// l &lt; r 时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l; x &lt;= r; x++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(dfs(l, x - <span class="number">1</span>), dfs(x + <span class="number">1</span>, r)) + x;</span><br><span class="line">            ans = Math.min(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488868&idx=1&sn=5e54a1d091a8249d3033a28fc299076d">宫水三叶大佬整理的背包问题解题方法</a></p>
<h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">weightbagproblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagsize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wlen</span> <span class="operator">=</span> weight.length, value0 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[wlen + <span class="number">1</span>][bagsize + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化：背包容量为0时，能获得的价值都为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= wlen; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = value0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= wlen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagsize; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一维dp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">WeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagWeight)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wLen</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>0-1背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">WeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagWeight)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wLen</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagWeight; j++)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202209261525418.png" alt="image-20220926152505083"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMultiPack1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 版本一：改变物品数量为01背包格式</span></span><br><span class="line">    List&lt;Integer&gt; weight = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    List&lt;Integer&gt; value = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">bagWeight</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums.get(i) &gt; <span class="number">1</span>) &#123; <span class="comment">// 把物品展开为i</span></span><br><span class="line">            weight.add(weight.get(i));</span><br><span class="line">            value.add(value.get(i));</span><br><span class="line">            nums.set(i, nums.get(i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight.get(i); j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight.get(i)] + value.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMultiPack2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 版本二：改变遍历个数</span></span><br><span class="line">    <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bagWeight</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.length; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="comment">// 以上为01背包，然后加一个遍历个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= <span class="number">0</span>; k++) &#123; <span class="comment">// 遍历个数</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="朴素广度优先搜索"><a href="#朴素广度优先搜索" class="headerlink" title="朴素广度优先搜索"></a>朴素广度优先搜索</h4><p>一般用队列，第一个元素入队，判断队列不为空，步数+1，记录队列中元素个数依次出队，上下左右遍历，入队。如果不需要记录步数，可以去掉size的循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] direct = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125; <span class="comment">//四个方向</span></span><br><span class="line">Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;); </span><br><span class="line"><span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">	step++;		<span class="comment">//记录步数</span></span><br><span class="line">	size = queue.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;   <span class="comment">// 不需要记录步数可以去掉这个循环</span></span><br><span class="line">		<span class="type">int</span>[] element = queue.poll();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> element[<span class="number">0</span>] + direct[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> element[<span class="number">1</span>] + direct[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (判断条件)</span><br><span class="line">				queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;); <span class="comment">//满足条件入队</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双向广度优先搜索"><a href="#双向广度优先搜索" class="headerlink" title="双向广度优先搜索"></a>双向广度优先搜索</h4><p>朴素的 BFS 可能会带来「搜索空间爆炸」的情况。</p>
<p>在朴素的 BFS 实现中，空间的瓶颈主要取决于搜索空间中的最大宽度。</p>
<p>那么有没有办法让我们不使用这么宽的搜索空间，同时又能保证搜索到目标结果呢？</p>
<p>「双向 BFS」 可以很好的解决这个问题：</p>
<p>同时从两个方向开始搜索，一旦搜索到相同的值，意味着找到了一条联通起点和终点的最短路径。</p>
<p>「双向 BFS」的基本实现思路如下：</p>
<ol>
<li><p>创建「两个队列」分别用于两个方向的搜索；</p>
</li>
<li><p>创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；</p>
</li>
<li><p>为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少；</p>
</li>
<li><p>如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。<br>「双向 BFS」基本思路对应的伪代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">d1、d2 为两个方向的队列</span><br><span class="line">m1、m2 为两个方向的哈希表，记录每个节点距离起点的</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只有两个队列都不空，才有必要继续往下搜索</span></span><br><span class="line"><span class="comment">// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点</span></span><br><span class="line"><span class="keyword">while</span>(!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.size() &lt; d2.size()) &#123;</span><br><span class="line">        update(d1, m1, m2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(d2, m2, m1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update 为从队列 d 中取出一个元素进行「一次完整扩展」的逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Deque d, Map cur, Map other)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁 - 力扣</a></p>
<p>朴素广度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">openLock</span><span class="params">(String[] deadends, String target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;0000&quot;</span>.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; dead = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String deadend : deadends) &#123;</span><br><span class="line">            dead.add(deadend);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dead.contains(<span class="string">&quot;0000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        queue.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        seen.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ++step;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (String nextStatus : get(status)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!seen.contains(nextStatus) &amp;&amp; !dead.contains(nextStatus)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nextStatus.equals(target)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> step;</span><br><span class="line">                        &#125;</span><br><span class="line">                        queue.offer(nextStatus);</span><br><span class="line">                        seen.add(nextStatus);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">numPrev</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">x</span> <span class="operator">=</span>= <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;9&#x27;</span> : (<span class="type">char</span>) (x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">numSucc</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">x</span> <span class="operator">=</span>= <span class="string">&#x27;9&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : (<span class="type">char</span>) (x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 status 通过一次旋转得到的数字</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">get</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">char</span>[] array = status.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = numPrev(num);</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">String</span>(array));</span><br><span class="line">            array[i] = numSucc(num);</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">String</span>(array));</span><br><span class="line">            array[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>双向广度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String t, s;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">openLock</span><span class="params">(String[] _ds, String _t)</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line">        t = _t;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(t)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String d : _ds) set.add(d);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(s)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> bfs();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// d1 代表从起点 s 开始搜索（正向）</span></span><br><span class="line">        <span class="comment">// d2 代表从结尾 t 开始搜索（反向）</span></span><br><span class="line">        Deque&lt;String&gt; d1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(), d2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * m1 和 m2 分别记录两个方向出现的状态是经过多少次转换而来</span></span><br><span class="line"><span class="comment">         * e.g.</span></span><br><span class="line"><span class="comment">         * m1 = &#123;&quot;1000&quot;:1&#125; 代表 &quot;1000&quot; 由 s=&quot;0000&quot; 旋转 1 次而来</span></span><br><span class="line"><span class="comment">         * m2 = &#123;&quot;9999&quot;:3&#125; 代表 &quot;9999&quot; 由 t=&quot;9996&quot; 旋转 3 次而来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Integer&gt; m1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        d1.addLast(s);</span><br><span class="line">        m1.put(s, <span class="number">0</span>);</span><br><span class="line">        d2.addLast(t);</span><br><span class="line">        m2.put(t, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 只有两个队列都不空，才有必要继续往下搜索</span></span><br><span class="line"><span class="comment">         * 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点</span></span><br><span class="line"><span class="comment">         * e.g. </span></span><br><span class="line"><span class="comment">         * 例如，如果 d1 为空了，说明从 s 搜索到底都搜索不到 t，反向搜索也没必要进行了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (d1.size() &lt;= d2.size()) &#123;</span><br><span class="line">                t = update(d1, m1, m2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = update(d2, m2, m1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t != -<span class="number">1</span>) <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(Deque&lt;String&gt; deque, Map&lt;String, Integer&gt; cur, Map&lt;String, Integer&gt; other)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">poll</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">        <span class="type">char</span>[] pcs = poll.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> cur.get(poll);</span><br><span class="line">        <span class="comment">// 枚举替换哪个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 能「正向转」也能「反向转」，这里直接枚举偏移量 [-1,1] 然后跳过 0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 求得替换字符串 str</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> pcs[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (origin + j) % <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span> (next == -<span class="number">1</span>) next = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span>[] clone = pcs.clone();</span><br><span class="line">                clone[i] = (<span class="type">char</span>)(next + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(clone);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (set.contains(str)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur.containsKey(str)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果在「另一方向」找到过，说明找到了最短路，否则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (other.containsKey(str)) &#123; </span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span> + other.get(str);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    deque.addLast(str);</span><br><span class="line">                    cur.put(str, step + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/escape-a-large-maze/">1036. 逃离大迷宫 - 力扣</a></p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h3 id="启发式搜索（A-算法）"><a href="#启发式搜索（A-算法）" class="headerlink" title="启发式搜索（A*算法）"></a>启发式搜索（A*算法）</h3><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211115221126024.png" alt="image-20211115221126024"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁 - 力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">openLock</span><span class="params">(String[] deadends, String target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;0000&quot;</span>.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; dead = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String deadend : deadends) &#123;</span><br><span class="line">            dead.add(deadend);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dead.contains(<span class="string">&quot;0000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;AStar&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;AStar&gt;((a, b) -&gt; a.f - b.f);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">AStar</span>(<span class="string">&quot;0000&quot;</span>, target, <span class="number">0</span>));</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        seen.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">AStar</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (String nextStatus : get(node.status)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!seen.contains(nextStatus) &amp;&amp; !dead.contains(nextStatus)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextStatus.equals(target)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> node.g + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">AStar</span>(nextStatus, target, node.g + <span class="number">1</span>));</span><br><span class="line">                    seen.add(nextStatus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">numPrev</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">x</span> <span class="operator">=</span>= <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;9&#x27;</span> : (<span class="type">char</span>) (x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">numSucc</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">x</span> <span class="operator">=</span>= <span class="string">&#x27;9&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : (<span class="type">char</span>) (x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 status 通过一次旋转得到的数字</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">get</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">char</span>[] array = status.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = numPrev(num);</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">String</span>(array));</span><br><span class="line">            array[i] = numSucc(num);</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">String</span>(array));</span><br><span class="line">            array[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AStar</span> &#123;</span><br><span class="line">    String status;</span><br><span class="line">    <span class="type">int</span> f, g, h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AStar</span><span class="params">(String status, String target, <span class="type">int</span> g)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">        <span class="built_in">this</span>.g = g;</span><br><span class="line">        <span class="built_in">this</span>.h = getH(status, target);</span><br><span class="line">        <span class="built_in">this</span>.f = <span class="built_in">this</span>.g + <span class="built_in">this</span>.h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算启发函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getH</span><span class="params">(String status, String target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> Math.abs(status.charAt(i) - target.charAt(i));</span><br><span class="line">            ret += Math.min(dist, <span class="number">10</span> - dist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><p>回文一般有两种解法，</p>
<p>方法一：中心扩散法，也是双指针法，构成回文有两种情况，由一个点构成的回文还有两个点构成的回文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            ans++;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//从一个点开始构成的回文</span></span><br><span class="line">            recursion(s, i, i, n);</span><br><span class="line">            <span class="comment">//从两个点开始构成的回文</span></span><br><span class="line">            recursion(s, i, i + <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：动态规划法</p>
<p>执行效率不如中心扩散法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp[i][j] : 字符串s从第i位到j位是否能构成回文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 从后往前遍历，防止遗漏 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]))&#123;</span><br><span class="line">                   dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                   ans++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>





<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级详解 + 练习（持续更新） - 全排列 - 力扣（LeetCode）</a></p>
<p>回溯的时间复杂度分析： N为数据可以遍历的规模</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220826213515628.png" alt="image-20220826213515628"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列 - 力扣（LeetCode）</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯方法一：</span></span><br><span class="line">    <span class="comment">// public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     for (int num : nums)</span></span><br><span class="line">    <span class="comment">//         list.add(num);</span></span><br><span class="line">    <span class="comment">//     int n = nums.length;</span></span><br><span class="line">    <span class="comment">//     dfs(res, list, 0, n);</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// void dfs(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, int pos, int n)&#123;</span></span><br><span class="line">    <span class="comment">//     if (pos == n)&#123;</span></span><br><span class="line">    <span class="comment">//         res.add(new ArrayList&lt;&gt;(list));</span></span><br><span class="line">    <span class="comment">//         return ;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for (int i = pos; i &lt; n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         Collections.swap(list, pos, i);</span></span><br><span class="line">    <span class="comment">//         dfs(res, list, pos + 1, n);</span></span><br><span class="line">    <span class="comment">//         Collections.swap(list, i, pos);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回溯方法二</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dfs(res, list, vis, nums, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="type">boolean</span>[] vis, <span class="type">int</span>[] nums, <span class="type">int</span> pos, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(res, list, vis, nums, pos + <span class="number">1</span>, n);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">689. 三个无重叠子数组的最大和 - 力扣（LeetCode） (leetcode-cn.com)</a>  三个滑动窗口</p>
<p>滑动窗口中需要保存最大值索引的同时还记录候选最大值的索引情况下，使用单调队列或优先队列。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i])&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="keyword">if</span> (deque.peekFirst() &lt;= i - k)</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">                ans[j++] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>对于「找最近一个比当前值大&#x2F;小」的问题，都可以使用单调栈来解决。</p>
<p>「单调栈」顾名思义就是具有单调性的栈结构，一般常用于找到下一个更大的元素，即当前元素右侧第一个更大的元素</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220604104317651.png" alt="image-20220604104317651"></p>
<p>如果直接暴力的话，时间复杂度为O(n^2)，一般会超时，这时考虑使用单调栈，将元素正序，或是倒序入栈，要保持栈内的单调性，只有当前元素大于或小于栈顶元素时才入栈，否则的话先出栈一些元素，再讲当前元素入栈。一般是从栈底到栈顶单调递减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 判定个子高矮</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 矮个起开，反正也被挡着了</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的更大元素</span></span><br><span class="line">        res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        stack.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode）</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">//维护一个单调递减的栈</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += width * h;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220606185207408.png" alt="image-20220606185207408"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220819152743122.png" alt="image-20220819152743122"></p>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324223012585.png" alt="image-20220324223012585"><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324223131610.png" alt="image-20220324223131610"></p>
<p>因此当我们要求 (x1, y1) 作为左上角，(x2, y2) 作为右下角 的区域和的时候，可以直接利用前缀和数组快速求解：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324223341846.png" alt="image-20220324223341846"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324223413715.png" alt="image-20220324223413715"></p>
<p>模板代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理前缀和数组</span></span><br><span class="line">&#123;</span><br><span class="line">    sum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="comment">// 当前格子(和) = 上方的格子(和) + 左边的格子(和) - 左上角的格子(和) + 当前格子(值)【和是指对应的前缀和，值是指原数组中的值】sum是从1开始的，matrix是从0开始的</span></span><br><span class="line">            sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先我们要令左上角为 (x1, y1) 右下角为 (x2, y2)</span></span><br><span class="line"><span class="comment">// 计算 (x1, y1, x2, y2) 的结果</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前缀和是从 1 开始，原数组是从 0 开始，上来先将原数组坐标全部 +1，转换为前缀和坐标</span></span><br><span class="line">    x1++; y1++; x2++; y2++;</span><br><span class="line">    <span class="comment">// 记作 22 - 12 - 21 + 11，然后 不减，减第一位，减第二位，减两位</span></span><br><span class="line">    <span class="comment">// 也可以记作 22 - 12(x - 1) - 21(y - 1) + 11(x y 都 - 1)</span></span><br><span class="line">    ans = sum[x2][y2] - sum[x1 - <span class="number">1</span>][y2] - sum[x2][y1 - <span class="number">1</span>] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="树状数组-（BIT）"><a href="#树状数组-（BIT）" class="headerlink" title="树状数组 （BIT）"></a>树状数组 （BIT）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>使用情况：单点修改，区间求和</p>
<p>查询和修改的时间复杂度都为logn</p>
<p>先了解lowbit(x)函数，就是x的二进制最右边的1，连带着它之后的0组成的二进制数。</p>
<p>比如x&#x3D;6，二进制位110，lowbit(6) &#x3D; 10，即十进制为2。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>出现了一种数据结构</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220404111149316.png" alt="image-20220404111149316"></p>
<p>更新一个节点的值，相应的后面的值（父节点及祖先节点）也应该修改，更新过程是每次加了个二进制的低位1和右边的0组成的数，比如更新下标5的值，也需要更新6， 8， 16 ，(101+1 -&gt;110, 110 + 10 -&gt; 1000, 1000 + 1000 -&gt; 10000)这些节点的值</p>
<p>查询过程每次就是去掉了二进制中的低位1和右边的0组成的数，比如查询前15项的和，需要查询15，14，12，8处的值相加，(1111 - 1 -&gt; 1110, 1110 - 10 -&gt; 1100, 1100 - 100 -&gt; 1000)<br><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220404111930345.png" alt="image-20220404111930345"></p>
<p>更新操作代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; <span class="comment">//数组从1开始</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowbit(i))    <span class="comment">//x为更新的位置,y为更新后的数,n为数组最大值</span></span><br><span class="line">        c[i] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询操作代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsum</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowbit(i))</span><br><span class="line">        ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">            tree[i] += y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[index];</span><br><span class="line">        add(index + <span class="number">1</span>, val - t);</span><br><span class="line">        nums[index] = val;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> getSum(left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> getSum(right + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>对区间边界进行+1或-1标记，再利用前缀和统计</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计 - 力扣（LeetCode）</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220606222214719.png" alt="image-20220606222214719"></p>
<p><code>diff[i] =  nums[i] - nums[i - 1]</code>  可以由diff[1]依次得到nums数组的元素</p>
<p>修改数组nums中区间[1, 3]的元素，加5，只需要在diff中修改 <code>diff[1] = diff[1] + 5</code>  <code>diff[3 + 1] = diff[3 + 1] - 5</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    diff[i] += val;</span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">        diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/solution/by-lfool-eo50/">线段树详解「汇总级别整理 🔥🔥🔥」 - Range 模块 - 力扣（LeetCode）</a></p>
<h2 id="数组复制："><a href="#数组复制：" class="headerlink" title="数组复制："></a>数组复制：</h2><p><strong>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</strong></p>
<p>在 Java 中数据类型可以分为两大类：基本类型和引用类型。</p>
<p>　　基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。</p>
<p>　　引用类型则包括类、接口、数组、枚举等。</p>
<p>　　Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p>
<h3 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1. 浅克隆"></a>1. 浅克隆</h3><p>在浅克隆中，如果原型对象的成员变量是&#x3D;&#x3D;值类型&#x3D;&#x3D;，将复制一份给克隆对象；如果原型对象的成员变量是&#x3D;&#x3D;引用类型&#x3D;&#x3D;，则将引用复制一份给克隆对象，但不复制引用的对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p>
<p>简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20210714113259905.png" alt="image-20210714113259905"></p>
<p>在Java语言中，通过**&#x3D;&#x3D;覆盖Object类的clone()方法可以实现浅克隆&#x3D;&#x3D;**。</p>
<h3 id="2-深克隆"><a href="#2-深克隆" class="headerlink" title="2. 深克隆"></a>2. 深克隆</h3><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用的对象也复制一份给克隆对象。</p>
<p>简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20210714113834318.png" alt="image-20210714113834318"></p>
<p>在Java语言中，如果需要**&#x3D;&#x3D;实现深克隆，可以通过覆盖Object类的clone()方法实现，也可以通过序列化(Serialization)等方式&#x3D;&#x3D;**来实现。</p>
<p>实现对象克隆有两种方式：</p>
<p>  1.  实现Cloneable接口并重写Object类中的clone()方法，让每个引用类型属性内部都重写clone方法。</p>
<p>  2.  实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p>
<ol>
<li><p><code>for</code></p>
</li>
<li><p><code>clone</code>                 <code>array_name.clone()</code></p>
</li>
<li><p><code>System.arraycopy</code>       <code>System.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length)</code></p>
</li>
<li><p><code>Arrays.copyOf()</code>                      <code>Arrays.copyOf(dataType[] srcArray,int length);</code></p>
</li>
<li><p><code>Arrays.copyOfRange()</code>            <code>Arrays.copyOfRange(dataType[] srcArray,int startIndex,int endIndex)</code></p>
</li>
</ol>
<h2 id="数组转List"><a href="#数组转List" class="headerlink" title="数组转List"></a>数组转List</h2><ol>
<li><p><code>Arrays.asList()</code></p>
<p><code>List list = Arrays.asList(strArray);</code> 不能增删</p>
</li>
<li><p><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(strArray)) ;</code></p>
</li>
<li><p><code>Collections.addAll(arrayList, strArray)</code></p>
</li>
</ol>
<p>   <code>ArrayList&lt; String&gt; arrayList = new ArrayList&lt;String&gt;(strArray.length); Collections.addAll(arrayList, strArray);</code></p>
<ol start="4">
<li><p>Java 1.8之后  可以使用流stream来将下列3种数组快速转为List，分别是int[]、long[]、double[]，其他数据类型比如short[]、byte[]、char[]，在 JDK 1.8中暂不支持。由于这只是一种常用方法的封装，不再纳入一种崭新的数组转List方式，暂时算是 Java流送给我们的常用工具方法吧。<br><code>List&lt;Integer&gt; intList= Arrays.stream(new int[] &#123; 1, 2, 3, &#125;).boxed().collect(Collectors.toList()); List&lt;Long&gt; longList= Arrays.stream(new long[] &#123; 1, 2, 3 &#125;).boxed().collect(Collectors.toList()); List&lt;Double&gt; doubleList= Arrays.stream(new double[] &#123; 1, 2, 3 &#125;).boxed().collect(Collectors.toList());</code></p>
<p><code>String[] arrays = &#123;&quot;tom&quot;, &quot;jack&quot;, &quot;kate&quot;&#125;; List&lt;String&gt; stringList= Stream.of(arrays).collect(Collectors.toList());</code></p>
</li>
</ol>
<p>可能出现的问题：<code>int[] intArray1 = new int[2];    List&lt;Integer&gt; list1 = Arrays.asList(intArray1);//此处报错！！！</code> 可以先将int转为Integer再转为list</p>
<p>&#x3D;&#x3D;<code>List</code>声明时，需要传递一个泛型<code>&lt;E&gt;</code>作为形参，<code>asList()</code>参数类型也是泛型中的通配类型<code>&lt;T&gt;</code>。<strong>Java中所有的泛型必须是引用类型</strong>。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;8种基本数据类型boolean、byte、short、int、long、float、double、char也都不是引用类型，所以8种基本数据类型都不能作为List的形参。但String、数组、class、interface是引用类型，都可以作为List的形参，所以存在List<Runnable>接口类型的集合、List&lt;int[]&gt;数组类型的集合、List<String>类的集合。但不存在list<byte>、list<short> 等基本类型的集合。&#x3D;&#x3D;</p>
<p><strong>List 转数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] res = list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>





<h3 id="int数组转Integer数组"><a href="#int数组转Integer数组" class="headerlink" title="int数组转Integer数组"></a>int数组转Integer数组</h3><p>在Java中没有api能直接把int数组转换成Integer数组，需要经过流，装箱操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">Stream&lt;Integer&gt; boxed = stream.boxed();</span><br><span class="line">Integer[] integers = boxed.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Integer数组转int"><a href="#Integer数组转int" class="headerlink" title="Integer数组转int"></a>Integer数组转int</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = Arrays.stream(integers).boxed.mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>



<h3 id="String转Character数组"><a href="#String转Character数组" class="headerlink" title="String转Character数组"></a>String转Character数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;fdafda&quot;</span>;</span><br><span class="line">Character[] characters = s.chars().mapToObj(c -&gt; (<span class="type">char</span>) c).toArray(Character[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>方法二：需要导入ArrayUtils包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;testString&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">Character[] charObjectArray = ArrayUtils.toObject(charArray);</span><br></pre></td></tr></table></figure>





<h3 id="数组求和，获取最大值、最小值"><a href="#数组求和，获取最大值、最小值" class="headerlink" title="数组求和，获取最大值、最小值"></a>数组求和，获取最大值、最小值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(arr).sum();</span><br><span class="line"><span class="type">int</span> <span class="variable">maxx</span> <span class="operator">=</span> Arrays.stream(arr).max().getAsInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Arrays.stream(arr).min().getAsInt();</span><br></pre></td></tr></table></figure>





<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllOne</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(Node node)</span>&#123; <span class="comment">//往当前节点后面插入node</span></span><br><span class="line">            node.pre = <span class="built_in">this</span>;</span><br><span class="line">            node.next = <span class="built_in">this</span>.next;</span><br><span class="line">            <span class="built_in">this</span>.next.pre = node;</span><br><span class="line">            <span class="built_in">this</span>.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.pre.next = <span class="built_in">this</span>.next;</span><br><span class="line">            <span class="built_in">this</span>.next.pre = <span class="built_in">this</span>.pre;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    Map&lt;String, Node&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AllOne</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">            Node node;</span><br><span class="line">            <span class="keyword">if</span> (head.next.value == <span class="number">1</span>)&#123;</span><br><span class="line">                node = head.next;</span><br><span class="line">                node.set.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">                node.set.add(key);</span><br><span class="line">                head.insert(node);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value + <span class="number">1</span>;</span><br><span class="line">            Node newnode;</span><br><span class="line">            <span class="keyword">if</span> (node.next.value != value)&#123;</span><br><span class="line">                newnode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">                newnode.set.add(key);</span><br><span class="line">                node.insert(newnode);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                newnode = node.next;</span><br><span class="line">                newnode.set.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, newnode);</span><br><span class="line">            node.set.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (node.set.size() == <span class="number">0</span>)</span><br><span class="line">                node.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        node.set.remove(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>)&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value != <span class="number">0</span>)&#123;</span><br><span class="line">            Node newnode;</span><br><span class="line">            <span class="keyword">if</span> (node.pre.value == value)&#123;</span><br><span class="line">                newnode = node.pre;</span><br><span class="line">                newnode.set.add(key); </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newnode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">                newnode.set.add(key);</span><br><span class="line">                node.pre.insert(newnode);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, newnode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.set.size() == <span class="number">0</span>)</span><br><span class="line">            node.remove();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMaxKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">for</span>(String s: node.set)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMinKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span>(String s: node.set)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>又称单词查找树、前缀树。</p>
<p>在统计、排序和保存大量的字符串（但不仅限于字符串）是具有更小的时间复杂度，因此可以应用于搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<p>字典树的性质</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20210916112659128.png" alt="image-20210916112659128" style="zoom:50%;" /><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20210916112721677.png" alt="image-20210916112721677" style="zoom:50%;" /></p>
<p>构建节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;			</span><br><span class="line">	<span class="type">boolean</span> isWord;                      <span class="comment">// 从root根节点至此是否是一个完整的单词（即这个节点是否是一个单词的结尾）</span></span><br><span class="line">	TrieNode[] children;                 <span class="comment">// 巧妙的用数组的下标作为26个字母；数组的值则为子节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">		isWord = <span class="literal">false</span>;</span><br><span class="line">		children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路：按照word的字符，从根节点开始，一直向下走：</span></span><br><span class="line"><span class="comment">//          如果遇到null，就new出新节点；如果节点已经存在，cur顺着往下走就可以</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(TrieNode root, String word)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;                        <span class="comment">// 先指向根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;	<span class="comment">// 如果是【后缀树】而不是【前缀树】，把单词倒着插就可以了，即for(len-1; 0; i--)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;           <span class="comment">// (关键) 将一个字符用数字表示出来，并作为下标</span></span><br><span class="line">        <span class="keyword">if</span> (cur.children[c] == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.children[c] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.children[c];</span><br><span class="line">    &#125;</span><br><span class="line">    cur.isWord = <span class="literal">true</span>;                          <span class="comment">// 一个单词插入完毕，此时cur指向的节点即为一个单词的结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>数组构建字典树</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary/solution/by-ac_oier-bmot/">【宫水三叶】一题双解 :「模拟」&amp;「字典树」 - 词典中最长的单词 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] tr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">30010</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">boolean</span>[] isEnd = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">30010</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    Arrays.fill(tr[i], <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (tr[p][u] == <span class="number">0</span>)</span><br><span class="line">            tr[p][u] = ++idx;</span><br><span class="line">        p = tr[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    isEnd[p] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询s串是否在字典树中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">query</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        p = tr[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEnd[p])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>字典树序列应用题</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lexicographical-numbers/">386. 字典序排数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220418124932382.png" alt="image-20220418124932382"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220418124953705.png" alt="image-20220418124953705"></p>
<p>会发现字典序的顺序为字典树的前序遍历</p>
<p>递归的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">lexicalOrder</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) dfs(i, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; n) <span class="keyword">return</span> ;</span><br><span class="line">        ans.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) dfs(cur * <span class="number">10</span> + i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代的方式（前序遍历的方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">lexicalOrder</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans.add(j);</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">10</span> &lt;= n)</span><br><span class="line">                j = j * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (j % <span class="number">10</span> == <span class="number">9</span> || j + <span class="number">1</span> &gt; n) <span class="comment">//当最后一位为9或加一后大于n不能往下加了，需要移到上一层</span></span><br><span class="line">                    j = j / <span class="number">10</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220418125538842.png" alt="image-20220418125538842"></p>
<p>如果按上一题的做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (j * <span class="number">10</span> &lt;= n)</span><br><span class="line">             j = j * <span class="number">10</span>;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (j % <span class="number">10</span> == <span class="number">9</span> || j + <span class="number">1</span> &gt; n) <span class="comment">//当最后一位为9或加一后大于n不能往下加了，需要移到上一层</span></span><br><span class="line">                 j = j / <span class="number">10</span>;</span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>  (<span class="type">int</span>)j;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在力扣上会超时</p>
<p>这时考虑字典树中可以先统计一个节点下面子节点的数量，如果当前节点在点i位，下面子节点有j个，若 k &lt; &#x3D; i + j  则进入子节点，若大于的话，直接跳过这个节点下面的子节点。难点变成了计算子节点的个数，按每一层计算子节点的数量，第一一个first和last，first和last每往下一层都乘以10，last还需要加9，每一层的个数为 last - first，知道first 大于n，注意last &#x3D; min(last, n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//计算当前节点+子节点的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">first</span> <span class="operator">=</span> cur, last = cur;</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first &lt;= n)&#123;</span><br><span class="line">            total += Math.min(last, n) - first + <span class="number">1</span>;</span><br><span class="line">            first = first * <span class="number">10</span>;</span><br><span class="line">            last = last * <span class="number">10</span> + <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> getNode(cur, n);</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= node)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                k = k - node;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur * <span class="number">10</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





































<h2 id="二叉树相关"><a href="#二叉树相关" class="headerlink" title="二叉树相关"></a>二叉树相关</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    inorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorder(root.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
</li>
<li><p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>
</li>
</ul>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span> || !stk.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
</li>
<li><p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)的级别。</p>
</li>
</ul>
<h4 id="Morris-中序遍历"><a href="#Morris-中序遍历" class="headerlink" title="Morris 中序遍历"></a>Morris 中序遍历</h4><p>思路与算法</p>
<p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。</p>
<p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：</p>
<p>如果 xx 无左孩子，先将 xx 的值加入答案数组，再访问 xx 的右孩子，即 x&#x3D;x.right。<br>如果 xx 有左孩子，则找到 xx 左子树上最右的节点（即左子树中序遍历的最后一个节点，xx 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。<br>如果 predecessor 的右孩子为空，则将其右孩子指向 xx，然后访问 xx 的左孩子，即 x&#x3D;x.left。<br>如果predecessor 的右孩子不为空，则此时其右孩子指向 xx，说明我们已经遍历完 xx 的左子树，我们将 predecessor 的右孩子置空，将 xx 的值加入答案数组，然后访问 xx 的右孩子，即 x&#x3D;x.right。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">predecessor</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">            predecessor = root.left;</span><br><span class="line">            <span class="keyword">while</span> (predecessor.right != <span class="literal">null</span> &amp;&amp; predecessor.right != root) &#123;</span><br><span class="line">                predecessor = predecessor.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (predecessor.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                predecessor.right = root;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                predecessor.right = <span class="literal">null</span>;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)，其中 n 为二叉搜索树的节点个数。Morris 遍历中每个节点会被访问两次，因此总时间复杂度为 O(2n)&#x3D;O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>迭代1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代2（推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        	<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        	res.add(node.val);</span><br><span class="line">        	<span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        		stack.push(node.right);</span><br><span class="line">        	<span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        		stack.push(node.left);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代3</p>
<p>每次取出栈顶元素，如果当前节点是首次出队，则将节点的值加入到答案中，将节点标记为访问过，如果不是首次出队，从右到左将孩子节点加入到栈中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Object[]&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, root&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Object[] poll = stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> (<span class="type">int</span>)poll[<span class="number">0</span>];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> (TreeNode)poll[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (loc == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(node.val);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>, node&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (loc == <span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, node.right&#125;);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, node.left&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, res);</span><br><span class="line">        postorder(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>迭代 (比较难理解的迭代方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">method1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode prev=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//主要思想：</span></span><br><span class="line">        <span class="comment">//由于在某颗子树访问完成以后，接着就要回溯到其父节点去</span></span><br><span class="line">        <span class="comment">//因此可以用prev来记录访问历史，在回溯到父节点时，可以由此来判断，上一个访问的节点是否为右子树</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从栈中弹出的元素，左子树一定是访问完了的</span></span><br><span class="line">            root=stack.pop();</span><br><span class="line">            <span class="comment">//现在需要确定的是是否有右子树，或者右子树是否访问过</span></span><br><span class="line">            <span class="comment">//如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时</span></span><br><span class="line">            <span class="comment">//说明可以访问当前节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>||prev==root.right)&#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                <span class="comment">//更新历史访问记录，这样回溯的时候父节点可以由此判断右子树是否访问完成</span></span><br><span class="line">                prev=root;</span><br><span class="line">                root=<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果右子树没有被访问，那么将当前节点压栈，访问右子树</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序遍历反转(注意左右子树的入栈顺序)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        	<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        	res.add(node.val);</span><br><span class="line">        	<span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        		stack.push(node.left); </span><br><span class="line">        	<span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        		stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每次去除栈顶元素，如果当前节点已经遍历完所有的子节点，则将当前节点的值加入到答案中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Object[]&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, root&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Object[] poll = stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> (<span class="type">int</span>)poll[<span class="number">0</span>];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> (TreeNode)poll[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (loc == <span class="number">0</span>)&#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>, node&#125;);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, node.right&#125;);</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, node.left&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (loc == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="存图的方式"><a href="#存图的方式" class="headerlink" title="存图的方式"></a>存图的方式</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/396576813">【最短路&#x2F;必背模板】743. 网络延迟时间 : 涵盖所有的「存图方式」与「最短路算法（详尽注释）」 - 知乎 (zhihu.com)</a></p>
<ol>
<li><p>邻接矩阵</p>
<p>适用于边数较多的<strong>稠密图</strong>使用，当边数量接近点的数量的平方，即 m ≈ n ^ 2时，可定义为<strong>稠密图</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边</span></span><br><span class="line"><span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    w[a][b] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>邻接表</p>
<p>方式一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] g = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	g[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>方式二</p>
<p>链式前向星存图（采用头插法）</p>
<p>适用于边数较少的<strong>稀疏图</strong>使用，当边数量接近点的数量，即 m≈<em>n</em> 时，可定义为<strong>稀疏图</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> n, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Arrays.fill(he, -<span class="number">1</span>); <span class="comment">// 为了找到每一顶点对应的链表的结尾</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">	e[idx] = b;</span><br><span class="line">	ne[idx] = he[a];</span><br><span class="line">	he[a] = idx;</span><br><span class="line">	w[idx] = c;</span><br><span class="line">	idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先idx对边进行编号，然后对存图用到的几个数组简单的解释：</p>
<ul>
<li>e数组：idx编号下的那条边，指向的顶点。</li>
<li>he数组：记录邻接表中当前顶点对应的边集合中的头结点，也就是顶点a的第一条边对应的编号</li>
<li>ne数组：由于是以链表的形式进行存边，该数组就是用于找到下一条边（采用的是头插法）</li>
<li>w数组：记录某条边的权值</li>
</ul>
<p>当我们想要遍历由点a出发的所有边时，使用如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[a]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> e[i];</span><br><span class="line">	<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>类</p>
<p>这是一种最简单，但是相比上述两种存图方式，使用得较少的存图方式。</p>
<p>只有当我们需要确保某个操作复杂度严格为 O(m) 时，才会考虑使用。</p>
<p>具体的，我们建立一个类来记录有向边信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="comment">// 代表从 a 到 b 有一条权重为 c 的边</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    Edge(<span class="type">int</span> _a, <span class="type">int</span> _b, <span class="type">int</span> _c) &#123;</span><br><span class="line">        a = _a; b = _b; c = _c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常我们会使用 List 存起所有的边对象，并在需要遍历所有边的时候，进行遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Edge&gt; es = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Edge e : es) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><p>以此题进行讲解</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间 - 力扣</a></p>
<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35644234/article/details/60875818">最短路径问题—Floyd算法详解_William-CSDN博客_floyd算法</a></p>
<p>弗洛伊德算法是解决<strong>任意两点之间的最短路径</strong>的一种算法，可以正确处理非负权值的有向图或无向图的最短路径问题，也被用于计算有向图的传递闭包（多源汇最短路）</p>
<p>算法思路</p>
<p>枚举中转点—&gt; 枚举起点—-&gt; 枚举终点 —&gt; 松弛操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素b[i][j]，表示顶点i到顶点j经过了b[i][j]记录的值所表示的顶点。</span><br><span class="line">假设图G中顶点个数为N，则需要对矩阵S和矩阵P进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞，矩阵P的值为顶点b[i][j]的j的值。 接下来开始，对矩阵S进行N次更新。第<span class="number">1</span>次更新时，如果”a[i][j]的距离” &gt; “a[i][<span class="number">0</span>]+a[<span class="number">0</span>][j]”(a[i][<span class="number">0</span>]+a[<span class="number">0</span>][j]表示”i与j之间经过第<span class="number">1</span>个顶点的距离”)，则更新a[i][j]为”a[i][<span class="number">0</span>]+a[<span class="number">0</span>][j]”,更新b[i][j]=b[i][<span class="number">0</span>]。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k-<span class="number">1</span>]+a[k-<span class="number">1</span>][j]”，则更新a[i][j]为”a[i][k-<span class="number">1</span>]+a[k-<span class="number">1</span>][j]”,b[i][j]=b[i][k-<span class="number">1</span>]。更新N次之后，操作完成！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p>一个图的邻接矩阵A：</p>
<table>
<thead>
<tr>
<th></th>
<th>v1</th>
<th>v2</th>
<th>v3</th>
</tr>
</thead>
<tbody><tr>
<td>v1</td>
<td>0</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>v2</td>
<td>3</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td>v3</td>
<td>∞</td>
<td>4</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一步是：枚举中转点：比如中转点为 v1：</span><br><span class="line">A[v2][v1] + A[v1][v3] &lt; A[v2][v3], 因此将A[v2][<span class="number">3</span>] 置为 A[v2][v1] + A[v1][v3]</span><br><span class="line">依次枚举中转点---&gt; 枚举起点----&gt; 枚举终点 ---&gt; 松弛操作</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// floyd 基本流程为三层循环：</span></span><br><span class="line">    <span class="comment">// 枚举中转点 - 枚举起点 - 枚举终点 - 松弛操作        </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= n; p++) &#123;   <span class="comment">// 存表时从1开始的，邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                w[i][j] = Math.min(w[i][j], w[i][p] + w[p][j]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为O(n^<span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yalishadaa/article/details/55827681">Dijkstra算法原理_记忆碎片-CSDN博客_dijkstra算法</a></p>
<p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止</p>
<p>算法思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211230220004902.png" alt="image-20211230220004902"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211230220040004.png" alt="image-20211230220040004"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211230220058483.png" alt="image-20211230220058483"></p>
<p>朴素Dijkstra (邻接矩阵)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵表示</span></span><br><span class="line"><span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="comment">//dist[x] = y 表示从起点到x的最短距离为y</span></span><br><span class="line"><span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="comment">//记录哪些点被更新了，也就是加入到S集合中了</span></span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line"><span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//起始先将所有点标记为未更新和距离起点无穷大</span></span><br><span class="line">    Arrays.fill(dist, INF);</span><br><span class="line">    Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//只有起点最短距离为0</span></span><br><span class="line">    disk[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//迭代n次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= n; p++)&#123;</span><br><span class="line">        <span class="comment">//每次找到最短距离最小且未被更新的t</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[t] &amp;&amp; (t == -<span class="number">1</span> || dist[i] &lt; dist[t]))</span><br><span class="line">                t = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记t点为已更新，加入到S集合中</span></span><br><span class="line">        vis[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用t点作为中间点，更新其他点的最短距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            dist[i] = Math.min(dist[i], dist[t] + w[t][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">时间复杂度O(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<p>堆优化Dijkstra (邻接表)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表，链式前向星存图</span></span><br><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="comment">// dist[x] = y 代表从「源点/起点」到 x 的最短距离为 y</span></span><br><span class="line"><span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="comment">// 记录哪些点已经被更新过</span></span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line"><span class="type">int</span> n, k, idx;</span><br><span class="line"><span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">Arrays.fill(he, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = he[a];</span><br><span class="line">    he[a] = idx;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dijsktra</span><span class="params">()</span>&#123;</span><br><span class="line">    Arrays.fill(dist, INF);</span><br><span class="line">    Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">    dist[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用优先队列存储所有可用于更新的点</span></span><br><span class="line">    <span class="comment">//以(点编号、到起点的距离)进行存储，优先弹出最短距离最小的点</span></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;k, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span>[] poll = pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> poll[<span class="number">0</span>], step = poll[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//如果弹出的点被标记为已更新，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (vis[id]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//标记该点为已更新，并使用该点作为中间点去更新其他点的最短距离</span></span><br><span class="line">        vis[id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[id]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i]; <span class="comment">//点j</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[id] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[id] + w[i]；</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j, dist[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度为O(mlogn + n)</span><br></pre></td></tr></table></figure>



<h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman Ford"></a>Bellman Ford</h4><p>贝尔曼-福特算法</p>
<p>使用条件&amp;范围：单源最短路径， 有向图&amp; 无向图， 边权可正可负</p>
<p>bellman-ford算法进行n-1次更新（一次更新是指用所有节点进行一次松弛操作）来找到到所有节点的单源最短路。bellman-ford算法和dijkstra其实有点相似，该算法能够保证每更新一次都能确定一个节点的最短路，但与dijkstra不同的是，并不知道是那个节点的最短路被确定了，只是知道比上次多确定一个，这样进行n-1次更新后所有节点的最短路都确定了（源点的距离本来就是确定的）。</p>
<p>bellman-ford的一个优势是可以用来判断是否存在负环，在不存在负环的情况下，进行了n-1次所有边的更新操作后每个节点的最短距离都确定了，再用所有边去更新一次不会改变结果。而如果存在负环，最后再更新一次会改变结果。原因是之前是假定了起点的最短距离是确定的并且是最短的，而又负环的情况下这个假设不再成立。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="comment">// dist[x] = y 代表从「源点/起点」到 x 的最短距离为 y</span></span><br><span class="line"><span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="comment">// 记录哪些点已经被更新过</span></span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line"><span class="type">int</span> n, k, idx;</span><br><span class="line"><span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">Arrays.fill(he, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = he[a];</span><br><span class="line">    he[a] = idx;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bf</span><span class="params">()</span>&#123;</span><br><span class="line">    Arrays.fill(dist, INF);</span><br><span class="line">    dist[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//迭代n次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= n; p++)&#123;</span><br><span class="line">        <span class="type">int</span>[] prev = dist.clone();</span><br><span class="line">        <span class="comment">//每次都是用上一次迭代的结果，执行松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= n; a++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[a]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> e[i];</span><br><span class="line">                dist[b] = Math.min(dist[b], dist[a] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度O(n*m), n为顶点数，m为边数</span><br></pre></td></tr></table></figure>



<h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>SPFA算法是Bellman-Ford算法的一种队列实现，减少了不必要的冗余计算。</p>
<p>SPFA对Bellman-Ford算法优化的关键之处在于意识到：<strong>只有那些在前一遍松弛中改变了距离估计值的点，才可能引起他们的邻接点的距离估计值的改变</strong>。因此，算法大致流程是用一个队列来进行维护，即用一个先进先出的队列来存放被成功松弛的顶点。初始时，源点s入队。当队列不为空时，取出队首顶点，对它的邻接点进行松弛。如果某个邻接点松弛成功，且该邻接点不在队列中，则将其入队。经过有限次的松弛操作后，队列将为空，算法结束。SPFA算法的实现，需要用到一个先进先出的队列 queue 和一个指示顶点是否在队列中的标记数组mark。为了方便查找某个顶点的邻接点，图采用临界表存储。</p>
<p> 需要特别注意的是：仅当图不存在负权回路时，SPFA能正常工作。如果图存在负权回路，由于负权回路上的顶点无法收敛，总有顶点在入队和出队往返，队列无法为空，这种情况下SPFA无法正常结束。</p>
<p>例子：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231000822687.png" alt="image-20211231000822687"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231000857568.png" alt="image-20211231000857568"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231000925367.png" alt="image-20211231000925367"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="comment">// dist[x] = y 代表从「源点/起点」到 x 的最短距离为 y</span></span><br><span class="line"><span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="comment">// 记录哪一个点已在队列中</span></span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line"><span class="type">int</span> n, k, idx;</span><br><span class="line"><span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">Arrays.fill(he, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = he[a];</span><br><span class="line">    he[a] = idx;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">spfa</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 起始先将所有的点标记为「未入队」和「距离为正无穷」</span></span><br><span class="line">    Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">    Arrays.fill(dist, INF);</span><br><span class="line">    disk[k] = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 使用「双端队列」存储，存储的是点编号</span></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将「源点/起点」进行入队，并标记「已入队」</span></span><br><span class="line">    deque.addLast(k);</span><br><span class="line">    vis[k] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!deque.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 每次从「双端队列」中取出，并标记「未入队」</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">poll</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">        vis[poll] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 尝试使用该点，更新其他点的最短距离</span></span><br><span class="line">        <span class="comment">// 如果更新的点，本身「未入队」则加入队列中，并标记「已入队」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[poll]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[poll] + w[i]) &#123;</span><br><span class="line">                dist[j] = dist[poll] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">                d.addLast(j);</span><br><span class="line">                vis[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度O(n*m),</span><br><span class="line">通常情况下时间复杂度为O(k*m), k一般为<span class="number">4</span>到<span class="number">5</span>， 最坏情况下仍为 O(n*m)， 当数据为网格图时，复杂度从 O(k*m)退化为  O(n*m)</span><br></pre></td></tr></table></figure>



<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>最小生成树能够保证整个拓扑图的<strong>所有路径之和</strong>最小，但不能保证任意两点之间是最短路径</p>
<p>最短路径是从一点出发，到任一点的路径最小</p>
<p>最小生成树与最短路之间没有太大的关联，只不过一定程度上都用了贪心算法的思想</p>
<p>区别</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231112448525.png"></p>
<p>总结：遇到求所有路径之和最小问题用最小生成树&amp;并查集解决</p>
<p>​			遇到求两点间最短路径的用最短路径解决。</p>
<p>生成树：对连通图进行遍历，过程中多经历的边和顶点的组合可看做是一颗普通树，通常称为生成树。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3406.html">什么是生成树，生成树（生成森林）详解 (biancheng.net)</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231114425823.png" alt="image-20211231114425823"></p>
<p>图b为图a两种生成树。</p>
<p>最小生成树：一个连通图的生成树是一个极小的连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边。那么我们把构造连通网的最小代价生成树称为最小生成树。</p>
<p>找连通网的最小生成树，经典的有两种算法，普里姆算法和克鲁斯卡尔算法。下面分别介绍两种算法。</p>
<h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>普利姆算法</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35644234/article/details/59106779">数据结构–最小生成树详解_William-CSDN博客_最小生成树</a></p>
<p>算法思路：</p>
<p>V是所有定点集合，U为顶点集V的一个非空子集。</p>
<p>首先就是从图中的任一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231214335014.png" alt="image-20211231214335014"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231214240374.png" alt="image-20211231214240374"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231214309266.png" alt="image-20211231214309266"></p>
<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>克鲁斯卡尔算法</p>
<p>算法思路：</p>
<p>（1）将图中的所有边都去掉。<br>（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环<br>（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231214941420.png" alt="image-20211231214941420"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231214956914.png" alt="image-20211231214956914"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211231215120484.png" alt="image-20211231215120484"></p>
<p>&#x3D;&#x3D;Kruskal算法通常是基于并查集来找到最小生成树。&#x3D;&#x3D; 先学会并查集</p>
<p>算法步骤：</p>
<ol>
<li><p>初始化并查集</p>
</li>
<li><p>根据权重对边进行排序</p>
</li>
<li><p>遍历排序后的边，判断该边对应的两个顶点是否连通，然后将其连通，并加入到生成树</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径 - 力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10009</span>;</span><br><span class="line">    <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//记录祖先节点</span></span><br><span class="line">    <span class="type">int</span>[] rank = <span class="keyword">new</span> <span class="title class_">int</span>[N];  <span class="comment">// 记录深度</span></span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 找到i点的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class="line">        <span class="keyword">return</span> parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123; <span class="comment">//将a点与b点连通</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(b);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty)&#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty])</span><br><span class="line">                parent[rootx] = rooty;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty])</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">                rank[rootx]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent[find(a)] = parent[find(b)];</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123; <span class="comment">//判断a点与b点是否连通</span></span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;  <span class="comment">// 将图中的每个点编号存到数组中</span></span><br><span class="line">        <span class="keyword">return</span> x * col + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        row = heights.length;</span><br><span class="line">        col = heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row * col; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// edge 存的是 [a, b, w]：代表从 a 到 b 的体力值为 w</span></span><br><span class="line">        <span class="comment">// 将每条边存到List中，Kruskal是对每一条边的操作</span></span><br><span class="line">        <span class="comment">// 虽然我们可以往四个方向移动，但是只要对于每个点都添加「向右」和「向下」两条边的话，其实就已经覆盖了所有边了</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> getIndex(i, j);</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; row)&#123;  <span class="comment">//向下移动</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> Math.abs(heights[i + <span class="number">1</span>][j] - heights[i][j]);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> idx, b = getIndex(i + <span class="number">1</span>, j);</span><br><span class="line">                    edges.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a, b, w&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; col)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> Math.abs(heights[i][j + <span class="number">1</span>] - heights[i][j]);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> idx, b = getIndex(i, j + <span class="number">1</span>);</span><br><span class="line">                    edges.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a, b, w&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据权值w升序排序</span></span><br><span class="line">        Collections.sort(edges, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据Kruskal算法从权值最小的边开始添加，当添加到包括起点和终点连通时，此时的权值就是最短路径中的权值最大的边</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> getIndex(<span class="number">0</span>, <span class="number">0</span>), end = getIndex(row - <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> edge[<span class="number">0</span>], b = edge[<span class="number">1</span>], w = edge[<span class="number">2</span>];</span><br><span class="line">            union(a, b); <span class="comment">//将a点与b点连通</span></span><br><span class="line">            <span class="keyword">if</span> (query(start, end))</span><br><span class="line">                <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h3 id="遍历图"><a href="#遍历图" class="headerlink" title="遍历图"></a>遍历图</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>深度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, n - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>广度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dx = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">                board[i][<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][m - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, m - <span class="number">1</span>&#125;);</span><br><span class="line">                board[i][m - <span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">                board[<span class="number">0</span>][i] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[n - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n - <span class="number">1</span>, i&#125;);</span><br><span class="line">                board[n - <span class="number">1</span>][i] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] cell = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cell[<span class="number">0</span>], y = cell[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> x + dx[i], my = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || my &lt; <span class="number">0</span> || mx &gt;= n || my &gt;= m || board[mx][my] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;mx, my&#125;);</span><br><span class="line">                board[mx][my] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>适用有向无环图，</p>
<p>拓扑序列是一个有向无环图的所有顶点的线性序列，拓扑排序形成的。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211216102448165.png" alt="image-20211216102448165"></p>
<p>在拓扑排序有环的情况下，会考虑将有向图反向。</p>
<p>应用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态 </a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">eventualSafeNodes</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        List&lt;Integer&gt;[] g = <span class="keyword">new</span> <span class="title class_">List</span>[n];<span class="comment">//邻接表</span></span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">//入度数统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            g[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p : graph[i])&#123;</span><br><span class="line">                g[p].add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            inDegree[i] = graph[i].length;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) <span class="comment">//将入度为零的入队</span></span><br><span class="line">                q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            ans.add(p);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : g[p])&#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[x] == <span class="number">0</span>) <span class="comment">// 入度减一，如果为零入队</span></span><br><span class="line">                    q.offer(x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/loud-and-rich/">851. 喧闹和富有 </a></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f05e8097fa6b">Java8集合框架结构图 - 简书 (jianshu.com)</a></p>
<img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010200053297-163386725577231.png" alt="image-20211010200053297" style="zoom: 200%;" />



<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010201009287-163386781159932.png" alt="image-20211010201009287"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/820406-20160529134155569-877986274.png" alt="img"></p>
<p>Queue被定义成单端队列使用，Deque被定义成双端队列使用。<br>而由于双端队列的定义，Queue只能作为队列或者依赖于子类的实现作为堆使用，Deque可以作为栈或者队列使用。</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p><strong>PriorityQueue</strong>，也叫优先队列，是一个通过完全二叉树实现的小顶堆。其<strong>作用是每次以O(1)取出队列中权值最小的元素,再以O(logn)维护队列</strong></p>
<p>默认无参构造小根堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p>大根堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o2 - o1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);  <span class="comment">//按从大到小排序的优先队列，匿名类</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度</p>
<ul>
<li><p>offer方法用来在数据中添加一个元素，维护的时间复杂度是O(logn)</p>
</li>
<li><p>peek方法直接返回队头的值，所以总的时间复杂度是O(1)</p>
</li>
<li><p>poll方法删除队头元素维护堆的时间是O(logn)</p>
</li>
</ul>
<p>例子：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数 - 力扣</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sequentially-ordinal-rank-tracker/">5937. 序列顺序查询 - 力扣</a></p>
<p>使用大根堆 l 和小根堆 r 两个堆来维护一组数据，保持小根堆的数据总是比大根堆的数据大，可以先将数据放到小根堆，得到首元素（最小的）放到大根堆，也可以先将数据放到大根堆，得到最大的元素再放到小根堆。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127147909">HashMap原理详解，看不懂算我输（附面试题） - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28501879">HashMap底层实现原理（上） - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28587782">HashMap底层实现原理（下） - 知乎 (zhihu.com)</a></p>
<h2 id="Treemap"><a href="#Treemap" class="headerlink" title="Treemap"></a>Treemap</h2><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211009112204988-163374972691124.png" alt="image-20211009112204988"></p>
<p>TreeMap继承于AbstractMap，实现了Map, Cloneable, NavigableMap, Serializable接口。</p>
<p>基本操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span>&#123;</span><br><span class="line">        <span class="comment">//创建TreeMap对象：</span></span><br><span class="line">        TreeMap&lt;String,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后,TreeMap元素个数为：&quot;</span> + treeMap.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新增元素:</span></span><br><span class="line">        treeMap.put(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;world&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;my&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;name&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;is&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;jiaboyan&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;i&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;am&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;a&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;developer&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加元素后,TreeMap元素个数为：&quot;</span> + treeMap.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历元素：</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrySet = treeMap.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : entrySet)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(<span class="string">&quot;TreeMap元素的key:&quot;</span>+key+<span class="string">&quot;,value:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的key：</span></span><br><span class="line">        Set&lt;String&gt; keySet = treeMap.keySet();</span><br><span class="line">        <span class="keyword">for</span>(String strKey:keySet)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TreeMap集合中的key:&quot;</span>+strKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的value:</span></span><br><span class="line">        Collection&lt;Integer&gt; valueList = treeMap.values();</span><br><span class="line">        <span class="keyword">for</span>(Integer intValue:valueList)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TreeMap集合中的value:&quot;</span> + intValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素：</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">getValue</span> <span class="operator">=</span> treeMap.get(<span class="string">&quot;jiaboyan&quot;</span>);<span class="comment">//获取集合内元素key为&quot;jiaboyan&quot;的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">firstKey</span> <span class="operator">=</span> treeMap.firstKey();<span class="comment">//获取集合内第一个元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lastKey</span> <span class="operator">=</span>treeMap.lastKey();<span class="comment">//获取集合内最后一个元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lowerKey</span> <span class="operator">=</span>treeMap.lowerKey(<span class="string">&quot;jiaboyan&quot;</span>);<span class="comment">//获取集合内的key小于&quot;jiaboyan&quot;的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ceilingKey</span> <span class="operator">=</span>treeMap.ceilingKey(<span class="string">&quot;jiaboyan&quot;</span>);<span class="comment">//获取集合内的key大于等于&quot;jiaboyan&quot;的key</span></span><br><span class="line">        SortedMap&lt;String,Integer&gt; sortedMap =treeMap.subMap(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;my&quot;</span>);<span class="comment">//获取集合的key从&quot;a&quot;到&quot;jiaboyan&quot;的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除元素：</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">removeValue</span> <span class="operator">=</span> treeMap.remove(<span class="string">&quot;jiaboyan&quot;</span>);<span class="comment">//删除集合中key为&quot;jiaboyan&quot;的元素</span></span><br><span class="line">        treeMap.clear(); <span class="comment">//清空集合元素：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断方法：</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> treeMap.isEmpty();<span class="comment">//判断集合是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isContain</span> <span class="operator">=</span> treeMap.containsKey(<span class="string">&quot;jiaboyan&quot;</span>);<span class="comment">//判断集合的key中是否包含&quot;jiaboyan&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java集合的时间复杂度"><a href="#Java集合的时间复杂度" class="headerlink" title="Java集合的时间复杂度"></a>Java集合的时间复杂度</h2><ul>
<li><p><strong>ArrayList</strong></p>
<ul>
<li><p>get() 直接读取下标，复杂度 O(1)</p>
</li>
<li><p>add(E) 直接在队尾添加，复杂度 O(1)</p>
</li>
<li><p>add(index, E) 在第n个元素后插入，n后面的元素需要向后移动，复杂度 O(n)</p>
</li>
<li><p>remove() 删除元素后面的元素需要逐个前移，复杂度 O(n)</p>
</li>
</ul>
</li>
<li><p><strong>LinkedList</strong></p>
<ul>
<li><p>addFirst() 添加队列头部，复杂度 O(1)</p>
</li>
<li><p>removeFirst() 删除队列头部，复杂度 O(1)</p>
</li>
<li><p>addLast() 添加队列尾部，复杂度 O(1)</p>
</li>
<li><p>removeLast() 删除队列尾部，复杂度 O(1)</p>
</li>
<li><p>getFirst() 获取队列头部，复杂度 O(1)</p>
</li>
<li><p>getLast() 获取队列尾部，复杂度 O(1)</p>
</li>
<li><p>get() 获取第n个元素，依次遍历，复杂度O(n)</p>
</li>
<li><p>add(E) 添加到队列尾部，复杂度O(1)</p>
</li>
<li><p>add(index, E) 添加到第n个元素后，需要先查找到第n个元素，复杂度O(n)</p>
</li>
<li><p>remove() 删除元素，修改前后元素节点指针，复杂度O(1)</p>
</li>
</ul>
</li>
<li><p><strong>HashSet</strong></p>
<ul>
<li><p>add() 复杂度为 O(1)</p>
</li>
<li><p>remove() 复杂度为 O(1)</p>
</li>
<li><p>contains() 复杂度为 O(1)</p>
</li>
</ul>
</li>
<li><p><strong>TreeSet</strong>(基于红黑树)</p>
<ul>
<li><p>add() 复杂度为 O(log (n))</p>
</li>
<li><p>remove() 复杂度为 O(log (n))</p>
</li>
<li><p>contains() 复杂度为 O(log (n))</p>
</li>
</ul>
</li>
</ul>
<p>TreeMap基于红黑树（一种自平衡二叉查找树）实现的，时间复杂度平均能达到O(log n)。<br>HashMap是基于散列表实现的，时间复杂度平均能达到O(1)。正常是O(1)到O（n） jdk1.8添加了 红黑树 是 O（log n）</p>
<p>TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的。<br>LinkedHashMap的出现就是为了平衡这些因素，能以O(1)时间复杂度查找元素，又能够保证key的有序性</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><strong>按位与运算 （&amp;）</strong></p>
<p>运算规则：0&amp;0&#x3D;0; 0&amp;1&#x3D;0;  1&amp;0&#x3D;0;  1&amp;1&#x3D;1;</p>
<p>即：两位同时为“1”，结果才为“1”，否则为0</p>
<p>例如：3&amp;5 即 0000 0011&amp; 0000 0101 &#x3D; 00000001 因此，3&amp;5的值得1。</p>
<p>另，负数按补码形式参加按位与运算。</p>
<p>“与运算”的特殊用途：</p>
<p>&#x3D;&#x3D;（1）清零。&#x3D;&#x3D;如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p>
<p>&#x3D;&#x3D;（2）取一个数中指定位&#x3D;&#x3D;</p>
<p>方法：找一个数，对应X要取的位，该数的对应位为1，其余位为零，此数与X进行“与运算”可以得到X中的指定位。</p>
<p>例：设X&#x3D;10101110，</p>
<p>   取X的低4位，用 X &amp; 0000 1111 &#x3D; 00001110 即可得到；</p>
<p>   还可用来取X的2、4、6位</p>
<p><strong>按位或运算符（|）</strong></p>
<p>参加运算的两个对象，按二进制位进行“或”运算。</p>
<p>运算规则：0|0&#x3D;0；  0|1&#x3D;1；  1|0&#x3D;1；   1|1&#x3D;1；</p>
<p> 即 ：参加运算的两个对象只要有一个为1，其值为1。</p>
<p>例如:3|5　即 00000011 | 0000 0101 &#x3D; 00000111  因此，3|5的值得7。</p>
<p>&#x3D;&#x3D;（1）常用来将一个数据的某些位置置为1。&#x3D;&#x3D;</p>
<p>方法：找到一个数，对应X要置1的位，该数的对应位为1，其余位为零。此数与X相或可使X中的某些位置1。</p>
<p>例：将X&#x3D;10100000的低4位置1 ，用X | 0000 1111 &#x3D; 1010 1111即可得到。</p>
<p><strong>异或运算符</strong>（^）</p>
<p>参加运算的两个数据，按二进制位进行“异或”运算。</p>
<p>运算规则：0^0&#x3D;0； 0^1&#x3D;1； 1^0&#x3D;1；  1^1&#x3D;0；</p>
<p>  即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p>
<p>“异或运算”的特殊作用：</p>
<p>&#x3D;&#x3D;（1）使特定位翻转&#x3D;&#x3D;，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。</p>
<p>例：X&#x3D;10101110，使X低4位翻转，用X ^0000 1111 &#x3D; 1010 0001即可得到。</p>
<p>&#x3D;&#x3D;（2）与0相异或，保留原值&#x3D;&#x3D; ，X ^ 00000000 &#x3D; 1010 1110。</p>
<p><strong>取反运算符</strong>（~）</p>
<p>参加运算的一个数据，按二进制位进行“取反”运算。</p>
<p>运算规则：~1&#x3D;0； ~0&#x3D;1；</p>
<p>   即：对一个二进制数按位取反，即将0变1，1变0。</p>
<p><strong>左移运算符</strong>（&lt;&lt;）</p>
<p>将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p>
<p>例：a &#x3D; a&lt;&lt; 2将a的二进制位左移2位，右补0，</p>
<p>左移2位后a &#x3D; a * 2 * 2; </p>
<p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p>
<p>**&#x3D;&#x3D;对负数而言，Java负数存储是以补码形式存储的&#x3D;&#x3D;**， <strong>对负数的左移、右移操作都是对负数的补码进行操作的</strong></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211012182644185-163403440611435.png" alt="image-20211012182644185"></p>
<p><strong>右移运算符</strong>（&gt;&gt;）</p>
<p>将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p>
<p>操作数每右移一位，相当于该数除以2。</p>
<p>例如：a &#x3D; a&gt;&gt; 2 将a的二进制位右移2位，十进制来说相当于a除以 2 * 2</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211012184558726-163403556115836.png" alt="image-20211012184558726"></p>
<p><strong>无符号右移</strong> (&gt;&gt;&gt;)</p>
<p>不管正数还是负数，高位都用0补齐</p>
<p>正数的&gt;&gt;&gt;与&gt;&gt;，运算结果是相同的。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211012184953584-163403579466937.png" alt="image-20211012184953584"></p>
<p><strong>复合赋值运算符</strong></p>
<p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p>
<p>&amp;&#x3D;   例：a &amp;&#x3D;b       相当于a&#x3D;a&amp; b</p>
<p>|&#x3D;   例：a |&#x3D;b       相当于a&#x3D;a |b</p>
<p>&gt;&gt;&#x3D; 例：a &gt;&gt;&#x3D;b      相当于a&#x3D;a&gt;&gt; b</p>
<p>&lt;&lt;&#x3D; 例：a&lt;&lt;&#x3D;b      相当于a&#x3D;a&lt;&lt; b</p>
<p>^&#x3D;   例：a ^&#x3D; b      相当于a&#x3D;a^ b  </p>
<h2 id="均匀生成随机数"><a href="#均匀生成随机数" class="headerlink" title="均匀生成随机数"></a>均匀生成随机数</h2><ul>
<li><p>已知 rand_N() 可以等概率的生成[1, N]范围的随机数，那么：<br><em><strong>(rand_X() - 1) × Y + rand_Y()</strong></em> &#x3D;&#x3D;&gt; 可以等概率的生成[1, X * Y]范围的随机数，即实现了 rand_XY()</p>
</li>
<li><p>对于随机数 randN，只要 K 是 N 的约数（或者说 N 是 K 的整数倍），都可以通过 randN 一步得到 randK：<strong>randK &#x3D; (randN % K) + 1</strong>;</p>
</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="一维数组排序"><a href="#一维数组排序" class="headerlink" title="一维数组排序"></a>一维数组排序</h3><p>int类型的一维数组没法添加排序规则，只能单纯的从小到大排序，可以先转成Integer再添加规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arrs = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Arrays.sort(arrs);</span><br><span class="line"></span><br><span class="line">Integer[] integers = Arrays.stream(arrs).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">Arrays.sort(arrs, (a, b) -&gt; b - a);  <span class="comment">//从大到小排序</span></span><br><span class="line">Arrays.sort(arrs, Collections.reverseOrder());	<span class="comment">//从大到小排序</span></span><br></pre></td></tr></table></figure>





<h3 id="二维数组、集合排序"><a href="#二维数组、集合排序" class="headerlink" title="二维数组、集合排序"></a>二维数组、集合排序</h3><p>每一行作为一个整体，按行首的大小从小到大排序，是对二维数组的整体排序，每一行的数据顺序是不变的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">2</span>&#125;,&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">3</span>, <span class="number">1</span>&#125;,&#123;<span class="number">2</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">Arrays.sort(a, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.sort(edges, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">Collections.sort(edges, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] edge1, <span class="type">int</span>[] edge2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edge1[<span class="number">2</span>] - edge2[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="对象排序"><a href="#对象排序" class="headerlink" title="对象排序"></a>对象排序</h3><ul>
<li>对象实现Comparable排序接口，重写compareTo(T o)方法，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li>
<li>实现Comparator是比较接口，实现compare(T o1, T o2)方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortObj</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoForComparable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CutePig</span> <span class="variable">pig1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CutePig</span>(<span class="string">&quot;猪聪明&quot;</span>, <span class="number">18</span>);  <span class="comment">// 第一个对象</span></span><br><span class="line">        <span class="type">CutePig</span> <span class="variable">pig2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CutePig</span>(<span class="string">&quot;猪可爱&quot;</span>, <span class="number">12</span>);  <span class="comment">// 第二个对象</span></span><br><span class="line">        <span class="type">CutePig</span> <span class="variable">pig3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CutePig</span>(<span class="string">&quot;猪能干&quot;</span>, <span class="number">16</span>);  <span class="comment">// 第三个对象</span></span><br><span class="line">        ArrayList&lt;CutePig&gt; pigList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        pigList.add(pig1);</span><br><span class="line">        pigList.add(pig2);</span><br><span class="line">        pigList.add(pig3);</span><br><span class="line">        Collections.sort(pigList);</span><br><span class="line">        System.out.println(<span class="string">&quot;按年龄排序(升序)后结果如下&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CutePig pig : pigList) &#123;</span><br><span class="line">            System.out.println(pig.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SortObj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortObj</span>();</span><br><span class="line">        obj.demoForComparable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CutePig</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;CutePig&gt; &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CutePig</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;name is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;; age is &quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(CutePig other)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age;</span><br><span class="line">            <span class="comment">//大于0，传入的参数小，往前放</span></span><br><span class="line">            <span class="comment">//小于0，传入的参数大，放在后面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoForComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SweetHeart</span> <span class="variable">love1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SweetHeart</span>(<span class="string">&quot;猪可爱&quot;</span>, <span class="string">&quot;pig&quot;</span>);</span><br><span class="line">        <span class="type">SweetHeart</span> <span class="variable">love2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SweetHeart</span>(<span class="string">&quot;哈士奇&quot;</span>, <span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        <span class="type">SweetHeart</span> <span class="variable">love3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SweetHeart</span>(<span class="string">&quot;大火鸡&quot;</span>, <span class="string">&quot;chicken&quot;</span>);</span><br><span class="line">        ArrayList&lt;SweetHeart&gt; loveList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        loveList.add(love1);</span><br><span class="line">        loveList.add(love2);</span><br><span class="line">        loveList.add(love3);</span><br><span class="line">        Collections.sort(loveList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;SweetHeart&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(SweetHeart sweet1, SweetHeart sweet2)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> sweet2.type.compareTo(sweet1.type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );<span class="comment">//匿名类， 可以先定义一个类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;按类型首字母排序(降序)后结果如下&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SweetHeart love : loveList) &#123;</span><br><span class="line">            System.out.println(love.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SortObj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortObj</span>();</span><br><span class="line">        obj.demoForComparator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SweetHeart</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        String type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SweetHeart</span><span class="params">(String name, String type)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;name is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;; type is &quot;</span> + <span class="built_in">this</span>.type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="内置基本类型"><a href="#内置基本类型" class="headerlink" title="内置基本类型"></a>内置基本类型</h3><ol>
<li>byte<ul>
<li>byte数据类型是8位、有符号的，以二进制补码表示的整数；（256个数字），占1字节</li>
<li>最小值是-128（-2^7）；</li>
<li>最大值是127（2^7-1）；</li>
<li>默认值是0；</li>
<li>byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li>
<li>例子：byte a &#x3D; 100，byte b &#x3D; -50。</li>
</ul>
</li>
<li>short<ul>
<li>short数据类型是16位、有符号的以二进制补码表示的整数，占2字节</li>
<li>最小值是-32768（-2^15）；</li>
<li>最大值是32767（2^15 - 1）；</li>
<li>Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是0；</li>
<li>例子：short s &#x3D; 1000，short r &#x3D; -20000。</li>
</ul>
</li>
<li>int<ul>
<li>nt数据类型是32位、有符号的以二进制补码表示的整数；占4字节</li>
<li>最小值是-2,147,483,648（-2^31）；</li>
<li>最大值是2,147,485,647（2^31 - 1）；</li>
<li>一般地整型变量默认为int类型；</li>
<li>默认值是0；</li>
<li>例子：int a &#x3D; 100000, int b &#x3D; -200000。</li>
</ul>
</li>
<li>long<ul>
<li>long数据类型是64位、有符号的以二进制补码表示的整数；占8字节</li>
<li>最小值是-9,223,372,036,854,775,808（-2^63）；</li>
<li>最大值是9,223,372,036,854,775,807（2^63 -1）；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是0L；</li>
<li>例子： long a &#x3D; 100000L，int b &#x3D; -200000L。</li>
</ul>
</li>
<li>float<ul>
<li>float数据类型是单精度、32位、符合IEEE 754标准的浮点数；占4字节   <code>-3.4*E38- 3.4*E38</code>。。。浮点数是有舍入误差的</li>
<li>float在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是0.0f；</li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>例子：float f1 &#x3D; 234.5f。</li>
<li>float f&#x3D;6.26(错误  浮点数默认类型是double类型)</li>
<li>float f&#x3D;6.26F（转换正确，强制）</li>
<li>double d&#x3D;4.55(正确)</li>
</ul>
</li>
<li>double<ul>
<li>double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为double类型；</li>
<li>double类型同样不能表示精确的值，如货币；</li>
<li>默认值是0.0d；</li>
<li>例子：double d1 &#x3D; 123.4。</li>
</ul>
</li>
<li>boolean<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true和false；</li>
<li>这种类型只作为一种标志来记录true&#x2F;false情况；</li>
<li>默认值是false；</li>
<li>例子：boolean one &#x3D; true</li>
</ul>
</li>
<li>char<ul>
<li>char类型是一个单一的16位Unicode字符；用 ‘’表示一个字符。。java 内部使用Unicode字符集。。他有一些转义字符  ，2字节</li>
<li>最小值是’\u0000’（即为0）；</li>
<li>最大值是’\uffff’（即为65,535）；可以当整数来用，它的每一个字符都对应一个数字</li>
</ul>
</li>
</ol>
<h3 id="敏感数字"><a href="#敏感数字" class="headerlink" title="敏感数字"></a>敏感数字</h3><p>int   -2^31  ~~  2^31 - 1  ,  int 占 4 个字节， 32 位，</p>
<p> int 表示的最大整数： 0111 1111 1111 1111 1111 1111 1111 1111   (最高位表示符号位，正数符号位为0)对应的10进制数为2^31-1&#x3D;2147483647，对应的十六进制表示为：0x7FFFFFFF。减去的1 表示+0。</p>
<p>int 表示的最小整数：1000 0000 0000 0000 0000 0000 0000 0000  (最高位表示符号位，负数符号位为1)，负数在计算机中以补码的形式存在，所以对应的原码（补码的补码）也是1000 0000 0000 0000 0000 0000 0000 0000，对应的十六进制表示为0x80000000，该值为-2^31&#x3D;-2147483648。</p>
<p>在二进制中，0的表示有两种，分别为+0和-0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> ： <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">-<span class="number">0</span> ： <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> </span><br></pre></td></tr></table></figure>

<p>因为0只有一个， 便将-0拿来做最小的数，十进制中为 -2147483648 </p>
<p>-0 的补码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> </span><br></pre></td></tr></table></figure>

<p>2^31 &#x3D; 2147483648  10位数  </p>
<p>2^30 &#x3D; 1073741824   10位数    2^30  &gt; 10^9</p>
<p>2^29 &#x3D; 536870912      9位数     2 ^29 &lt;  10^9</p>
<p>如果给的数据不超过10^9的话，可以用0x3f3f3f3f作为无穷大</p>
<p>long类型 19位数</p>
<p>正数的补运算为本身，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机中二进制 101  代表的是5， </span><br><span class="line">计算机中-5的二进制为11111111011， 011为101取反加一得到的， 计算机中负数的二进制为正数的二进制取补（负数的补）运算</span><br></pre></td></tr></table></figure>





<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><ol>
<li><p>自然溢出</p>
<p>对于自然溢出方法，我们定义 Base ，而MOD对于自然溢出方法，就是 unsigned long long 整数的自然溢出（相当于MOD 是 <img src="https://private.codecogs.com/gif.latex?2%5E%7B64%7D%20-%201" alt="2^{64} - 1">)</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/gif-163366594519614.latex" alt="hash[i] = hash[i-1] * Base + idx(s[i])"></p>
</li>
<li><p>单Hash方法</p>
<p><img src="https://private.codecogs.com/gif.latex?hash%5Bi%5D%20=%20(hash%5Bi-1%5D%20*%20Base%20&plus;%20idx(s%5Bi%5D))%20%5C%25%20MOD" alt="hash[i] = (hash[i-1] * Base + idx(s[i])) \% MOD"></p>
</li>
<li><p>双Hash方法</p>
<p>将一个字符串用不同的Base和MOD，hash两次，将这两个结果用一个二元组表示，作为一个总的Hash结果。</p>
<p><img src="https://private.codecogs.com/gif.latex?hash1%5Bi%5D%20=%20(hash1%5Bi-1%5D%20*%20Base1%20&plus;%20idx(s%5Bi%5D))%20%5C%25%20MOD1" alt="hash1[i] = (hash1[i-1] * Base1 + idx(s[i])) \% MOD1"></p>
<p><img src="https://private.codecogs.com/gif.latex?hash2%5Bi%5D%20=%20(hash2%5Bi-1%5D%20*%20Base2%20&plus;%20idx(s%5Bi%5D))%20%5C%25%20MOD2" alt="hash2[i] = (hash2[i-1] * Base2 + idx(s[i])) \% MOD2"></p>
<p>映射的Hash结果为：<img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/gif-163366605544518.latex" alt="&lt;hash1[i], hash2[i]&gt;"></p>
</li>
<li><p>额外增加一个OFFSET，不如双哈希保险</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">OFFSET</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">hash = hash * P + (c - <span class="string">&#x27;a&#x27;</span>) + OFFSET;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>公式：</strong></p>
<p>根据定义分别求出hash[i]<br>hash[1]&#x3D;s1<br>hash[2]&#x3D;s1∗p+s2<br>hash[3]&#x3D;s1∗p2+s2∗p+s3<br>hash[4]&#x3D;s1∗p3+s2∗p2+s3∗p+s4<br>hash[5]&#x3D;s1∗p4+s2∗p3+s3∗p2+s4∗p+s5<br>现在我们想求s3s4的hash值，不难得出为s3∗p+s4,并且从上面观察，如果看hash[4]−hash[2]并将结果种带有s1,s2系数的项全部消掉，<br>就是所求。但是由于p的阶数，不能直接消掉，所以问题就转化成，将hash[2]乘一个关于p的系数，在做差的时候将多余项消除，从而得到结果。</p>
<p>若已知一个<img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211020220205260.png" alt="image-20211020220205260">的字符串的hash值，<img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211020220229413.png" alt="image-20211020220229413">，其子串<img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211020220253565.png" alt="image-20211020220253565">,对应的hash值为：&#x3D;&#x3D;注意字符串存储的下标是从0开始，公式中的r和l为从1开始计数的&#x3D;&#x3D;</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/gif.latex" alt="res = hash[r] - hash[l-1] * Base^{r - l + 1}"></p>
<p>同时，Hash值是要进行取  MOD 的：</p>
<p><img src="https://private.codecogs.com/gif.latex?res%20=%20(hash%5Br%5D%20-%20hash%5Bl-1%5D%20*%20Base%5E%7Br%20-%20l%20&plus;%201%7D)%20%5C%25%20MOD" alt="res = (hash[r] - hash[l-1] * Base^{r - l + 1}) \% MOD"></p>
<p>看起来这个式子人畜无害，但是对于取模运算要谨慎再谨慎，注意到括号里面是减法，即有可能是负数，故做如下的修正：</p>
<p><img src="https://private.codecogs.com/gif.latex?res%20=%20((hash%5Br%5D%20-%20hash%5Bl-1%5D%20*%20Base%5E%7Br%20-%20l%20&plus;%201%7D)%20%5C%25%20MOD%20&plus;%20MOD)%20%5C%25%20MOD" alt="res = ((hash[r] - hash[l-1] * Base^{r - l + 1}) \% MOD + MOD) \% MOD"></p>
<p>至此得到求子串hash值公式。</p>
<p>值得一提的是，如果需要反复对子串求解hash值，预处理Base的n次方效果更佳。所以才有上面用 <img src="https://private.codecogs.com/gif.latex?p%5Bi%5D%20=%20(Base%5Ei)%20%5C%25%20MOD" alt="p[i] = (Base^i) \% MOD"> ，也是有取余数的。<br>base 一般为131或13331.</p>
<p>例子</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e5</span>+<span class="number">10</span>, P = <span class="number">131313</span>;</span><br><span class="line">    <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[N], p = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            h[i] = h[i - <span class="number">1</span>] * P + s.charAt(i - <span class="number">1</span>);</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + <span class="number">10</span> - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">10</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> h[j] - h[i - <span class="number">1</span>] * p[j - i + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.getOrDefault(hash, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) ans.add(s.substring(i - <span class="number">1</span>, i + <span class="number">10</span> - <span class="number">1</span>));</span><br><span class="line">            map.put(hash, cnt + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211223113726513.png" alt="image-20211223113726513"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-string-match/">686. 重复叠加字符串匹配 - 力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">repeatedStringMatch</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sb.length() &lt; b.length() &amp;&amp; ++ans &gt; <span class="number">0</span>) sb.append(a);</span><br><span class="line">        sb.append(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> strHash(sb.toString(), b);</span><br><span class="line">        <span class="keyword">if</span> (idx == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> idx + b.length() &gt; a.length() * ans ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">strHash</span><span class="params">(String ss, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">P</span> <span class="operator">=</span> <span class="number">131</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ss.length(), m = b.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> ss + b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">10</span>], p = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">10</span>];</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            p[i + <span class="number">1</span>] = p[i] * P;</span><br><span class="line">            h[i + <span class="number">1</span>] = h[i] * P + str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> len, l = r - m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>]; <span class="comment">// b 的哈希值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + m - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> h[j] - h[i - <span class="number">1</span>] * p[j - i + <span class="number">1</span>]; <span class="comment">// 子串哈希值</span></span><br><span class="line">            <span class="keyword">if</span> (cur == target) <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211008192109399-163369207075623.png" alt="image-20211008192109399"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211008201332453.png" alt="image-20211008201332453"></p>
<ol>
<li><p>例一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;aooooooooooooooooooooooooooob&quot;</span>;</span><br><span class="line"><span class="comment">// String reg = &quot;ao?b&quot;;</span></span><br><span class="line"><span class="comment">// String reg = &quot;ao&#123;4&#125;b&quot;;</span></span><br><span class="line"><span class="comment">// String reg = &quot;ao&#123;4,&#125;b&quot;;</span></span><br><span class="line"><span class="comment">// String reg = &quot;ao&#123;4,6&#125;b&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;ao+b&quot;</span>;</span><br><span class="line"><span class="comment">// String reg = &quot;ao*b&quot;;</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(reg);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;15804901111&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;1[358][0-9]&#123;9&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// String regex = &quot;1[358]\\d&#123;9&#125;&quot;;</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> tel.matches(regex);</span><br><span class="line">System.out.println(tel + <span class="string">&quot; : &quot;</span> + b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>例二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String str1 = &quot;zhangsan xiaoqiang  zhaoliu&quot;;</span></span><br><span class="line"><span class="comment">// String str2 = &quot;zhangsan.xiaoqiang.zhaoliu&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;zhangsanttttxiaoqiangmmmmmmzhaoliu&quot;</span>;<span class="comment">//组</span></span><br><span class="line"><span class="comment">// String[] names = str1.split(&quot; &quot;);</span></span><br><span class="line"><span class="comment">// String [] names = str1.split(&quot; +&quot;);</span></span><br><span class="line"><span class="comment">//  String [] names = str2.split(&quot;\\.&quot;);  //.需要转义，不然识别为正则表达式的规则字符</span></span><br><span class="line">String [] names = str3.split(<span class="string">&quot;(.)\\1+&quot;</span>);  <span class="comment">//组  \\1 表示引用第一个括号中匹配的字符，是相同的字符  \\2 表示引用第二个括号匹配到的字符</span></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>例三</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;da jia hao,ming tian bu fang jia&quot;</span>;</span><br><span class="line"><span class="comment">//String regex = &quot;[a-z]&#123;3&#125;&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\b[a-z]&#123;3&#125;\\b&quot;</span>;<span class="comment">//  单词边界 \\b</span></span><br><span class="line"><span class="comment">//1、将正则规则进行对象的封装</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="comment">//2、通过正则对象获取匹配器对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line"><span class="comment">//3、使用Matcher对象的方法对字符串进行操作。</span></span><br><span class="line"><span class="comment">// 既然要获取三个字母组成的单词</span></span><br><span class="line"><span class="comment">// 查找find();</span></span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">	System.out.println(m.group());<span class="comment">//获取匹配的子序列</span></span><br><span class="line">	System.out.println(m.start()+<span class="string">&quot; : &quot;</span>+m.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>例四</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ipstr</span> <span class="operator">=</span> <span class="string">&quot;192.168.10.55 127.0.0.1 3.3.3.3 105.7.11.65&quot;</span>;</span><br><span class="line"><span class="comment">// 1.为了让ip可以按照字符串顺序比较，只要让ip的每一段的位数相同。</span></span><br><span class="line"><span class="comment">// 所以，补零，按照每一位所需做多0进行补充，每一段都加两个0.</span></span><br><span class="line">ipstr = ipstr.replaceAll(<span class="string">&quot;(\\d+)&quot;</span>, <span class="string">&quot;00$1&quot;</span>); <span class="comment">//替换中匹配第一个括号的内容</span></span><br><span class="line">System.out.println(ipstr);</span><br><span class="line"><span class="comment">//00192.00168.0010.0055 00127.000.000.001 003.003.003.003 00105.007.0011.0065</span></span><br><span class="line"><span class="comment">// 然后每一段保留数字3位</span></span><br><span class="line">ipstr = ipstr.replaceAll(<span class="string">&quot;0*(\\d&#123;3&#125;)&quot;</span>, <span class="string">&quot;$1&quot;</span>);</span><br><span class="line">System.out.println(ipstr);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><strong>继承</strong></p>
<p>指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性；</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010135633357-163384539461825.png" alt="image-20211010135633357"></p>
<p><strong>实现</strong></p>
<p>指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性；</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010135717860-163384543916126.png" alt="image-20211010135717860"></p>
<p><strong>依赖</strong></p>
<p>可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用；</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010135807132-163384548898227.png" alt="image-20211010135807132"></p>
<p><strong>关联</strong></p>
<p>他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量；</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010135937456-163384557836428.png" alt="image-20211010135937456"></p>
<p><strong>聚合</strong></p>
<p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010140026629-163384562796529.png" alt="image-20211010140026629"></p>
<p><strong>组合</strong></p>
<p>组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211010140127764-163384568909430.png" alt="image-20211010140127764"></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/the_zed/article/details/105126583">并查集</a></p>
<p>其中定义三个私有变量 ：一个是parent数组，记录当前位置节点对应的父亲节点 ；一个是rand数组，其记录了当前节点下面树的深度，以此优化路径；最后是count，记录当前有多少个集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] rank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span>&#123;  <span class="comment">// n个元素</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n; i++)&#123;</span><br><span class="line">    		parent[i] = i;	 <span class="comment">//每个结点的上级都是自己 </span></span><br><span class="line">    		rank[i] = <span class="number">1</span>; 	<span class="comment">//每个结点构成的树的高度为 1 </span></span><br><span class="line">    		count++;	<span class="comment">//记录集合个数----非连通</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;	<span class="comment">//查找结点i的根结点   路径压缩</span></span><br><span class="line">   		<span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);	<span class="comment">//递归，将路径上的节点的parent的值置为root根节点</span></span><br><span class="line">    	<span class="keyword">return</span> parent[i];	<span class="comment">// 返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;  <span class="comment">// 合并两个节点， 按秩(深度)合并，同时应用了路径压缩</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;	<span class="comment">//如果rootx的高度大于rooty的高度，则令rooty的上级为rootx</span></span><br><span class="line">        		parent[rooty] = rootx;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">        		parent[rootx] = rooty;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		parent[rooty] = rootx;</span><br><span class="line">        		rank[rootx] += <span class="number">1</span>;	<span class="comment">//如果rootx与rooty的高度相同，指定一个为上级，并将树高度加一</span></span><br><span class="line">        	&#125;</span><br><span class="line">        	--count;	<span class="comment">//连通，count减一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/">1697. 检查边长度限制的路径是否存在 - 力扣（Leetcode）</a></p>
<p>离线并查集</p>
<p>「离线」的意思是，对于一道题目会给出若干询问，而这些询问是全部提前给出的，也就是说，你不必按照询问的顺序依次对它们进行处理，而是可以按照某种顺序（例如全序、偏序（拓扑序）、树的 DFS 序等）或者把所有询问看成一个整体（例如整体二分、莫队算法等）进行处理。</p>
<p>与「离线」相对应的是「在线」思维，即所有的询问是依次给出的，在返回第 k 个询问的答案之前，不会获得第 k+1 个询问。</p>
<p>实际上，力扣平台上几乎所有的题目都是「离线」的，即一次性给出所有的询问。但在大部分情况下，我们按照下标顺序处理这些询问是没有问题的，也就是用「在线」的思维在「离线」的场景下解决问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] distanceLimitedPathsExist(<span class="type">int</span> n, <span class="type">int</span>[][] edgeList, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        Arrays.sort(edgeList, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        Integer[] index = <span class="keyword">new</span> <span class="title class_">Integer</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.length; i++)</span><br><span class="line">            index[i] = i;</span><br><span class="line">        Arrays.sort(index, (a, b) -&gt; queries[a][<span class="number">2</span>] - queries[b][<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] res = <span class="keyword">new</span> <span class="title class_">boolean</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : index)&#123;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; edgeList.length &amp;&amp; edgeList[k][<span class="number">2</span>] &lt; queries[i][<span class="number">2</span>])&#123;</span><br><span class="line">                union(parent, rank, edgeList[k][<span class="number">0</span>], edgeList[k][<span class="number">1</span>]);</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = find(parent, queries[i][<span class="number">0</span>]) == find(parent, queries[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x)</span><br><span class="line">            parent[x] = find(parent, parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span>[] rank, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(parent, x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(parent, y);</span><br><span class="line">        <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty])&#123;</span><br><span class="line">            parent[rootx] = rooty;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty])&#123;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            rank[rootx]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>最基本</p>
<p>写法一：</p>
<p>闭区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123; low = mid + <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123; high = mid - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法二：</p>
<p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上发现的其他写法：</p>
<p>依据mid是取上界还是下界<strong>（推荐使用的二分模板）</strong></p>
<p>模板一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = （left + right) &gt;&gt; <span class="number">1</span>; <span class="comment">//取下界，找的是最前出现等于目标值的元素</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = （left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">//取上界，找的是最后出现等于目标值的元素；  若没有相等的元素，取得是前面哪一个元素：2,5，8 target为6，取得是5</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数 - 力扣（LeetCode）</a></p>
<hr>
<p>有重复元素时，寻找第一个等于目标值的元素位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstOccurrence</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123; low = mid + <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123; high = mid - <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[low] == target) <span class="keyword">return</span> low;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有重复元素时，寻找最后一个等于目标值的元素位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LastOccurrence</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123; low = mid + <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123; high = mid - <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[high] == target) <span class="keyword">return</span> high;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Arrays-binarySearch-方法"><a href="#Arrays-binarySearch-方法" class="headerlink" title="Arrays.binarySearch()方法"></a><code>Arrays.binarySearch()</code>方法</h3><p>Arrays类的binarySearch()方法，可以使用二分搜索法来搜索指定的数组，以获得指定对象。该方法返回要搜索元素的索引值。务必注意：&#x3D;&#x3D;数组必须经过排序才可以使用此方法，否则返回下标显示不准&#x3D;&#x3D;。</p>
<ul>
<li><p><code>binarySearch(Object[] a, Object key)</code></p>
<p>a: 要搜索的数组</p>
<p>key：要搜索的值</p>
<p>如果key在数组中，则返回搜索值的索引；否则返回-1或“-”（插入点）。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素的索引。</p>
<p>技巧：</p>
<p>[1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”；</p>
<p>[2] 搜索值是数组元素，从0开始计数，得搜索值的索引值；</p>
<p>[3] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1；</p>
<p>[4] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1);</p>
<p>总结：如果返回值ret为正数，则ret为key在数组a中的位置，如果ret为负数，则数组中不存在key，<code>~ret</code>  或  <code>-ret-1</code>  为key在数组a中的应该插入的位置</p>
</li>
<li><p><code>binarySearch(Object[] a, int fromIndex, int toIndex, Object key)</code></p>
<p>a：要搜索的数组</p>
<p>fromIndex：指定范围的开始处索引（包含）</p>
<p>toIndex：指定范围的结束处索引（不包含）</p>
<p>key：要搜索的值</p>
<p>如果要搜索的元素key在指定的范围内，则返回搜索值的索引；否则返回-1或“-”（插入点）。</p>
<p>技巧：</p>
<p>[1] 该搜索键在范围内，但不是数组元素，由1开始计数，得“ - 插入点索引值”；</p>
<p>[2] 该搜索键在范围内，且是数组元素，由0开始计数，得搜索值的索引值；</p>
<p>[3] 该搜索键不在范围内，且小于范围（数组）内元素，返回–(fromIndex + 1)；</p>
<p>[4] 该搜索键不在范围内，且大于范围（数组）内元素，返回 –(toIndex + 1)。</p>
</li>
</ul>
<h2 id="快速幂、-快速乘"><a href="#快速幂、-快速乘" class="headerlink" title="快速幂、 快速乘"></a>快速幂、 快速乘</h2><p><strong>快速幂</strong></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211012112913057-163400935503033.png" alt="image-20211012112913057"></p>
<p>6 &#x3D; 110</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fastPower</span><span class="params">(<span class="type">long</span> base,<span class="type">long</span> power)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((power&amp;<span class="number">1</span>) == <span class="number">1</span>)<span class="comment">//此处等价于if(power%2==1)</span></span><br><span class="line">            result=(result*base)%<span class="number">1000</span>;</span><br><span class="line">        power&gt;&gt;=<span class="number">1</span>;<span class="comment">//此处等价于power=power/2</span></span><br><span class="line">        base=(base * base)%<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>快速乘</strong>（倍增乘）</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211012152413247-163402345536334.png" alt="image-20211012152413247"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> p)</span> &#123;  <span class="comment">//计算x乘y的积</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;                    <span class="comment">//加法初始化</span></span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (res + x) % p;  <span class="comment">//模仿二进制</span></span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) % p;  <span class="comment">//将x不断乘2达到二进制</span></span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倍增乘的逆   求b （不能使用 * 和 &#x2F; ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">求c/a</span><br><span class="line"><span class="type">int</span> <span class="title function_">mulInverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt;= c)&#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a, count = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span> (tmp + tmp &lt;= c)&#123;</span><br><span class="line">    		tmp = tmp &lt;&lt; <span class="number">1</span>;			<span class="comment">//相当于 a*2的k次方</span></span><br><span class="line">    		count = count &lt;&lt; <span class="number">1</span>;		<span class="comment">//相当于 2的k次方</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	c -= tmp;		<span class="comment">// 依次减去最大的 a*2的k次方</span></span><br><span class="line">    	ans += count;	<span class="comment">// 将得到的 2的k次方 相加，和为b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2)减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置，而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。</p>
<h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器 - 力扣（包含+-以及括号）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II - 力扣（包含+-*&#x2F; ）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzr2018xzy/article/details/100168335">772 基本计算器III（包含+-*&#x2F; 以及括号）</a></p>
<h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素 - 力扣</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II - 力扣</a></p>
<p><strong>一个数组中某个元素出现次数超过 n &#x2F; k的数最多只有 k - 1个。否则必然违背「数总共只有 n个」或者「当前统计的是出现次数超过 n &#x2F; k的数」的前提条件</strong></p>
<p>当明确了符合要求的数的数量之后，我们可以使用有限变量来代表这 k - 1个候选数及其出现次数。</p>
<p>然后使用「摩尔投票」的标准做法，在建立数组时同时 check 这 k - 1 个数，假设当前遍历到的元素为 x：</p>
<ul>
<li>如果 x本身是候选者的话，则对其出现次数加一；</li>
<li>如果 x 本身不是候选者，检查是否有候选者的出现次数为 0：<ul>
<li>若有，则让 x 代替其成为候选者，并记录出现次数为 1；</li>
<li>若无，则让所有候选者的出现次数减一。</li>
</ul>
</li>
<li>当处理完整个数组后，这 k - 1 个数可能会被填满，但不一定都是符合出现次数超过 n &#x2F; k 要求的。</li>
<li>需要进行二次遍历，来确定候选者是否符合要求，将符合要求的数加到答案。</li>
</ul>
<p>上述做法正确性的关键是：若存在出现次数超过 n &#x2F; k 的数，最后必然会成为这 k - 1个候选者之一。</p>
<p>我们可以通过「反证法」来进行证明：若出现次数超过 n &#x2F; k的数 x 最终没有成为候选者。</p>
<p>有两种可能会导致这个结果：</p>
<ol>
<li><p>数值 x 从来没成为过候选者：</p>
<p>如果 x 从来没成为过候选者，那么在遍历 xx 的过程中，必然有 k - 1 个候选者被减了超过 n &#x2F; k 次，假设当前 x 出现次数为 C，已知 C &gt; n &#x2F; k，此时总个数为</p>
<p>(k - 1) * C + C &#x3D; C * k</p>
<p>再根据 C &gt; n &#x2F; kC&gt;n&#x2F;k，可知 C * k &gt; nC∗k&gt;n，而我们总共就只有 nn 个数，因此该情况恒不成立。</p>
</li>
<li><p>数值 x 成为过候选者，但被逐出替换了：</p>
<p>同理，被逐出替换，说明发生了对 x 出现次数减一的动作（减到 0），每次的减一操作，意味着有其余的 k - 2 个候选者的出现次数也发生了减一动作，加上本身被遍历到的当前数 num[i]，共有 k - 1 个数字的和 x 被一同统计。<br>因此，根据我们摩尔投票的处理过程，如果 xx 成为过候选者，并被逐出替换，那么同样能够推导出我们存在超过 n 个数。</p>
</li>
</ol>
<p>综上，如果存在出现次数超过 n &#x2F; k 的数，其必然会成为 k - 1个候选者之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vote1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vote2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123; <span class="comment">//如果该元素为第一个元素，则计数加1</span></span><br><span class="line">                vote1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123; <span class="comment">//如果该元素为第二个元素，则计数加1</span></span><br><span class="line">                vote2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote1 == <span class="number">0</span>) &#123; <span class="comment">// 选择第一个元素</span></span><br><span class="line">                element1 = num;</span><br><span class="line">                vote1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 == <span class="number">0</span>) &#123; <span class="comment">// 选择第二个元素</span></span><br><span class="line">                element2 = num;</span><br><span class="line">                vote2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果三个元素均不相同，则相互抵消1次</span></span><br><span class="line">                vote1--;</span><br><span class="line">                vote2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测元素出现的次数是否满足要求</span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; cnt1 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">            ans.add(element1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; cnt2 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">            ans.add(element2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象BST（二叉搜索树）"><a href="#抽象BST（二叉搜索树）" class="headerlink" title="抽象BST（二叉搜索树）"></a>抽象BST（二叉搜索树）</h2><p>矩阵的元素从其中一个方向看去，一边比它大，另一边比它小。在这个矩阵中查找某个元素时，即可从这个方向的定点出发，进行左右移动，即可找到该元素。时间复杂度为O(m+n)。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-y1ns/"> 240. 搜索二维矩阵 II</a></p>
<h2 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><p>在一个文本或者较长的一段字符串(主串)中，找出一个或多个指定字符串(模式串)，并返回其位置</p>
<h3 id="1-BF"><a href="#1-BF" class="headerlink" title="1. BF"></a>1. BF</h3><p>最传统的算法，从目标字符串初始位置开始，依次分别与<em>Pattern</em>的各个位置的字符比较，如相同，比较下一个位置的字符直至完全匹配；如果不同则跳到目标字符串下一位置继续如此与<em>Pattern</em>比较，直至找到匹配字符串并返回其位置。</p>
<p>时间复杂度为O(mn)</p>
<h3 id="2-RK算法（哈希算法的应用）"><a href="#2-RK算法（哈希算法的应用）" class="headerlink" title="2. RK算法（哈希算法的应用）"></a>2. RK算法（哈希算法的应用）</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46272350/article/details/120671730">RK算法</a></p>
<p>通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后与模式串的哈希值进行比较。如果某个子串的哈希值等于模式串，那就说明子串与模式串相匹配(暂时不讨论哈希冲突的问题)。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串的比对的效率就提高了。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027174001667.png" alt="image-20211027174001667"></p>
<p>尽管借助了哈希值，模式串与子串比对的效率提高了，不过通过哈希算法计算子串哈希值的过程，需要遍历子串中的每个字符，这个过程就比较耗时。也就是说，整体的效率并没有提高。</p>
<p>如果假设主串和模式串对应的字符集只包含K个字符，我们可以用一个K进制数来表示一个子串，把K进制数转换为十进制数，作为子串的哈希值。现在看看这个例子。</p>
<p>例如：要处理的字符串只包含a到z这26个小写字母，那么我们就用26进制来表示一个子串，我们把a到z这26个字符映射到0到25这26个数字，如下图一样，计算哈希值时，相对于十进制字符串，我们只需要把进位从10改为26.</p>
<p>上面说的哈希算法有一个特点：在主串中，相邻两个子串哈希值的计算公式有一顶的关系。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027174133024.png" alt="image-20211027174133024"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027174157027.png" alt="image-20211027174157027"></p>
<p>上图是相邻子串哈希值的计算。</p>
<p>通过这个例子，我们可以得出这样的规律：相邻子串s[i-1]和s[i]对应的哈希值计算公式有交集，也就是说，我们可以使用s[i-1]的哈希值快速的计算出s[i]的哈希值。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027180128426.png" alt="image-20211027180128426"></p>
<p>不过，这里有一个小细节需要注意，那就是 26^(m-1) 这部分的计算，我们可以通过查表 的方法来提高效率。我们事先计算好 26^0、26^1、26^2……26^(m-1)，并且存n储在一个 长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方 的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p>
<p>性能分析</p>
<p>RK算法耗时的逻辑主要包含两个部分：计算子串的哈希值和比较模式串与子串的哈希值。对于计算字串的哈希值，我们可以设计特殊的哈希算法，只需要扫描一遍主串就能得到所以子串的哈希值，因此，这一部分的时间复杂度为O(n)。对于比较模式串与子串的哈希值，这部分的时间复杂度也为O(n)。综合起来，RK算法的时间复杂度为O(n)。这个时候可能还会出现一个问题，图个模式串很长，相对应的主串中的子串也很长，那么通过上面计算出的哈希值可能就会很大，如果哈希值超过了计算机整型类型可以表示的范围，那又应该怎么办呢？</p>
<p>实际上，前面设计的基于二十六进制的哈希算法是没有哈希冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样，十六进制字符串对应的十进制也是不会有冲突的。不过，对于模式串很长的情况下，为了能将哈希值落在整形数据表示的范围内，存在哈希冲突也是可以接收的，那么此时又该怎么设计哈希算法呢？</p>
<p>哈希算法的设计方法有很多，我举一个例子说明一下。假设字符串中只包含 a～z 这 26 个 英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希 算法产生的哈希值的数据范围就相对要小很多了。<br>不过，你也应该发现，这种哈希算法的哈希冲突概率也是挺高的。当然，我只是举了一个最 简单的设计方法，还有很多更加优化的方法，比如将每一个字母从小到大对应一个素数，而 不是 1，2，3……这样的自然数，这样冲突的概率就会降低一些。那现在新的问题来了。之前我们只需要比较一下模式串和子串的哈希值，如果两个值相等，<br>那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情 况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。<br>实际上，解决方法很简单。当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我 们只需要再对比一下子串和模式串本身就好了。当然，如果子串的哈希值与模式串的哈希值 不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。 所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的 时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模 式串本身，那时间复杂度就会退化成 O(n*m)。但也不要太悲观，一般情况下，冲突不会很 多，RK 算法的效率还是比 BF 算法高的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabinKarp</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设只匹配字母，所以d等于26</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 主串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rabinKarp</span><span class="params">(String str, String pattern)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> pattern.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哈希时需要用到进制计算，这里只涉及26个字母所以使用26进制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">        <span class="comment">//防止hash之后的值超出int范围，对最后的hash值取模</span></span><br><span class="line">        <span class="comment">//q取随机素数，满足q*d &lt; INT_MAX即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">144451</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//str子串的hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">strCode</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//pattern的hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">patternCode</span> <span class="operator">=</span> pattern.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//d的size2-1次幂，hash计算时，公式中会用到</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算sCode、pCode、h</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size2; i++) &#123;</span><br><span class="line">            patternCode = (d*patternCode + pattern.charAt(i)-<span class="string">&#x27;a&#x27;</span>) % q;</span><br><span class="line">            <span class="comment">//计算str第一个子串的hash</span></span><br><span class="line">            strCode = (d*strCode + str.charAt(i)-<span class="string">&#x27;a&#x27;</span>) % q;</span><br><span class="line">            h = (h*d) % q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大需要匹配的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> size1 - size2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//字符串开始匹配，对patternCode和strCode开始比较，并更新strCode的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; frequency; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strCode == patternCode &amp;&amp; ensureMatching(i, str, pattern))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新strCode的值，即计算str[i+1,i+m-1]子串的hashCode</span></span><br><span class="line">            strCode = ((strCode - h*(str.charAt(i)-<span class="string">&#x27;a&#x27;</span>))*d + str.charAt(i+size2) - <span class="string">&#x27;a&#x27;</span>) % q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash值一样并不能完全确保字符串一致，所以还需要进一步确认</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i hash值相同时字符串比对的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">ensureMatching</span><span class="params">(<span class="type">int</span> i, String str, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">strSub</span> <span class="operator">=</span> str.substring(i, i+pattern.length());</span><br><span class="line">        <span class="keyword">return</span> strSub.equals(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcabcabc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;cabc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次出现的位置:&quot;</span> + rabinKarp(str, pattern));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-KPM"><a href="#3-KPM" class="headerlink" title="3. KPM"></a>3. KPM</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yjiyjige/p/3263858.html">详解KMP算法</a></p>
<p>利用已经匹配的有效信息，保持主串的i指针不动，通过修改j指针，让模式串尽量的移动到有效位置。</p>
<p>由模式串得到next数组，由next数组去匹配</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211026162034900.png" alt="image-20211026162034900"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211026162114426.png" alt="image-20211026162114426"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211026162215288.png" alt="image-20211026162215288"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211026162230601.png" alt="image-20211026162230601"></p>
<p>next数组作用：寻找j指针前面字符串的最长公共前后缀，当i与j不等时，直接将前缀移到后缀的位置，i指针不动，j改变。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jb411V78H?from=search&seid=10701160656249682267&spm_id_from=333.337.0.0">手算next数组</a></p>
<p>next数组的代码理解： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16X4y137qw?from=search&seid=10701160656249682267&spm_id_from=333.337.0.0">next数组代码理解</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211026163421707.png" alt="image-20211026163421707"></p>
<p>例如求next[17] ,比较next[16] 与next[8], 再比较next[4]与next[16], 再比较next[2] 与next[16],  最终会得到next[17],即模式串坐标17前面的最长公共前后缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] getNext(string sub)    <span class="comment">// next数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[sub.length()];	<span class="comment">//此处建立的next数组从下标0开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">           next[++j] = ++k;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           k = next[k];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后的next数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] getNext(string sub)    <span class="comment">// next数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[sub.length()];	<span class="comment">//此处建立的next数组从下标0开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; sub.length() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || sub[i] == sub[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sub[++i] == sub[++j])</span><br><span class="line">                next[i] = next[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">int</span> []next, string data, string sub)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sub.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//主串的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//模式串的位置</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || data[i] == sub[j])   <span class="comment">// 当j为-1时，要移动的是i，当然j也要归0</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(m + n),</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211026164110705.png" alt="image-20211026164110705"></p>
<h3 id="4-BM"><a href="#4-BM" class="headerlink" title="4. BM"></a>4. BM</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/DBC_121/article/details/105569440?ops_request_misc=%7B%22request_id%22:%22163523794016780255264520%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163523794016780255264520&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105569440.first_rank_v2_pc_rank_v29&utm_term=BM%E7%AE%97%E6%B3%95+&spm=1018.2226.3001.4187">学习BM算法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21201267/article/details/92799488?ops_request_misc=&request_id=&biz_id=102&utm_term=BM%E7%AE%97%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-92799488.nonecase&spm=1018.2226.3001.4187"> 字符串匹配算法（BM) </a></p>
<p>模式串与主串比较时，是从左向右比较</p>
<p>两个规则：</p>
<ul>
<li><p>坏字符规则： 后移位数 &#x3D;  坏字符在模式串中的当前位置   -   坏字符在模式串中最右出现的位置  。如果坏字符不包含在模式串中，则设置最右出现的位置为 -1。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027163422788.png" alt="image-20211027163422788"></p>
<ul>
<li>利用<strong>坏字符规则</strong>，BM算法在最好情况下的时间复杂度非常低，是O（n&#x2F;m）。比如，主串是aaabaaabaaabaaab，模式串是aaaa。每次比对，模式串都可以直接后移四位，所以，匹配<strong>具有类似特点</strong>的模式串和主串的时候，BM算法非常高效。</li>
<li>单纯使用坏字符规则还是不够的。因为根据 si-xi计算出来的<strong>移动位数</strong>，<strong>有可能是负数</strong>，比如主串是aaaaaaaaaaaaaaaa，模式串是baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM算法还需要用到“好后缀规则”。</li>
</ul>
</li>
<li><p>好后缀规则：当字符匹配失败时，后移位数 &#x3D;  好后缀的位置 -  模式串中上一次出现的位置，如果好后缀在模式串中没有再次出现，则为 -1。</p>
<ol>
<li><p>“好后缀”的位置以最后一个字符为准。假定”ABCDEF”的”EF”是好后缀，则它的位置以”F”为准，即5（从0开始计算）。</p>
</li>
<li><p>如果”好后缀”在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，”EF”在”ABCDEF”之中只出现一次，则它的上一次出现位置为-1（即未出现）</p>
</li>
<li><p>如果”好后缀”有多个，则除了最长的那个”好后缀”，其他”好后缀”的上一次出现位置必须在头部。比如，假定”BABCDAB”的”好后缀”是”DAB”、”AB”、”B”，请问这时”好后缀”的上一次出现位置是什么？回答是，此时采用的好后缀是”B”，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个”好后缀”只出现一次，则可以把搜索词改写成如下形式进行位置计算”(DA)BABCDAB”，即虚拟加入最前面的”DA”。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027170107239.png" alt="image-20211027170107239"></p>
</li>
</ol>
</li>
</ul>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027180325885.png" alt="image-20211027180325885"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027180349080.png" alt="image-20211027180349080"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027170214940.png" alt="image-20211027170214940"></p>
<p>代码：待整理</p>
<p>时间复杂度分析：</p>
<p>最好情况时间复杂度可以达到O(n&#x2F;m), 最坏不会超过3n</p>
<h3 id="5-Sunday算法"><a href="#5-Sunday算法" class="headerlink" title="5. Sunday算法"></a>5. Sunday算法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q547550831/article/details/51860017">字符串匹配——Sunday算法</a></p>
<p>与BM算法相似，不过Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末尾字符串的下一位字符。</p>
<ol>
<li><p>如果该字符没有在模式串中出现则直接跳过，即移动位数 &#x3D; 模式串长度 + 1；</p>
</li>
<li><p>否则，其移动位数 &#x3D; 模式串长度 - 该字符最右出现的位置(以0开始) &#x3D; 模式串中该字符最右出现的位置到尾部的距离 + 1。</p>
<p>例子：</p>
</li>
</ol>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027183102439.png" alt="image-20211027183102439"></p>
<p>结果发现在第2个字符处发现不匹配，不匹配时关注主串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 &#x3D; 匹配串长度 + 1 &#x3D; 6 + 1 &#x3D; 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027183207062.png" alt="image-20211027183207062"></p>
<p>结果第一个字符就不匹配，再看主串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（m - 3 &#x3D; 6 - 3 &#x3D; r 到模式串末尾的距离 + 1 &#x3D; 2 + 1 &#x3D;3），使两个’r’对齐，如下</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027183238185.png" alt="image-20211027183238185"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sunday</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断子串中是否存在末尾下一个位置对应的父串的字符</span></span><br><span class="line"><span class="comment">     * 每次从后往前匹配，为了不遗漏可能的匹配，应该是跳到使得子串中最右一个字符与父串中的该字符对应，</span></span><br><span class="line"><span class="comment">     * 这样跳过的距离最小，且是安全的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">contains</span><span class="params">(<span class="type">char</span>[] sonArray, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sonArray.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sonArray[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String father, String son)</span> &#123;</span><br><span class="line">        <span class="comment">//这里转为char数组要更方便些</span></span><br><span class="line">        <span class="type">char</span>[] fatherArray = father.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] sonArray = son.toCharArray();</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> <span class="variable">fatherLength</span> <span class="operator">=</span> fatherArray.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sonLength</span> <span class="operator">=</span> sonArray.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//+ j是可能会出现最后一次移动father剩余长度与son长度不一致的情况</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= fatherLength - sonLength + j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fatherArray[i] != sonArray[j]) &#123;</span><br><span class="line">                <span class="comment">//如果父串与子串当前字符不相等</span></span><br><span class="line">                <span class="keyword">if</span> (i == fatherLength - sonLength + j) &#123;</span><br><span class="line">                    <span class="comment">//这里说明子串已经是在和父串中最后可能想等的字符比较过了，并且后面也没有可比较的了，所以返回</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//如果父串的中间部分与子串匹配，且结果不相等</span></span><br><span class="line">                <span class="comment">//就从子串最后面开始，找出子串最后一位的下一位对应父串的字符在子串中是否存在</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> contains(sonArray, fatherArray[i - j + sonLength]);</span><br><span class="line">                <span class="keyword">if</span> (pos == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//不存在则直接跳到再下一位，子串从头开始</span></span><br><span class="line">                    i = i - j + sonLength + <span class="number">1</span>;</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//存在则将这个字符与子串最右边与它相同的字符对其,并再次从头开始比较</span></span><br><span class="line">                    i = i + sonLength - pos - j;</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果父串与子串当前字符相等</span></span><br><span class="line">                <span class="keyword">if</span> (j == sonLength - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果比较到了子串的最后一位，说明已经存在</span></span><br><span class="line">                    <span class="keyword">return</span> i - j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是子串最后一位，则进行下一个字符的对比</span></span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">father</span> <span class="operator">=</span> <span class="string">&quot;ABABEABABABABCBA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">son</span> <span class="operator">=</span> <span class="string">&quot;ABABC&quot;</span>;</span><br><span class="line">        System.out.println(search(father, son));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以改进，加一个偏移表</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20211027184220246.png" alt="image-20211027184220246"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxNum = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shift[maxNum];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sunday</span><span class="params">(<span class="type">const</span> string&amp; T, <span class="type">const</span> string&amp; P)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = T.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = P.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认值，移动m+1位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNum; i++) &#123;</span><br><span class="line">        shift[i] = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式串P中每个字母出现的最后的下标</span></span><br><span class="line">    <span class="comment">// 所对应的主串参与匹配的最末位字符的下一位字符移动到该位，所需要的移动位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        shift[P[i]] = m - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式串开始位置在主串的哪里</span></span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 模式串已经匹配到的位置</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(s &lt;= n - m) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(T[s + j] == P[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">// 匹配成功</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到主串中当前跟模式串匹配的最末字符的下一个字符</span></span><br><span class="line">        <span class="comment">// 在模式串中出现最后的位置</span></span><br><span class="line">        <span class="comment">// 所需要从(模式串末尾+1)移动到该位置的步数</span></span><br><span class="line">        s += shift[T[s + m]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">IN</span></span><br><span class="line"><span class="comment">at the thought of</span></span><br><span class="line"><span class="comment">though</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">OUT</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主串和模式串</span></span><br><span class="line">    string T, P;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取一行</span></span><br><span class="line">        <span class="built_in">getline</span>(cin, T);</span><br><span class="line">        <span class="built_in">getline</span>(cin, P);</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">Sunday</span>(T, P);</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;主串和模式串不匹配。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;模式串在主串的位置为：&quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>算法分析：</p>
<ul>
<li>Sunday预处理阶段的时间为：O(|∑|+ m)</li>
<li>最坏情况下时间复杂度为：O(nm)</li>
<li>平均时间复杂度：O(n)</li>
</ul>
<h2 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h2><p>对于数字类型，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] cnt = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ++cnt[n % <span class="number">10</span>];</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>字母类型，可以建立26个空间的char类型，考虑字典树。</p>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><p>通常使用动态规划+部分贪心的思想来解决。</p>
<p>递归+状态压缩+记忆化搜索    <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/can-i-win/">464. 我能赢吗 - 力扣（LeetCode）</a>   </p>
<h2 id="LIS问题"><a href="#LIS问题" class="headerlink" title="LIS问题"></a>LIS问题</h2><p>最长上升子序列问题</p>
<p>给定一个序列，如 [7, 9, 6, 10, 7, 1, 3 ], 求它的最长上升子序列的长度。 为[7, 9, 10]构成的，长度为3.</p>
<p>如果使用动态规划思想解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义 dp[i] 为以 ai 为末尾的最长上升子序列的长度。</span><br><span class="line"></span><br><span class="line">状态转移：dp[i] = max (dp[i], dp[j] + <span class="number">1</span>)   (<span class="number">0</span> &lt;= j &lt; i, a[j] &lt; a[i])</span><br><span class="line"></span><br><span class="line">边界处理：dp[i] = <span class="number">1</span> (<span class="number">0</span> &lt;= i &lt; n)</span><br><span class="line">   </span><br><span class="line">时间复杂度： O(n^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Ldp</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[i])</span><br><span class="line">            	dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>LIS的nlogn的优化：</p>
<p>使用 [维护单调序列 + 二分] 的贪心解法，是的时间复杂度为O(nlogn)</p>
<p>比如说（4, 2, 3, 1, 2，3，5）这个序列，求他的最长上升子序列，那么来看，如果求最长的上升序列，那么按照贪心，应该最可能的让该序列的元素整体变小，以便可以加入更多的元素。<br>现在开辟一个新的数组，arr[ 10 ]， { …….} –&gt; 这个是他的空间 ，现在开始模拟贪心算法求解最长上升子序列，第一个数是4，先加进去，那么为{ 4 }再来看下一个数2，它比4小，所以如果他与4替换是不是可以让目前子序列（他这一个元素组成的子序列）变得更小，更方便以后元素的加入呢？是的 。同时还保证了序列的长度不变，所以将大的数替换成小的是可以在保证序列长度不变的前提下是整体序列更小，更容易加入元素 。所以现在为{ 2 } 再来看他的下一个元素3，他要比2大，所以呢加在他的后面，{ 2, 3}<br>再看下一个元素是1，它比3要小，所以呢为了保证子序列整体尽可能的小（以便可以加入更多的元素），从目前的序列中查找出第一个比他大的数替换掉，那么就变成了{ 1， 3}，继续。。 下一个数是2，那么序列变为{ 1，2}，再下一个数为3，那么序列为{1，2，3}，在下一个数为5，那么序列为{1，2，3，5}，完。 目前序列里又4个元素，所以他的最长子序列的个数为4，但是这个序列是一个伪序列，里面的元素，并不是真正的最长上升子序列，而仅仅和最长上升子序列的个数一样。因为查找的时候用的二分查找，所以时间复杂度为o（nlogn）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LIS</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    dp[k] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[k] &lt; arr[i]) <span class="comment">//如果比最后一个元素大，那么就添加到单调序列的最后末尾处</span></span><br><span class="line">            dp[++k] = arr[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> binarySearch(dp, <span class="number">0</span>, k, arr[i]); <span class="comment">//如果比最后一个元素小，那么就替换该序列中第一个比它大的数</span></span><br><span class="line">        	dp[c] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在arr中从start开始到end结束的序列中找到第一个大于等于target元素的位置。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> start, r = end;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= target)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优雅的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || f[k] &lt; nums[i])</span><br><span class="line">                f[++k] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (f[mid] &gt;= nums[i])</span><br><span class="line">                        r = mid;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                f[r] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列 - 力扣</a></p>
<p>将求最长公共子序列的长度为dp问题 转化为 求最长上升子序列问题</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数 - 力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] target, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> target.length, m = arr.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            map.put(target[i], i);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(arr[i]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> map.get(arr[i]);</span><br><span class="line">                <span class="keyword">if</span> (k == -<span class="number">1</span> || f[k] &lt; t)</span><br><span class="line">                    f[++k] = t;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (f[mid] &gt;= t)</span><br><span class="line">                            r = mid;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    f[r] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - (k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























<h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><h3 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码 - 力扣</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220108175402366.png" alt="image-20220108175402366"></p>
<p>方式一：对称生成</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220108175608405.png" alt="image-20220108175608405"></p>
<p>逆序复制一遍，高位补1</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220108175546158.png" alt="image-20220108175546158"></p>
<p>方式二： 二进制数转格雷码</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220108175642590.png" alt="image-20220108175642590"></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220108175751064.png" alt="image-20220108175751064"></p>
<h2 id="几种树"><a href="#几种树" class="headerlink" title="几种树"></a>几种树</h2><h3 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h3><p>二叉查找&#x2F;二叉排序树</p>
<p>具有下列性质的二叉树：<br>（1）若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；<br>（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>（3）它的左、右子树也分别为二叉排序树</p>
<h3 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h3><p>称为自平衡二叉查找树  又被称为AVL树<br>它是一 棵空树或它的左右两个子树的高度差(平衡因子)的绝对值不超过1，<br>并且左右两个子树都是一棵平衡二叉树，<br>同时，平衡二叉树必定是二叉搜索树，反之则不一定</p>
<p>平衡二叉树的目的是为了减少二叉查找树层次，提高查找速度</p>
<p>平衡二叉树的常用实现方法有AVL、红黑树、替罪羊树、Treap、伸展树等</p>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/henuliulei/p/15114440.html">b树，b+树，b-树,红黑树详解一锅端 - 你的雷哥 - 博客园 (cnblogs.com)</a></p>
<p>平衡多路查找树，也叫B树</p>
<p>B树的出现是为了弥合不同的存储级别之间的访问速度上的巨大差异，实现高效的 I&#x2F;O。平衡二叉树的查找效率是非常高的，并可以通过降低树的深度来提高查找的效率。但是当数据量非常大，树的存储的元素数量是有限的，这样会导致二叉查找树结构由于树的深度过大而造成磁盘I&#x2F;O读写过于频繁，进而导致查询效率低下。另外数据量过大会导致内存空间不够容纳平衡二叉树所有结点的情况。B树是解决这个问题的很好的结构</p>
<p>B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： </p>
<ul>
<li>每个节点最多只有m个子节点。</li>
<li>每个非叶子节点（除了根）具有至少⌈ m&#x2F;2⌉子节点，含有ceil(m&#x2F;2)-1到m-1个元素。</li>
<li>如果根不是叶节点，则根至少有两个子节点。</li>
<li>具有<em>k</em>个子节点的非叶节点包含<em>k</em> -1个键。</li>
<li>所有叶子都出现在同一水平，没有任何信息（高度一致）。</li>
<li>B树的最大高度为log┌m&#x2F;2┐((N+1)&#x2F;2 )+1， m阶B树有N个关键码</li>
</ul>
<p><strong>插入</strong></p>
<p>针对m阶高度h的B树，插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。</p>
<ul>
<li>若该节点元素个数小于m-1，直接插入；</li>
<li>若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；</li>
<li>重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1；</li>
</ul>
<p><strong>删除</strong></p>
<p>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素，前驱和后继(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除。这样将问题归结为在终端结点删除元素。</p>
<ul>
<li>若终端结点删除一个关键码后，其元素数目小于⌈m&#x2F;2⌉-1,(m&#x2F;2)向上取整，则需要看其某相邻兄弟结点是否丰满；</li>
<li>如果丰满（结点中元素个数大于(m&#x2F;2)-1），则向父节点借一个元素来满足条件；</li>
<li>如果其相邻兄弟都不丰满，即其结点数目等于(m&#x2F;2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；</li>
</ul>
<p>磁盘读写原理</p>
<p><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/eabf311f51794625b1fd87d392c4f45d">扇区、磁盘块、页。磁盘是如何存储数据的：磁盘的物理结构_牛客博客 (nowcoder.net)</a></p>
<p>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。</p>
<p>读&#x2F;写磁盘上某一指定数据需要下面3个步骤：</p>
<p>(1) 首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。</p>
<p>(2) 如上图11.3中所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。</p>
<p>(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。</p>
<p>经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读&#x2F;写操作了。</p>
<p>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1&#x2F;120&#x2F;2 &#x3D; 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</p>
<p>硬盘的读写以扇区为基本单位， <strong>文件系统的读写数据是以盘块</strong>(block)<strong>为基本单位的。</strong> 操作系统将相邻的扇区组合在一起形成盘块，位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读&#x2F;<strong>写信息时尽量减少磁头来回移动的次数，避免过多的查找时间</strong>Ts<strong>。</strong></p>
<p>从以上数据中可以总结出一个道理，索引查询的数据主要受限于硬盘的I&#x2F;O速度，查询I&#x2F;O次数越少，速度越快，所以B树的结构才应需求而生；B树的每个节点的元素可以视为一次I&#x2F;O读取，树的高度表示最多的I&#x2F;O次数，在相同数量的总元素个数下，<strong>每个节点的元素个数越多，高度越低，查询所需的I&#x2F;O次数越少</strong>；假设，一次硬盘一次I&#x2F;O数据为8K，索引用int(4字节)类型数据建立，理论上一个节点最多可以为2000个元素，2000<em>2000</em>2000&#x3D;8000000000，80亿条的数据只需3次I&#x2F;O（理论值），可想而知，B树做为索引的查询效率有多高；</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tgycoder/p/5077017.html">关于B树的一些总结 - RunningSnail - 博客园 (cnblogs.com)</a></p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>推荐  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149287061">B+树看这一篇就够了（B+树查找、插入、删除全上） - 知乎 (zhihu.com)</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiang_wang01/article/details/113739230"> 什么是B+树？（详细图解）_初念初恋的博客-CSDN博客_b+树</a></p>
<p>一个m阶的B+树具有如下几个特征：</p>
<ol>
<li><p>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
</li>
<li><p>所有的叶子结点中包含了全部关键字的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
</li>
<li><p>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>
</li>
<li><p>除根结点外，内部结点最少有ceil(m&#x2F;2)个关键字和ceil(m&#x2F;2) 个指向子树的指针，最多有m个关键字和m个指向子树的指针</p>
</li>
<li><p>B+树的根节点最少有2个key和2个指向子树的指针</p>
</li>
</ol>
<p><strong>为什么说B+树比B树更适合数据库索引？</strong></p>
<p>1）B+树的磁盘读写代价更低</p>
<p>　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；</p>
<p>2）B+树查询效率更加稳定</p>
<p>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p>
<p>3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态）</p>
<p>　　B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历（找到一个值之后，进行连表查询）。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低（找到一个之后，进行中序遍历）；</p>
<p>B+树插入</p>
<p>B+树中做插入关键字的操作，有以下 3 种情况：</p>
<p>1、 若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入；</p>
<p>2、 若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含 <code>⌊M/2⌋</code> ，另一个结点包含 <code>⌈M/2⌉</code> 。同时，将<code>⌈M/2⌉</code>的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。</p>
<p>3、在第 2 情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。</p>
<p>4、若插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。</p>
<p>B+树删除</p>
<p>在 B+树中做删除关键字的操作，采取如下的步骤：</p>
<ol>
<li>删除该关键字，如果不破坏 B+树本身的性质，直接完成删除操作（情况 1）；</li>
<li>如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值（情况 2）；</li>
<li>在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并（情况 3、4 和 5）。（注意这两种方式有时需要更改其父结点中的索引值。）</li>
</ol>
<h3 id="红黑树（red-block-tree"><a href="#红黑树（red-block-tree" class="headerlink" title="红黑树（red-block tree)"></a>红黑树（red-block tree)</h3><p>特点</p>
<ol>
<li>结点分为红色和黑色</li>
<li>根结点为黑色</li>
<li>叶子结点都为黑色，且为null，不存储任何数据</li>
<li>相邻的两个结点不能同时为红色，红色结点是被黑色结点隔开</li>
<li>从任意结点出发，到其可达的叶子结点，路径上的黑色结点数量是相同的</li>
<li>新加入红黑树的结点为红色结点</li>
</ol>
<p>左旋和右旋</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324140604258.png" alt="image-20220324140604258"></p>
<p>插入</p>
<p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫做关注节点。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p>
<p>case1.</p>
<p>如果关注节点a，父亲结点是红色的，叔叔结点也是红色</p>
<ul>
<li>将父亲结点和叔叔结点变为黑色</li>
<li>祖父结点和点a标记为相同颜色，为红色</li>
<li>关注结点a变成了祖父结点</li>
<li>重复上述操作，直到祖父为根结点标记为黑色</li>
</ul>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324141238694.png" alt="image-20220324141238694"></p>
<p>case2.</p>
<p>如果x的父节点是红色的，叔叔节点是黑色的，分以下四种情况</p>
<ol>
<li>左左（P(父节点)是G(祖父结点)的左孩子，X是P的左孩子）</li>
<li>左右（P(父节点)是G(祖父结点)的左孩子，X是P的右孩子）</li>
<li>右右（P(父节点)是G(祖父结点)的右孩子，X是P的右孩子）</li>
<li>右左（P(父节点)是G(祖父结点)的右孩子，X是P的左孩子）</li>
</ol>
<p>左左时</p>
<p>围绕关注节点X的<strong>祖父结点G右旋</strong>，P和G颜色互换<strong>变色</strong>，调整结束</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324142111436.png" alt="image-20220324142111436"></p>
<p>左右时</p>
<p>围绕着关注结点X的<strong>父节点P左旋</strong>，关注结点变为P，<strong>在进行左左操作</strong>，即，G右旋，互换颜色</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324142510134.png" alt="image-20220324142510134"></p>
<p>右右时</p>
<p><strong>祖父结点左旋，p和g换色</strong></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324142934086.png" alt="image-20220324142934086"></p>
<p>右左时</p>
<p>以X的父节点为关注点，进行右旋，进行右旋操作，祖父结点左旋，换色。</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220324143043076.png" alt="image-20220324143043076"></p>
<p>删除</p>
<h2 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h2><p><strong>两个向量叉乘：</strong></p>
<p>断两个向量之间夹角是顺时针还是逆时针，利用平面向量的叉乘，a &#x3D; (x1,y1) b &#x3D; (x2,y2)<br>a×b &#x3D; x1y2 - x2y1<br>若结果为正，则向量b在a的逆时针方向<br>否则，b在a的顺时针方向<br>若结果为0，则a与b共线</p>
<p> Andrew 算法</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/erect-the-fence/solution/by-ac_oier-4xuu/">【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] subtraction(<span class="type">int</span>[] a, <span class="type">int</span>[] b) &#123; <span class="comment">// 向量相减</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a[<span class="number">0</span>] - b[<span class="number">0</span>], a[<span class="number">1</span>] - b[<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">cross</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123; <span class="comment">// 叉乘</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] * b[<span class="number">1</span>] - a[<span class="number">1</span>] * b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b, <span class="type">int</span>[] c)</span> &#123; <span class="comment">// 向量 ab 转为 向量 ac 过程中扫过的面积</span></span><br><span class="line">        <span class="keyword">return</span> cross(subtraction(b, a), subtraction(c, a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] outerTrees(<span class="type">int</span>[][] trees) &#123;</span><br><span class="line">        Arrays.sort(trees, (a, b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> trees.length, tp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] stk = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">10</span>];</span><br><span class="line">        stk[++tp] = <span class="number">0</span>; <span class="comment">// 不标记起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] c = trees[i];</span><br><span class="line">            <span class="keyword">while</span> (tp &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] a = trees[stk[tp - <span class="number">1</span>]], b = trees[stk[tp]];</span><br><span class="line">                <span class="keyword">if</span> (getArea(a, b, c) &lt; <span class="number">0</span>) vis[stk[tp--]] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++tp] = i;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> tp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span>[] c = trees[i];</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; size) &#123;</span><br><span class="line">                <span class="type">int</span>[] a = trees[stk[tp - <span class="number">1</span>]], b = trees[stk[tp]];</span><br><span class="line">                <span class="keyword">if</span> (getArea(a, b, c) &lt; <span class="number">0</span>) tp--;</span><br><span class="line">                <span class="comment">// vis[stk[tp--]] = false; // 非必须</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++tp] = i;</span><br><span class="line">            <span class="comment">// vis[i] = true; // 非必须</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[tp - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; tp; i++) ans[i - <span class="number">1</span>] = trees[stk[i]];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="蓄水池抽样"><a href="#蓄水池抽样" class="headerlink" title="蓄水池抽样"></a>蓄水池抽样</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typoraimage-20220425123200670.png" alt="image-20220425123200670"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">20220116</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(ListNode _head)</span> &#123;</span><br><span class="line">        head = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">null</span> &amp;&amp; ++idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (random.nextInt(idx) == <span class="number">0</span>) ans = t.val;</span><br><span class="line">            t = t.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘 - 力扣（LeetCode）</a></p>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>思想</p>
<ol>
<li>先从数组中找一个基数（一般为头元素）</li>
<li>让其他比他大的元素移动到一边，让其他比他小的元素移动到另一边，从而把数组拆分成两部分</li>
<li>再对左右两个区间重复一二两步，直到各区间只有一个元素。</li>
</ol>
<p>虽然归并排序和快速排序都用到了分治思想，但是归并排序是自下而上的，先处理子问题，然后再合并，将小集合合成大集合，最后实现排序。而快速排序是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题</p>
<p>我们根据思想可知，排序算法的核心就是如何利用基准数将记录分区，这里我们主要介绍两种容易理解的方法，一种是挖坑填数，另一种是利用双指针思想进行元素交换</p>
<p>方法一：挖坑填数</p>
<p>以序列的第一个元素为基准数，然后将该位置挖坑，high指针从后往前移动直到找到一个比基准数小的数，将该数放到已挖坑的位置，这样high这个位置就是一个新坑了，然后low指针从前往后移动直到找到一个比基数大的，放到新坑中，不断迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(nums, low, high);</span><br><span class="line">            quickSort(nums, low, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, index + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="comment">// 移动high指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 填坑</span></span><br><span class="line">            <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">                nums[low] = nums[high];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= pivot)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填坑</span></span><br><span class="line">            <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">                nums[high] = nums[low];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准数放到合适的位置</span></span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">test</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">        nums =  main.sortArray(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二 前后交换（推荐）</p>
<p>low 指针找到大于 pivot 的元素，hight 指针找到小于 pivot 的元素，然后两个元素交换位置，最后再将基准数归位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(nums, low, high);</span><br><span class="line">            quickSort(nums, low, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, index + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="comment">// 移动high指针 </span></span><br><span class="line">            <span class="comment">// 注意连个指针移动的次序不能变，先移动high指针，在移动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= pivot)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">                swap(nums, low, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准数归位</span></span><br><span class="line">        swap(nums, start, low);</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">test</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">        nums =  main.sortArray(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h4><p>由快速排序算法延伸出快速选择算法，用于在一组无序数中找到第k小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="comment">// 移动high指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动low指针</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= pivot)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">                swap(nums, low, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准数归位</span></span><br><span class="line">        swap(nums, start, low);</span><br><span class="line">        <span class="keyword">if</span> (low == k - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (low &lt; k - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, low + <span class="number">1</span>, high, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, start, low - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">test</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> main.quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的基本思想是对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。</p>
<p>算法过程：</p>
<ol>
<li>根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；</li>
<li>遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；</li>
<li>对额外空间内数据进行计算，得出每一个元素的正确位置；</li>
<li>将待排序集合每一个元素移动到计算得出的正确位置上。</li>
</ol>
<p>例子：</p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220804103558820.png" alt="image-20220804103558820"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSort(<span class="type">int</span>[] A) &#123;</span><br><span class="line">    <span class="comment">// 找出数组A中的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化计数数组count</span></span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 对计数数组各元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">        count[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建结果数组</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[A.length];</span><br><span class="line">    <span class="comment">// 创建结果数组的起始索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历计数数组，将计数数组的索引填充到结果数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            result[index++] = i;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化版 ：避免空间浪费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSort2(<span class="type">int</span>[] A) &#123;</span><br><span class="line">    <span class="comment">// 找出数组A中的最大值、最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化计数数组count</span></span><br><span class="line">    <span class="comment">// 长度为最大值减最小值加1</span></span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 对计数数组各元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">        <span class="comment">// A中的元素要减去最小值，再作为新索引</span></span><br><span class="line">        count[num-min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建结果数组</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[A.length];</span><br><span class="line">    <span class="comment">// 创建结果数组的起始索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历计数数组，将计数数组的索引填充到结果数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 再将减去的最小值补上</span></span><br><span class="line">            result[index++] = i+min;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n + k)</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表 - 力扣（LeetCode）</a></p>
<p><img src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-20220801150018238.png" alt="image-20220801150018238"></p>
<p>跳表相对于单链表，则是通过引入「多层」链表来优化查找过程，其中每层链表均是「有序」链表：</p>
<p>对于单链表的 Node 设计而言，我们只需存储对应的节点值 val，以及当前节点的下一节点的指针 ne 即可（ne 为一指针变量）</p>
<p>对于跳表来说，除了存储对应的节点值 val 以外，我们需要存储当前节点在「每一层」的下一节点指针 ne（ne 为指针数组）</p>
<p>跳表的 level 编号从下往上递增，最下层的链表为元素最全的有序单链表，而查找过程则是按照 level 从上往下进行。</p>
<p>同时为了简化，建立一个哨兵节点 he，哨兵值的值应当足够小（根据数据范围，设定为 -1 即可），所有的操作（假设当前操作的传入值为 t），先进行统一化的查找：查找出每一层比 t 严格小的最后一个节点，将其存成 ns 数组。即 ns[i] 为 level &#x3D; i层严格比 t 小的最后一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line">    Node he;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_LEVEL</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Skiplist</span><span class="params">()</span> &#123;</span><br><span class="line">        he = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, MAX_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> t, Node[] ns)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> he;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MAX_LEVEL - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.ne[i] != <span class="literal">null</span> &amp;&amp; cur.ne[i].val &lt; t)</span><br><span class="line">                cur = cur.ne[i];</span><br><span class="line">            ns[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// ns[] : 每一层中比target严格小的最后一个节点</span></span><br><span class="line">        Node[] ns = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">        find(target, ns);</span><br><span class="line">        <span class="keyword">return</span> ns[<span class="number">0</span>].ne[<span class="number">0</span>] != <span class="literal">null</span> &amp;&amp; ns[<span class="number">0</span>].ne[<span class="number">0</span>].val == target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        Node[] ns = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">        find(num, ns);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(num, MAX_LEVEL);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_LEVEL; i++)&#123;</span><br><span class="line">            node.ne[i] = ns[i].ne[i];</span><br><span class="line">            ns[i].ne[i] = node;</span><br><span class="line">            <span class="keyword">if</span> (random.nextInt(<span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">erase</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        Node[] ns = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">        find(num, ns);</span><br><span class="line">        <span class="keyword">if</span> (ns[<span class="number">0</span>].ne[<span class="number">0</span>] == <span class="literal">null</span> || ns[<span class="number">0</span>].ne[<span class="number">0</span>].val != num)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> ns[<span class="number">0</span>].ne[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_LEVEL; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ns[i].ne[i] == node)&#123;</span><br><span class="line">                ns[i].ne[i] = ns[i].ne[i].ne[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node[] ne;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> maxLevel)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        ne = <span class="keyword">new</span> <span class="title class_">Node</span>[maxLevel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>由于我们是均匀的选取n&#x2F;2个元素作为上一层的元素，我们也可以采用随机的方式，也就是在链表中随机的选取n&#x2F;2个元素作为他的上一层元素，并且当原始链表中元素数量足够大，且抽取足够随机的话，我们得到的上层元素是均匀的。于是我们可以在每次新插入元素的时候，一定要插入第一层，有1&#x2F;2的概率插入第二层、1&#x2F;4的概率插入第三层、1&#x2F;8的概率插入第四层。当每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几层中。（SKIPLIST_P配置0.5 实际代码参考了Redis中zset配置了0.25 也就是1&#x2F;4的概率插入第二层、1&#x2F;16的概率插入第三层依次类推）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且</span></span><br><span class="line"><span class="comment">     * 1/2 的概率返回 2</span></span><br><span class="line"><span class="comment">     * 1/4 的概率返回 3</span></span><br><span class="line"><span class="comment">     * 1/8 的概率返回 4 以此类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1</span></span><br><span class="line">    <span class="keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>又叫散列表</p>
<p>散列表的实现叫做散列，散列是以常数平均时间执行插入、删除和查找的技术。</p>
<p>散列过程分为两步：</p>
<ol>
<li>通过散列函数计算记录的散列地址，并按此散列地址存储该记录。</li>
<li>当查找时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。</li>
</ol>
<p><strong>散列函数构造方法</strong></p>
<ol>
<li><p>直接寻址法</p>
<p>取关键字或关键字的某个线性函数值作为散列地址</p>
</li>
<li><p>数字分析法</p>
<p>分析我们的关键字，取其中一段，或对其位移，叠加，用作地址。比如学号，前6位都是一样的，后面3位不一样，则可用后三位来构造散列地址</p>
</li>
<li><p>平方取中法</p>
<p>当无法确定关键字哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p>
</li>
<li><p>取随机数法</p>
<p>使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</p>
</li>
<li><p>除留取余法</p>
<p>取关键字被某个不大于散列表的表长n的数m除后所得的余数p位散列地址。这种方式也可以在用过其他方法后再使用。该函数对m的选择比较重要，一般取素数或者直接用n。</p>
</li>
</ol>
<p><strong>哈希冲突的解决方法</strong></p>
<ol>
<li><p>开放地址法</p>
<p>一旦发生冲突，就去寻找下一个空的散列地址，只要表足够大，空的散列地址总能找到，寻找空的地址，称为探查，常用的有线性探测、二次探测和随机探测。</p>
<ul>
<li><p>线性探测</p>
<p>当往散列表中插入数据时，经过散列函数发现位置已经被占用了，我们就从当前位置开始，依次往后查找，直到找到空闲位置为止。</p>
</li>
<li><p>二次探测</p>
<p>二次探索，和线性探索原理一样，先行探索每次的步长为 1 ，探索的下标依次为 hash(key)+0，hash(key)+1，hash(key)+2…，二次探索每次的步长变为原来的二次方，所以每次探索的下边为 hash(key)+0，hash(key)+1^2， hash(key)+2^2。</p>
<p>二次探测法的目的就是为了不让关键字聚集在某一块区域。</p>
</li>
<li><p>随机探测法</p>
</li>
</ul>
</li>
<li><p>再哈希法</p>
<p>发生冲突的时候，利用不同的哈希函数再求得一个哈希地址，直到不出现冲突为止</p>
</li>
<li><p>链地址法</p>
<p>将通过哈希函数落在同一个地址上的值，做一个链表</p>
</li>
<li><p>公共溢出区法</p>
<p>为所有冲突的关键字建立一个公共的溢出区来存放，查找时，首先通过散列函数计算出散列地址后，先和基本表对比，如果不相等再到溢出表去顺序查找。</p>
</li>
</ol>
<p><strong>散列表的装填因子</strong></p>
<p>装填因子α &#x3D; 填入表中的记录数 &#x2F;  散列表的长度</p>
<p>散列因子则代表散列表的装满程度，表中的记录越多，α越大，产生冲突的概率越大。</p>
<p>当散列表的装载因子过大的时候，散列表的空闲位置变得很少，散列冲突的概率就变得很大，而且插入和查找数据的效率也会变得很低。 这个时候我们就需要对散列表动态扩容，重新申请一个更大的散列表，然后把原有的数据移到新的散列表中。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>在力扣中一般时间复杂度达到10^8会超时，10^7一般可以通过</p>
</li>
<li><p>有泛型的数据作为形参的时候，要把泛型的类型在参数列表中显示出来，不然在方法中使用的时候可能会出错， 例如</p>
<p><code>public int[] findSwap(List&lt;Integer&gt; list)&#123;&#125;</code></p>
</li>
<li></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cobwebzh.top">可乐就炸鸡</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cobwebzh.top/2022/10/18/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/%E5%88%B7%E9%A2%98/">https://cobwebzh.top/2022/10/18/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/%E5%88%B7%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cobwebzh.top" target="_blank">可乐就炸鸡の葵花宝典</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/111" target="_blank"><img class="post-qr-code-img" src="https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202210241925598.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/18/%E9%A1%B9%E7%9B%AE/MyDB/"><img class="prev-cover" src="https://api.ghser.com/random/api.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MyDB</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/18/%E4%B9%9D%E9%98%B3%E7%A5%9E%E5%8A%9F/Redis/"><img class="next-cover" src="https://api.ghser.com/random/api.php" onerror="onerror=null;src='https://cobweb-post-images.oss-cn-beijing.aliyuncs.com/typora/image-202207050039612.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%A4%8D%E7%9B%98%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">需要复盘的题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.1.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DP"><span class="toc-number">2.2.</span> <span class="toc-text">DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97DP"><span class="toc-number">2.2.1.</span> <span class="toc-text">序列DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="toc-number">2.2.2.</span> <span class="toc-text">区间DP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-number">2.3.</span> <span class="toc-text">背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85"><span class="toc-number">2.3.1.</span> <span class="toc-text">0-1背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">2.3.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">2.3.3.</span> <span class="toc-text">多重背包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">3.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.1.</span> <span class="toc-text">广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.1.1.</span> <span class="toc-text">朴素广度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">双向广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.2.</span> <span class="toc-text">深度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%EF%BC%88A-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">启发式搜索（A*算法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87"><span class="toc-number">4.</span> <span class="toc-text">回文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">5.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">7.</span> <span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">区间问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">8.1.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">8.1.1.</span> <span class="toc-text">二维前缀和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%EF%BC%88BIT%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">树状数组 （BIT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">8.3.</span> <span class="toc-text">差分数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">8.4.</span> <span class="toc-text">线段树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">数组复制：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%85%E5%85%8B%E9%9A%86"><span class="toc-number">9.1.</span> <span class="toc-text">1. 浅克隆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="toc-number">9.2.</span> <span class="toc-text">2. 深克隆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%ACList"><span class="toc-number">10.</span> <span class="toc-text">数组转List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#int%E6%95%B0%E7%BB%84%E8%BD%ACInteger%E6%95%B0%E7%BB%84"><span class="toc-number">10.1.</span> <span class="toc-text">int数组转Integer数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E6%95%B0%E7%BB%84%E8%BD%ACint"><span class="toc-number">10.2.</span> <span class="toc-text">Integer数组转int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E8%BD%ACCharacter%E6%95%B0%E7%BB%84"><span class="toc-number">10.3.</span> <span class="toc-text">String转Character数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">10.4.</span> <span class="toc-text">数组求和，获取最大值、最小值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">12.</span> <span class="toc-text">字典树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">13.</span> <span class="toc-text">二叉树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">13.1.</span> <span class="toc-text">中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">13.1.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">13.1.2.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">13.1.3.</span> <span class="toc-text">Morris 中序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">13.2.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">13.3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">14.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9B%BE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">14.1.</span> <span class="toc-text">存图的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">14.2.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd"><span class="toc-number">14.2.1.</span> <span class="toc-text">Floyd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra"><span class="toc-number">14.2.2.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bellman-Ford"><span class="toc-number">14.2.3.</span> <span class="toc-text">Bellman Ford</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPFA"><span class="toc-number">14.2.4.</span> <span class="toc-text">SPFA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">14.3.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim"><span class="toc-number">14.3.1.</span> <span class="toc-text">Prim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal"><span class="toc-number">14.3.2.</span> <span class="toc-text">Kruskal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%9B%BE"><span class="toc-number">14.4.</span> <span class="toc-text">遍历图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">14.5.</span> <span class="toc-text">拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">15.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">16.</span> <span class="toc-text">优先队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">17.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Treemap"><span class="toc-number">18.</span> <span class="toc-text">Treemap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">19.</span> <span class="toc-text">Java集合的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">20.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%87%E5%8C%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">均匀生成随机数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">22.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">22.1.</span> <span class="toc-text">一维数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E3%80%81%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F"><span class="toc-number">22.2.</span> <span class="toc-text">二维数组、集合排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">22.3.</span> <span class="toc-text">对象排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">23.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">23.1.</span> <span class="toc-text">内置基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%84%9F%E6%95%B0%E5%AD%97"><span class="toc-number">23.2.</span> <span class="toc-text">敏感数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">24.1.</span> <span class="toc-text">字符串哈希</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">25.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML%E5%9B%BE"><span class="toc-number">26.</span> <span class="toc-text">UML图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">27.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">28.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays-binarySearch-%E6%96%B9%E6%B3%95"><span class="toc-number">28.1.</span> <span class="toc-text">Arrays.binarySearch()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81-%E5%BF%AB%E9%80%9F%E4%B9%98"><span class="toc-number">29.</span> <span class="toc-text">快速幂、 快速乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">30.</span> <span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">31.</span> <span class="toc-text">计算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="toc-number">32.</span> <span class="toc-text">摩尔投票法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1BST%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89"><span class="toc-number">33.</span> <span class="toc-text">抽象BST（二叉搜索树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">34.</span> <span class="toc-text">字符串匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BF"><span class="toc-number">34.1.</span> <span class="toc-text">1. BF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RK%E7%AE%97%E6%B3%95%EF%BC%88%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89"><span class="toc-number">34.2.</span> <span class="toc-text">2. RK算法（哈希算法的应用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-KPM"><span class="toc-number">34.3.</span> <span class="toc-text">3. KPM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BM"><span class="toc-number">34.4.</span> <span class="toc-text">4. BM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Sunday%E7%AE%97%E6%B3%95"><span class="toc-number">34.5.</span> <span class="toc-text">5. Sunday算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1"><span class="toc-number">35.</span> <span class="toc-text">词频统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-number">36.</span> <span class="toc-text">博弈论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIS%E9%97%AE%E9%A2%98"><span class="toc-number">37.</span> <span class="toc-text">LIS问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86"><span class="toc-number">38.</span> <span class="toc-text">常识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E9%9B%B7%E7%A0%81"><span class="toc-number">38.1.</span> <span class="toc-text">格雷码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E6%A0%91"><span class="toc-number">39.</span> <span class="toc-text">几种树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">39.1.</span> <span class="toc-text">二叉搜索树（BST）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">39.2.</span> <span class="toc-text">二叉平衡树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree"><span class="toc-number">39.3.</span> <span class="toc-text">B-tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">39.4.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88red-block-tree"><span class="toc-number">39.5.</span> <span class="toc-text">红黑树（red-block tree)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">40.</span> <span class="toc-text">凸包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7"><span class="toc-number">41.</span> <span class="toc-text">蓄水池抽样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">42.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">42.1.</span> <span class="toc-text">快排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-number">42.1.1.</span> <span class="toc-text">快速选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">42.2.</span> <span class="toc-text">计数排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">43.</span> <span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">44.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">45.</span> <span class="toc-text">注意</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022.07 - 2023 By 可乐就炸鸡</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>